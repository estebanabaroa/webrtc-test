(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function t(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function r(s){if(s.ep)return;s.ep=!0;const i=t(s);fetch(s.href,i)}})();const Ph=Symbol.for("@libp2p/connection"),ha=Symbol.for("@libp2p/content-routing"),fa=Symbol.for("@libp2p/peer-discovery"),vo=Symbol.for("@libp2p/peer-id");function Zn(n){return!!n?.[vo]}const pa=Symbol.for("@libp2p/peer-routing"),So="keep-alive",xo=Symbol.for("@libp2p/transport");var or;(function(n){n[n.FATAL_ALL=0]="FATAL_ALL",n[n.NO_FATAL=1]="NO_FATAL"})(or||(or={}));let Bt=class extends Error{static name="AbortError";constructor(e="The operation was aborted"){super(e),this.name="AbortError"}};class Dh extends Error{static name="UnexpectedPeerError";constructor(e="Unexpected Peer"){super(e),this.name="UnexpectedPeerError"}}let Lh=class extends Error{static name="InvalidCryptoExchangeError";constructor(e="Invalid crypto exchange"){super(e),this.name="InvalidCryptoExchangeError"}},K=class extends Error{static name="InvalidParametersError";constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}};class gl extends Error{static name="InvalidPublicKeyError";constructor(e="Invalid public key"){super(e),this.name="InvalidPublicKeyError"}}class kh extends Error{static name="ConnectionClosingError";constructor(e="The connection is closing"){super(e),this.name="ConnectionClosingError"}}class ml extends Error{static name="ConnectionClosedError";constructor(e="The connection is closed"){super(e),this.name="ConnectionClosedError"}}class yl extends Error{static name="ConnectionFailedError";constructor(e="Connection failed"){super(e),this.name="ConnectionFailedError"}}class Bn extends Error{static name="MuxerClosedError";constructor(e="The muxer is closed"){super(e),this.name="MuxerClosedError"}}class Rh extends Error{static name="StreamResetError";constructor(e="The stream has been reset"){super(e),this.name="StreamResetError"}}class Wi extends Error{static name="StreamStateError";constructor(e="The stream is in an invalid state"){super(e),this.name="StreamStateError"}}let Vi=class extends Error{static name="NotFoundError";constructor(e="Not found"){super(e),this.name="NotFoundError"}};class wl extends Error{static name="InvalidPeerIdError";constructor(e="Invalid PeerID"){super(e),this.name="InvalidPeerIdError"}}let Ao=class extends Error{static name="InvalidMultiaddrError";constructor(e="Invalid multiaddr"){super(e),this.name="InvalidMultiaddrError"}};class Nh extends Error{static name="InvalidCIDError";constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}}class Oh extends Error{static name="InvalidMultihashError";constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}}class _o extends Error{static name="UnsupportedProtocolError";constructor(e="Unsupported protocol error"){super(e),this.name="UnsupportedProtocolError"}}class Je extends Error{static name="InvalidMessageError";constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}}class Mh extends Error{static name="ProtocolError";constructor(e="Protocol error"){super(e),this.name="ProtocolError"}}let Co=class extends Error{static name="TimeoutError";constructor(e="Timed out"){super(e),this.name="TimeoutError"}};class is extends Error{static name="NotStartedError";constructor(e="Not started"){super(e),this.name="NotStartedError"}}class jn extends Error{static name="DialError";constructor(e="Dial error"){super(e),this.name="DialError"}}class Hi extends Error{static name="ListenError";constructor(e="Listen error"){super(e),this.name="ListenError"}}class bl extends Error{static name="LimitedConnectionError";constructor(e="Limited connection"){super(e),this.name="LimitedConnectionError"}}class Fh extends Error{static name="TooManyInboundProtocolStreamsError";constructor(e="Too many inbound protocol streams"){super(e),this.name="TooManyInboundProtocolStreamsError"}}class El extends Error{static name="TooManyOutboundProtocolStreamsError";constructor(e="Too many outbound protocol streams"){super(e),this.name="TooManyOutboundProtocolStreamsError"}}class Io extends Error{static name="UnsupportedKeyTypeError";constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}}class nt extends EventTarget{#e=new Map;constructor(){super()}listenerCount(e){const t=this.#e.get(e);return t==null?0:t.length}addEventListener(e,t,r){super.addEventListener(e,t,r);let s=this.#e.get(e);s==null&&(s=[],this.#e.set(e,s)),s.push({callback:t,once:(r!==!0&&r!==!1&&r?.once)??!1})}removeEventListener(e,t,r){super.removeEventListener(e.toString(),t??null,r);let s=this.#e.get(e);s!=null&&(s=s.filter(({callback:i})=>i!==t),this.#e.set(e,s))}dispatchEvent(e){const t=super.dispatchEvent(e);let r=this.#e.get(e.type);return r==null||(r=r.filter(({once:s})=>!s),this.#e.set(e.type,r)),t}safeDispatchEvent(e,t={}){return this.dispatchEvent(new CustomEvent(e,t))}}function To(n){return n!=null&&typeof n.start=="function"&&typeof n.stop=="function"}async function vl(...n){const e=[];for(const t of n)To(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStart!=null&&await t.beforeStart()})),await Promise.all(e.map(async t=>{await t.start()})),await Promise.all(e.map(async t=>{t.afterStart!=null&&await t.afterStart()}))}async function Sl(...n){const e=[];for(const t of n)To(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStop!=null&&await t.beforeStop()})),await Promise.all(e.map(async t=>{await t.stop()})),await Promise.all(e.map(async t=>{t.afterStop!=null&&await t.afterStop()}))}const Ye=Symbol.for("@libp2p/service-capabilities"),os=Symbol.for("@libp2p/service-dependencies");function Uh(n,e){if(n===e)return!0;if(n.byteLength!==e.byteLength)return!1;for(let t=0;t<n.byteLength;t++)if(n[t]!==e[t])return!1;return!0}function qs(n){if(n instanceof Uint8Array&&n.constructor.name==="Uint8Array")return n;if(n instanceof ArrayBuffer)return new Uint8Array(n);if(ArrayBuffer.isView(n))return new Uint8Array(n.buffer,n.byteOffset,n.byteLength);throw new Error("Unknown type, must be binary type")}function Bh(n){return new TextEncoder().encode(n)}function $h(n){return new TextDecoder().decode(n)}function qh(n,e){if(n.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),r=0;r<t.length;r++)t[r]=255;for(var s=0;s<n.length;s++){var i=n.charAt(s),o=i.charCodeAt(0);if(t[o]!==255)throw new TypeError(i+" is ambiguous");t[o]=s}var a=n.length,c=n.charAt(0),u=Math.log(a)/Math.log(256),l=Math.log(256)/Math.log(a);function d(g){if(g instanceof Uint8Array||(ArrayBuffer.isView(g)?g=new Uint8Array(g.buffer,g.byteOffset,g.byteLength):Array.isArray(g)&&(g=Uint8Array.from(g))),!(g instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(g.length===0)return"";for(var m=0,f=0,w=0,v=g.length;w!==v&&g[w]===0;)w++,m++;for(var x=(v-w)*l+1>>>0,L=new Uint8Array(x);w!==v;){for(var E=g[w],T=0,k=x-1;(E!==0||T<f)&&k!==-1;k--,T++)E+=256*L[k]>>>0,L[k]=E%a>>>0,E=E/a>>>0;if(E!==0)throw new Error("Non-zero carry");f=T,w++}for(var D=x-f;D!==x&&L[D]===0;)D++;for(var y=c.repeat(m);D<x;++D)y+=n.charAt(L[D]);return y}function h(g){if(typeof g!="string")throw new TypeError("Expected String");if(g.length===0)return new Uint8Array;var m=0;if(g[m]!==" "){for(var f=0,w=0;g[m]===c;)f++,m++;for(var v=(g.length-m)*u+1>>>0,x=new Uint8Array(v);g[m];){var L=t[g.charCodeAt(m)];if(L===255)return;for(var E=0,T=v-1;(L!==0||E<w)&&T!==-1;T--,E++)L+=a*x[T]>>>0,x[T]=L%256>>>0,L=L/256>>>0;if(L!==0)throw new Error("Non-zero carry");w=E,m++}if(g[m]!==" "){for(var k=v-w;k!==v&&x[k]===0;)k++;for(var D=new Uint8Array(f+(v-k)),y=f;k!==v;)D[y++]=x[k++];return D}}}function p(g){var m=h(g);if(m)return m;throw new Error(`Non-${e} character`)}return{encode:d,decodeUnsafe:h,decode:p}}var zh=qh,Kh=zh;class Wh{name;prefix;baseEncode;constructor(e,t,r){this.name=e,this.prefix=t,this.baseEncode=r}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}let Vh=class{name;prefix;baseDecode;prefixCodePoint;constructor(e,t,r){this.name=e,this.prefix=t;const s=t.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=r}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return xl(this,e)}};class Hh{decoders;constructor(e){this.decoders=e}or(e){return xl(this,e)}decode(e){const t=e[0],r=this.decoders[t];if(r!=null)return r.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function xl(n,e){return new Hh({...n.decoders??{[n.prefix]:n},...e.decoders??{[e.prefix]:e}})}class Gh{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(e,t,r,s){this.name=e,this.prefix=t,this.baseEncode=r,this.baseDecode=s,this.encoder=new Wh(e,t,r),this.decoder=new Vh(e,t,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}function zs({name:n,prefix:e,encode:t,decode:r}){return new Gh(n,e,t,r)}function br({name:n,prefix:e,alphabet:t}){const{encode:r,decode:s}=Kh(t,n);return zs({prefix:e,name:n,encode:r,decode:i=>qs(s(i))})}function Qh(n,e,t,r){let s=n.length;for(;n[s-1]==="=";)--s;const i=new Uint8Array(s*t/8|0);let o=0,a=0,c=0;for(let u=0;u<s;++u){const l=e[n[u]];if(l===void 0)throw new SyntaxError(`Non-${r} character`);a=a<<t|l,o+=t,o>=8&&(o-=8,i[c++]=255&a>>o)}if(o>=t||(255&a<<8-o)!==0)throw new SyntaxError("Unexpected end of data");return i}function Yh(n,e,t){const r=e[e.length-1]==="=",s=(1<<t)-1;let i="",o=0,a=0;for(let c=0;c<n.length;++c)for(a=a<<8|n[c],o+=8;o>t;)o-=t,i+=e[s&a>>o];if(o!==0&&(i+=e[s&a<<t-o]),r)for(;(i.length*t&7)!==0;)i+="=";return i}function Xh(n){const e={};for(let t=0;t<n.length;++t)e[n[t]]=t;return e}function Ee({name:n,prefix:e,bitsPerChar:t,alphabet:r}){const s=Xh(r);return zs({prefix:e,name:n,encode(i){return Yh(i,r,t)},decode(i){return Qh(i,s,t,n)}})}const ge=br({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Zh=br({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),jh=Object.freeze(Object.defineProperty({__proto__:null,base58btc:ge,base58flickr:Zh},Symbol.toStringTag,{value:"Module"})),It=Ee({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Jh=Ee({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),ef=Ee({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),tf=Ee({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),nf=Ee({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),rf=Ee({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),sf=Ee({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),of=Ee({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),af=Ee({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),cf=Object.freeze(Object.defineProperty({__proto__:null,base32:It,base32hex:nf,base32hexpad:sf,base32hexpadupper:of,base32hexupper:rf,base32pad:ef,base32padupper:tf,base32upper:Jh,base32z:af},Symbol.toStringTag,{value:"Module"})),ts=br({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),lf=br({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),uf=Object.freeze(Object.defineProperty({__proto__:null,base36:ts,base36upper:lf},Symbol.toStringTag,{value:"Module"}));var df=Al,ga=128,hf=-128,ff=Math.pow(2,31);function Al(n,e,t){e=e||[],t=t||0;for(var r=t;n>=ff;)e[t++]=n&255|ga,n/=128;for(;n&hf;)e[t++]=n&255|ga,n>>>=7;return e[t]=n|0,Al.bytes=t-r+1,e}var pf=Gi,gf=128,ma=127;function Gi(n,r){var t=0,r=r||0,s=0,i=r,o,a=n.length;do{if(i>=a)throw Gi.bytes=0,new RangeError("Could not decode varint");o=n[i++],t+=s<28?(o&ma)<<s:(o&ma)*Math.pow(2,s),s+=7}while(o>=gf);return Gi.bytes=i-r,t}var mf=Math.pow(2,7),yf=Math.pow(2,14),wf=Math.pow(2,21),bf=Math.pow(2,28),Ef=Math.pow(2,35),vf=Math.pow(2,42),Sf=Math.pow(2,49),xf=Math.pow(2,56),Af=Math.pow(2,63),_f=function(n){return n<mf?1:n<yf?2:n<wf?3:n<bf?4:n<Ef?5:n<vf?6:n<Sf?7:n<xf?8:n<Af?9:10},Cf={encode:df,decode:pf,encodingLength:_f},as=Cf;function Qi(n,e=0){return[as.decode(n,e),as.decode.bytes]}function cs(n,e,t=0){return as.encode(n,e,t),e}function ls(n){return as.encodingLength(n)}function ar(n,e){const t=e.byteLength,r=ls(n),s=r+ls(t),i=new Uint8Array(s+t);return cs(n,i,0),cs(t,i,r),i.set(e,s),new Po(n,t,e,i)}function Er(n){const e=qs(n),[t,r]=Qi(e),[s,i]=Qi(e.subarray(r)),o=e.subarray(r+i);if(o.byteLength!==s)throw new Error("Incorrect length");return new Po(t,s,o,e)}function If(n,e){if(n===e)return!0;{const t=e;return n.code===t.code&&n.size===t.size&&t.bytes instanceof Uint8Array&&Uh(n.bytes,t.bytes)}}class Po{code;size;digest;bytes;constructor(e,t,r,s){this.code=e,this.size=t,this.digest=r,this.bytes=s}}function ya(n,e){const{bytes:t,version:r}=n;switch(r){case 0:return Pf(t,Yi(n),e??ge.encoder);default:return Df(t,Yi(n),e??It.encoder)}}const wa=new WeakMap;function Yi(n){const e=wa.get(n);if(e==null){const t=new Map;return wa.set(n,t),t}return e}class re{code;version;multihash;bytes;"/";constructor(e,t,r,s){this.code=t,this.version=e,this.multihash=r,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==$n)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==Lf)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return re.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,r=ar(e,t);return re.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return re.equals(this,e)}static equals(e,t){const r=t;return r!=null&&e.code===r.code&&e.version===r.version&&If(e.multihash,r.multihash)}toString(e){return ya(this,e)}toJSON(){return{"/":ya(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const t=e;if(t instanceof re)return t;if(t["/"]!=null&&t["/"]===t.bytes||t.asCID===t){const{version:r,code:s,multihash:i,bytes:o}=t;return new re(r,s,i,o??ba(r,s,i.bytes))}else if(t[kf]===!0){const{version:r,multihash:s,code:i}=t,o=Er(s);return re.create(r,i,o)}else return null}static create(e,t,r){if(typeof t!="number")throw new Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(t!==$n)throw new Error(`Version 0 CID must use dag-pb (code: ${$n}) block encoding`);return new re(e,t,r,r.bytes)}case 1:{const s=ba(e,t,r.bytes);return new re(e,t,r,s)}default:throw new Error("Invalid version")}}static createV0(e){return re.create(0,$n,e)}static createV1(e,t){return re.create(1,e,t)}static decode(e){const[t,r]=re.decodeFirst(e);if(r.length!==0)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=re.inspectBytes(e),r=t.size-t.multihashSize,s=qs(e.subarray(r,r+t.multihashSize));if(s.byteLength!==t.multihashSize)throw new Error("Incorrect length");const i=s.subarray(t.multihashSize-t.digestSize),o=new Po(t.multihashCode,t.digestSize,i,s);return[t.version===0?re.createV0(o):re.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const r=()=>{const[d,h]=Qi(e.subarray(t));return t+=h,d};let s=r(),i=$n;if(s===18?(s=0,t=0):i=r(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);const o=t,a=r(),c=r(),u=t+c,l=u-o;return{version:s,codec:i,multihashCode:a,digestSize:c,multihashSize:l,size:u}}static parse(e,t){const[r,s]=Tf(e,t),i=re.decode(s);if(i.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return Yi(i).set(r,e),i}}function Tf(n,e){switch(n[0]){case"Q":{const t=e??ge;return[ge.prefix,t.decode(`${ge.prefix}${n}`)]}case ge.prefix:{const t=e??ge;return[ge.prefix,t.decode(n)]}case It.prefix:{const t=e??It;return[It.prefix,t.decode(n)]}case ts.prefix:{const t=e??ts;return[ts.prefix,t.decode(n)]}default:{if(e==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[n[0],e.decode(n)]}}}function Pf(n,e,t){const{prefix:r}=t;if(r!==ge.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);const s=e.get(r);if(s==null){const i=t.encode(n).slice(1);return e.set(r,i),i}else return s}function Df(n,e,t){const{prefix:r}=t,s=e.get(r);if(s==null){const i=t.encode(n);return e.set(r,i),i}else return s}const $n=112,Lf=18;function ba(n,e,t){const r=ls(n),s=r+ls(e),i=new Uint8Array(s+t.byteLength);return cs(n,i,0),cs(e,i,r),i.set(t,s),i}const kf=Symbol.for("@ipld/js-cid/CID"),_l=0,Rf="identity",Cl=qs;function Nf(n){return ar(_l,Cl(n))}const vr={code:_l,name:Rf,encode:Cl,digest:Nf};function Te(n,e){if(n===e)return!0;if(n.byteLength!==e.byteLength)return!1;for(let t=0;t<n.byteLength;t++)if(n[t]!==e[t])return!1;return!0}function j(n=0){return new Uint8Array(n)}function rt(n=0){return new Uint8Array(n)}function $t(n,e){e==null&&(e=n.reduce((s,i)=>s+i.length,0));const t=rt(e);let r=0;for(const s of n)t.set(s,r),r+=s.length;return t}const Il=Symbol.for("@achingbrain/uint8arraylist");function Ea(n,e){if(e==null||e<0)throw new RangeError("index is out of bounds");let t=0;for(const r of n){const s=t+r.byteLength;if(e<s)return{buf:r,index:e-t};t=s}throw new RangeError("index is out of bounds")}function Rr(n){return!!n?.[Il]}class H{bufs;length;[Il]=!0;constructor(...e){this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(const r of e)if(r instanceof Uint8Array)t+=r.byteLength,this.bufs.push(r);else if(Rr(r))t+=r.byteLength,this.bufs.push(...r.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(const r of e.reverse())if(r instanceof Uint8Array)t+=r.byteLength,this.bufs.unshift(r);else if(Rr(r))t+=r.byteLength,this.bufs.unshift(...r.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}get(e){const t=Ea(this.bufs,e);return t.buf[t.index]}set(e,t){const r=Ea(this.bufs,e);r.buf[r.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let r=0;r<e.length;r++)this.set(t+r,e[r]);else if(Rr(e))for(let r=0;r<e.length;r++)this.set(t+r,e.get(r));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(e>=this.bufs[0].byteLength)e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}}}slice(e,t){const{bufs:r,length:s}=this._subList(e,t);return $t(r,s)}subarray(e,t){const{bufs:r,length:s}=this._subList(e,t);return r.length===1?r[0]:$t(r,s)}sublist(e,t){const{bufs:r,length:s}=this._subList(e,t),i=new H;return i.length=s,i.bufs=[...r],i}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(e===0&&t===this.length)return{bufs:this.bufs,length:this.length};const r=[];let s=0;for(let i=0;i<this.bufs.length;i++){const o=this.bufs[i],a=s,c=a+o.byteLength;if(s=c,e>=c)continue;const u=e>=a&&e<c,l=t>a&&t<=c;if(u&&l){if(e===a&&t===c){r.push(o);break}const d=e-a;r.push(o.subarray(d,d+(t-e)));break}if(u){if(e===0){r.push(o);continue}r.push(o.subarray(e-a));continue}if(l){if(t===c){r.push(o);break}r.push(o.subarray(0,t-a));break}r.push(o)}return{bufs:r,length:t-e}}indexOf(e,t=0){if(!Rr(e)&&!(e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const r=e instanceof Uint8Array?e:e.subarray();if(t=Number(t??0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),e.length===0)return t>this.length?this.length:t;const s=r.byteLength;if(s===0)throw new TypeError("search must be at least 1 byte long");const i=256,o=new Int32Array(i);for(let d=0;d<i;d++)o[d]=-1;for(let d=0;d<s;d++)o[r[d]]=d;const a=o,c=this.byteLength-r.byteLength,u=r.byteLength-1;let l;for(let d=t;d<=c;d+=l){l=0;for(let h=u;h>=0;h--){const p=this.get(d+h);if(r[h]!==p){l=Math.max(1,h-a[p]);break}}if(l===0)return d}return-1}getInt8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,t){const r=rt(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setInt8(0,t),this.write(r,e)}getInt16(e,t){const r=this.subarray(e,e+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt16(0,t)}setInt16(e,t,r){const s=j(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt16(0,t,r),this.write(s,e)}getInt32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt32(0,t)}setInt32(e,t,r){const s=j(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt32(0,t,r),this.write(s,e)}getBigInt64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigInt64(0,t)}setBigInt64(e,t,r){const s=j(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigInt64(0,t,r),this.write(s,e)}getUint8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,t){const r=rt(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setUint8(0,t),this.write(r,e)}getUint16(e,t){const r=this.subarray(e,e+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint16(0,t)}setUint16(e,t,r){const s=j(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint16(0,t,r),this.write(s,e)}getUint32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint32(0,t)}setUint32(e,t,r){const s=j(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint32(0,t,r),this.write(s,e)}getBigUint64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigUint64(0,t)}setBigUint64(e,t,r){const s=j(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigUint64(0,t,r),this.write(s,e)}getFloat32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat32(0,t)}setFloat32(e,t,r){const s=j(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat32(0,t,r),this.write(s,e)}getFloat64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat64(0,t)}setFloat64(e,t,r){const s=j(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat64(0,t,r),this.write(s,e)}equals(e){if(e==null||!(e instanceof H)||e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!Te(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){const r=new H;return r.bufs=e,t==null&&(t=e.reduce((s,i)=>s+i.byteLength,0)),r.length=t,r}}const Of=br({prefix:"9",name:"base10",alphabet:"0123456789"}),Mf=Object.freeze(Object.defineProperty({__proto__:null,base10:Of},Symbol.toStringTag,{value:"Module"})),Ff=Ee({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Uf=Ee({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),Bf=Object.freeze(Object.defineProperty({__proto__:null,base16:Ff,base16upper:Uf},Symbol.toStringTag,{value:"Module"})),$f=Ee({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),qf=Object.freeze(Object.defineProperty({__proto__:null,base2:$f},Symbol.toStringTag,{value:"Module"})),Tl=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),zf=Tl.reduce((n,e,t)=>(n[t]=e,n),[]),Kf=Tl.reduce((n,e,t)=>{const r=e.codePointAt(0);if(r==null)throw new Error(`Invalid character: ${e}`);return n[r]=t,n},[]);function Wf(n){return n.reduce((e,t)=>(e+=zf[t],e),"")}function Vf(n){const e=[];for(const t of n){const r=t.codePointAt(0);if(r==null)throw new Error(`Invalid character: ${t}`);const s=Kf[r];if(s==null)throw new Error(`Non-base256emoji character: ${t}`);e.push(s)}return new Uint8Array(e)}const Hf=zs({prefix:"🚀",name:"base256emoji",encode:Wf,decode:Vf}),Gf=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:Hf},Symbol.toStringTag,{value:"Module"})),Pl=Ee({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Qf=Ee({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Dl=Ee({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Yf=Ee({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),Xf=Object.freeze(Object.defineProperty({__proto__:null,base64:Pl,base64pad:Qf,base64url:Dl,base64urlpad:Yf},Symbol.toStringTag,{value:"Module"})),Zf=Ee({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),jf=Object.freeze(Object.defineProperty({__proto__:null,base8:Zf},Symbol.toStringTag,{value:"Module"})),Jf=zs({prefix:"\0",name:"identity",encode:n=>$h(n),decode:n=>Bh(n)}),ep=Object.freeze(Object.defineProperty({__proto__:null,identity:Jf},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;function tp({name:n,code:e,encode:t}){return new np(n,e,t)}class np{name;code;encode;constructor(e,t,r){this.name=e,this.code=t,this.encode=r}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?ar(this.code,t):t.then(r=>ar(this.code,r))}else throw Error("Unknown type, must be binary type")}}function rp(n){return async e=>new Uint8Array(await crypto.subtle.digest(n,e))}const Ll=tp({name:"sha2-256",code:18,encode:rp("SHA-256")}),Xi={...ep,...qf,...jf,...Mf,...Bf,...cf,...uf,...jh,...Xf,...Gf};function kl(n,e,t,r){return{name:n,prefix:e,encoder:{name:n,prefix:e,encode:t},decoder:{decode:r}}}const va=kl("utf8","u",n=>"u"+new TextDecoder("utf8").decode(n),n=>new TextEncoder().encode(n.substring(1))),ri=kl("ascii","a",n=>{let e="a";for(let t=0;t<n.length;t++)e+=String.fromCharCode(n[t]);return e},n=>{n=n.substring(1);const e=rt(n.length);for(let t=0;t<n.length;t++)e[t]=n.charCodeAt(t);return e}),Rl={utf8:va,"utf-8":va,hex:Xi.base16,latin1:ri,ascii:ri,binary:ri,...Xi};function $(n,e="utf8"){const t=Rl[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.decoder.decode(`${t.prefix}${n}`)}function q(n,e="utf8"){const t=Rl[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.encoder.encode(n).substring(1)}const sp=parseInt("11111",2),Zi=parseInt("10000000",2),ip=parseInt("01111111",2),Sa={0:qn,1:qn,2:op,3:lp,4:up,5:cp,6:ap,16:qn,22:qn,48:qn};function Ks(n,e={offset:0}){const t=n[e.offset]&sp;if(e.offset++,Sa[t]!=null)return Sa[t](n,e);throw new Error("No decoder for tag "+t)}function Sr(n,e){let t=0;if((n[e.offset]&Zi)===Zi){const r=n[e.offset]&ip;let s="0x";e.offset++;for(let i=0;i<r;i++,e.offset++)s+=n[e.offset].toString(16).padStart(2,"0");t=parseInt(s,16)}else t=n[e.offset],e.offset++;return t}function qn(n,e){Sr(n,e);const t=[];for(;!(e.offset>=n.byteLength);){const r=Ks(n,e);if(r===null)break;t.push(r)}return t}function op(n,e){const t=Sr(n,e),r=e.offset,s=e.offset+t,i=[];for(let o=r;o<s;o++)o===r&&n[o]===0||i.push(n[o]);return e.offset+=t,Uint8Array.from(i)}function ap(n,e){const t=Sr(n,e),r=e.offset+t,s=n[e.offset];e.offset++;let i=0,o=0;s<40?(i=0,o=s):s<80?(i=1,o=s-40):(i=2,o=s-80);let a=`${i}.${o}`,c=[];for(;e.offset<r;){const u=n[e.offset];if(e.offset++,c.push(u&127),u<128){c.reverse();let l=0;for(let d=0;d<c.length;d++)l+=c[d]<<d*7;a+=`.${l}`,c=[]}}return a}function cp(n,e){return e.offset++,null}function lp(n,e){const t=Sr(n,e),r=n[e.offset];e.offset++;const s=n.subarray(e.offset,e.offset+t-1);if(e.offset+=t,r!==0)throw new Error("Unused bits in bit string is unimplemented");return s}function up(n,e){const t=Sr(n,e),r=n.subarray(e.offset,e.offset+t);return e.offset+=t,r}function dp(n){let e=n.toString(16);e.length%2===1&&(e="0"+e);const t=new H;for(let r=0;r<e.length;r+=2)t.append(Uint8Array.from([parseInt(`${e[r]}${e[r+1]}`,16)]));return t}function Do(n){if(n.byteLength<128)return Uint8Array.from([n.byteLength]);const e=dp(n.byteLength);return new H(Uint8Array.from([e.byteLength|Zi]),e)}function ji(n){const e=new H,t=128;return(n.subarray()[0]&t)===t&&e.append(Uint8Array.from([0])),e.append(n),new H(Uint8Array.from([2]),Do(e),e)}function Nl(n){const e=Uint8Array.from([0]),t=new H(e,n);return new H(Uint8Array.from([3]),Do(t),t)}function Jn(n,e=48){const t=new H;for(const r of n)t.append(r);return new H(Uint8Array.from([e]),Do(t),t)}async function hp(n,e,t,r){const s=await crypto.subtle.importKey("jwk",n,{name:"ECDSA",namedCurve:n.crv??"P-256"},!1,["verify"]);r?.signal?.throwIfAborted();const i=await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},s,e,t.subarray());return r?.signal?.throwIfAborted(),i}const fp=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),pp=Uint8Array.from([6,5,43,129,4,0,34]),gp=Uint8Array.from([6,5,43,129,4,0,35]),mp={ext:!0,kty:"EC",crv:"P-256"},yp={ext:!0,kty:"EC",crv:"P-384"},wp={ext:!0,kty:"EC",crv:"P-521"},si=32,ii=48,oi=66;function Ol(n){const e=Ks(n);return bp(e)}function bp(n){const e=n[1][1][0],t=1;let r,s;if(e.byteLength===si*2+1)return r=q(e.subarray(t,t+si),"base64url"),s=q(e.subarray(t+si),"base64url"),new ai({...mp,key_ops:["verify"],x:r,y:s});if(e.byteLength===ii*2+1)return r=q(e.subarray(t,t+ii),"base64url"),s=q(e.subarray(t+ii),"base64url"),new ai({...yp,key_ops:["verify"],x:r,y:s});if(e.byteLength===oi*2+1)return r=q(e.subarray(t,t+oi),"base64url"),s=q(e.subarray(t+oi),"base64url"),new ai({...wp,key_ops:["verify"],x:r,y:s});throw new K(`coordinates were wrong length, got ${e.byteLength}, expected 65, 97 or 133`)}function Ep(n){return Jn([ji(Uint8Array.from([1])),Jn([vp(n.crv)],160),Jn([Nl(new H(Uint8Array.from([4]),$(n.x??"","base64url"),$(n.y??"","base64url")))],161)]).subarray()}function vp(n){if(n==="P-256")return fp;if(n==="P-384")return pp;if(n==="P-521")return gp;throw new K(`Invalid curve ${n}`)}class ai{type="ECDSA";jwk;_raw;constructor(e){this.jwk=e}get raw(){return this._raw==null&&(this._raw=Ep(this.jwk)),this._raw}toMultihash(){return vr.digest(ft(this))}toCID(){return re.createV1(114,this.toMultihash())}toString(){return ge.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Te(this.raw,e.raw)}async verify(e,t,r){return hp(this.jwk,t,e,r)}}const Zt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Lo(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function us(n){if(!Number.isSafeInteger(n)||n<0)throw new Error("positive integer expected, got "+n)}function st(n,...e){if(!Lo(n))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(n.length))throw new Error("Uint8Array expected of length "+e+", got length="+n.length)}function ko(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");us(n.outputLen),us(n.blockLen)}function ds(n,e=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(e&&n.finished)throw new Error("Hash#digest() has already been called")}function Sp(n,e){st(n);const t=e.outputLen;if(n.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function qt(...n){for(let e=0;e<n.length;e++)n[e].fill(0)}function ci(n){return new DataView(n.buffer,n.byteOffset,n.byteLength)}function Xe(n,e){return n<<32-e|n>>>e}const Ml=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",xp=Array.from({length:256},(n,e)=>e.toString(16).padStart(2,"0"));function mn(n){if(st(n),Ml)return n.toHex();let e="";for(let t=0;t<n.length;t++)e+=xp[n[t]];return e}const at={_0:48,_9:57,A:65,F:70,a:97,f:102};function xa(n){if(n>=at._0&&n<=at._9)return n-at._0;if(n>=at.A&&n<=at.F)return n-(at.A-10);if(n>=at.a&&n<=at.f)return n-(at.a-10)}function Ro(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);if(Ml)return Uint8Array.fromHex(n);const e=n.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(t);for(let s=0,i=0;s<t;s++,i+=2){const o=xa(n.charCodeAt(i)),a=xa(n.charCodeAt(i+1));if(o===void 0||a===void 0){const c=n[i]+n[i+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+i)}r[s]=o*16+a}return r}function Ap(n){if(typeof n!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(n))}function cr(n){return typeof n=="string"&&(n=Ap(n)),st(n),n}function ht(...n){let e=0;for(let r=0;r<n.length;r++){const s=n[r];st(s),e+=s.length}const t=new Uint8Array(e);for(let r=0,s=0;r<n.length;r++){const i=n[r];t.set(i,s),s+=i.length}return t}class Fl{}function Ul(n){const e=r=>n().update(cr(r)).digest(),t=n();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>n(),e}function Ws(n=32){if(Zt&&typeof Zt.getRandomValues=="function")return Zt.getRandomValues(new Uint8Array(n));if(Zt&&typeof Zt.randomBytes=="function")return Uint8Array.from(Zt.randomBytes(n));throw new Error("crypto.getRandomValues must be defined")}function _p(n,e,t,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(e,t,r);const s=BigInt(32),i=BigInt(4294967295),o=Number(t>>s&i),a=Number(t&i),c=r?4:0,u=r?0:4;n.setUint32(e+c,o,r),n.setUint32(e+u,a,r)}function Cp(n,e,t){return n&e^~n&t}function Ip(n,e,t){return n&e^n&t^e&t}class Bl extends Fl{constructor(e,t,r,s){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=s,this.buffer=new Uint8Array(e),this.view=ci(this.buffer)}update(e){ds(this),e=cr(e),st(e);const{view:t,buffer:r,blockLen:s}=this,i=e.length;for(let o=0;o<i;){const a=Math.min(s-this.pos,i-o);if(a===s){const c=ci(e);for(;s<=i-o;o+=s)this.process(c,o);continue}r.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){ds(this),Sp(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:s,isLE:i}=this;let{pos:o}=this;t[o++]=128,qt(this.buffer.subarray(o)),this.padOffset>s-o&&(this.process(r,0),o=0);for(let d=o;d<s;d++)t[d]=0;_p(r,s-8,BigInt(this.length*8),i),this.process(r,0);const a=ci(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=c/4,l=this.get();if(u>l.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<u;d++)a.setUint32(4*d,l[d],i)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:s,finished:i,destroyed:o,pos:a}=this;return e.destroyed=o,e.finished=i,e.length=s,e.pos=a,s%t&&e.buffer.set(r),e}clone(){return this._cloneInto()}}const Et=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Se=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),Nr=BigInt(2**32-1),Aa=BigInt(32);function Tp(n,e=!1){return e?{h:Number(n&Nr),l:Number(n>>Aa&Nr)}:{h:Number(n>>Aa&Nr)|0,l:Number(n&Nr)|0}}function Pp(n,e=!1){const t=n.length;let r=new Uint32Array(t),s=new Uint32Array(t);for(let i=0;i<t;i++){const{h:o,l:a}=Tp(n[i],e);[r[i],s[i]]=[o,a]}return[r,s]}const _a=(n,e,t)=>n>>>t,Ca=(n,e,t)=>n<<32-t|e>>>t,jt=(n,e,t)=>n>>>t|e<<32-t,Jt=(n,e,t)=>n<<32-t|e>>>t,Or=(n,e,t)=>n<<64-t|e>>>t-32,Mr=(n,e,t)=>n>>>t-32|e<<64-t;function ct(n,e,t,r){const s=(e>>>0)+(r>>>0);return{h:n+t+(s/2**32|0)|0,l:s|0}}const Dp=(n,e,t)=>(n>>>0)+(e>>>0)+(t>>>0),Lp=(n,e,t,r)=>e+t+r+(n/2**32|0)|0,kp=(n,e,t,r)=>(n>>>0)+(e>>>0)+(t>>>0)+(r>>>0),Rp=(n,e,t,r,s)=>e+t+r+s+(n/2**32|0)|0,Np=(n,e,t,r,s)=>(n>>>0)+(e>>>0)+(t>>>0)+(r>>>0)+(s>>>0),Op=(n,e,t,r,s,i)=>e+t+r+s+i+(n/2**32|0)|0,Mp=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),vt=new Uint32Array(64);class Fp extends Bl{constructor(e=32){super(64,e,8,!1),this.A=Et[0]|0,this.B=Et[1]|0,this.C=Et[2]|0,this.D=Et[3]|0,this.E=Et[4]|0,this.F=Et[5]|0,this.G=Et[6]|0,this.H=Et[7]|0}get(){const{A:e,B:t,C:r,D:s,E:i,F:o,G:a,H:c}=this;return[e,t,r,s,i,o,a,c]}set(e,t,r,s,i,o,a,c){this.A=e|0,this.B=t|0,this.C=r|0,this.D=s|0,this.E=i|0,this.F=o|0,this.G=a|0,this.H=c|0}process(e,t){for(let d=0;d<16;d++,t+=4)vt[d]=e.getUint32(t,!1);for(let d=16;d<64;d++){const h=vt[d-15],p=vt[d-2],g=Xe(h,7)^Xe(h,18)^h>>>3,m=Xe(p,17)^Xe(p,19)^p>>>10;vt[d]=m+vt[d-7]+g+vt[d-16]|0}let{A:r,B:s,C:i,D:o,E:a,F:c,G:u,H:l}=this;for(let d=0;d<64;d++){const h=Xe(a,6)^Xe(a,11)^Xe(a,25),p=l+h+Cp(a,c,u)+Mp[d]+vt[d]|0,m=(Xe(r,2)^Xe(r,13)^Xe(r,22))+Ip(r,s,i)|0;l=u,u=c,c=a,a=o+p|0,o=i,i=s,s=r,r=p+m|0}r=r+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,u=u+this.G|0,l=l+this.H|0,this.set(r,s,i,o,a,c,u,l)}roundClean(){qt(vt)}destroy(){this.set(0,0,0,0,0,0,0,0),qt(this.buffer)}}const $l=Pp(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(n=>BigInt(n))),Up=$l[0],Bp=$l[1],St=new Uint32Array(80),xt=new Uint32Array(80);class $p extends Bl{constructor(e=64){super(128,e,16,!1),this.Ah=Se[0]|0,this.Al=Se[1]|0,this.Bh=Se[2]|0,this.Bl=Se[3]|0,this.Ch=Se[4]|0,this.Cl=Se[5]|0,this.Dh=Se[6]|0,this.Dl=Se[7]|0,this.Eh=Se[8]|0,this.El=Se[9]|0,this.Fh=Se[10]|0,this.Fl=Se[11]|0,this.Gh=Se[12]|0,this.Gl=Se[13]|0,this.Hh=Se[14]|0,this.Hl=Se[15]|0}get(){const{Ah:e,Al:t,Bh:r,Bl:s,Ch:i,Cl:o,Dh:a,Dl:c,Eh:u,El:l,Fh:d,Fl:h,Gh:p,Gl:g,Hh:m,Hl:f}=this;return[e,t,r,s,i,o,a,c,u,l,d,h,p,g,m,f]}set(e,t,r,s,i,o,a,c,u,l,d,h,p,g,m,f){this.Ah=e|0,this.Al=t|0,this.Bh=r|0,this.Bl=s|0,this.Ch=i|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=u|0,this.El=l|0,this.Fh=d|0,this.Fl=h|0,this.Gh=p|0,this.Gl=g|0,this.Hh=m|0,this.Hl=f|0}process(e,t){for(let x=0;x<16;x++,t+=4)St[x]=e.getUint32(t),xt[x]=e.getUint32(t+=4);for(let x=16;x<80;x++){const L=St[x-15]|0,E=xt[x-15]|0,T=jt(L,E,1)^jt(L,E,8)^_a(L,E,7),k=Jt(L,E,1)^Jt(L,E,8)^Ca(L,E,7),D=St[x-2]|0,y=xt[x-2]|0,S=jt(D,y,19)^Or(D,y,61)^_a(D,y,6),b=Jt(D,y,19)^Mr(D,y,61)^Ca(D,y,6),A=kp(k,b,xt[x-7],xt[x-16]),_=Rp(A,T,S,St[x-7],St[x-16]);St[x]=_|0,xt[x]=A|0}let{Ah:r,Al:s,Bh:i,Bl:o,Ch:a,Cl:c,Dh:u,Dl:l,Eh:d,El:h,Fh:p,Fl:g,Gh:m,Gl:f,Hh:w,Hl:v}=this;for(let x=0;x<80;x++){const L=jt(d,h,14)^jt(d,h,18)^Or(d,h,41),E=Jt(d,h,14)^Jt(d,h,18)^Mr(d,h,41),T=d&p^~d&m,k=h&g^~h&f,D=Np(v,E,k,Bp[x],xt[x]),y=Op(D,w,L,T,Up[x],St[x]),S=D|0,b=jt(r,s,28)^Or(r,s,34)^Or(r,s,39),A=Jt(r,s,28)^Mr(r,s,34)^Mr(r,s,39),_=r&i^r&a^i&a,I=s&o^s&c^o&c;w=m|0,v=f|0,m=p|0,f=g|0,p=d|0,g=h|0,{h:d,l:h}=ct(u|0,l|0,y|0,S|0),u=a|0,l=c|0,a=i|0,c=o|0,i=r|0,o=s|0;const C=Dp(S,A,I);r=Lp(C,y,b,_),s=C|0}({h:r,l:s}=ct(this.Ah|0,this.Al|0,r|0,s|0)),{h:i,l:o}=ct(this.Bh|0,this.Bl|0,i|0,o|0),{h:a,l:c}=ct(this.Ch|0,this.Cl|0,a|0,c|0),{h:u,l}=ct(this.Dh|0,this.Dl|0,u|0,l|0),{h:d,l:h}=ct(this.Eh|0,this.El|0,d|0,h|0),{h:p,l:g}=ct(this.Fh|0,this.Fl|0,p|0,g|0),{h:m,l:f}=ct(this.Gh|0,this.Gl|0,m|0,f|0),{h:w,l:v}=ct(this.Hh|0,this.Hl|0,w|0,v|0),this.set(r,s,i,o,a,c,u,l,d,h,p,g,m,f,w,v)}roundClean(){qt(St,xt)}destroy(){qt(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const ql=Ul(()=>new Fp),qp=Ul(()=>new $p);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const No=BigInt(0),Ji=BigInt(1);function zt(n,e){if(typeof e!="boolean")throw new Error(n+" boolean expected, got "+e)}function Fr(n){const e=n.toString(16);return e.length&1?"0"+e:e}function zl(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return n===""?No:BigInt("0x"+n)}function Vs(n){return zl(mn(n))}function Kt(n){return st(n),zl(mn(Uint8Array.from(n).reverse()))}function Oo(n,e){return Ro(n.toString(16).padStart(e*2,"0"))}function xr(n,e){return Oo(n,e).reverse()}function ce(n,e,t){let r;if(typeof e=="string")try{r=Ro(e)}catch(i){throw new Error(n+" must be hex string or Uint8Array, cause: "+i)}else if(Lo(e))r=Uint8Array.from(e);else throw new Error(n+" must be hex string or Uint8Array");const s=r.length;if(typeof t=="number"&&s!==t)throw new Error(n+" of length "+t+" expected, got "+s);return r}const li=n=>typeof n=="bigint"&&No<=n;function zp(n,e,t){return li(n)&&li(e)&&li(t)&&e<=n&&n<t}function At(n,e,t,r){if(!zp(e,t,r))throw new Error("expected valid "+n+": "+t+" <= n < "+r+", got "+e)}function Kp(n){let e;for(e=0;n>No;n>>=Ji,e+=1);return e}const Hs=n=>(Ji<<BigInt(n))-Ji;function Wp(n,e,t){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");const r=p=>new Uint8Array(p),s=p=>Uint8Array.of(p);let i=r(n),o=r(n),a=0;const c=()=>{i.fill(1),o.fill(0),a=0},u=(...p)=>t(o,i,...p),l=(p=r(0))=>{o=u(s(0),p),i=u(),p.length!==0&&(o=u(s(1),p),i=u())},d=()=>{if(a++>=1e3)throw new Error("drbg: tried 1000 values");let p=0;const g=[];for(;p<e;){i=u();const m=i.slice();g.push(m),p+=i.length}return ht(...g)};return(p,g)=>{c(),l(p);let m;for(;!(m=g(d()));)l();return c(),m}}function kn(n,e,t={}){if(!n||typeof n!="object")throw new Error("expected valid options object");function r(s,i,o){const a=n[s];if(o&&a===void 0)return;const c=typeof a;if(c!==i||a===null)throw new Error(`param "${s}" is invalid: expected ${i}, got ${c}`)}Object.entries(e).forEach(([s,i])=>r(s,i,!1)),Object.entries(t).forEach(([s,i])=>r(s,i,!0))}function hs(n){const e=new WeakMap;return(t,...r)=>{const s=e.get(t);if(s!==void 0)return s;const i=n(t,...r);return e.set(t,i),i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Fe=BigInt(0),be=BigInt(1),Rt=BigInt(2),Vp=BigInt(3),Kl=BigInt(4),Wl=BigInt(5),Vl=BigInt(8);function le(n,e){const t=n%e;return t>=Fe?t:e+t}function ae(n,e,t){let r=n;for(;e-- >Fe;)r*=r,r%=t;return r}function Ia(n,e){if(n===Fe)throw new Error("invert: expected non-zero number");if(e<=Fe)throw new Error("invert: expected positive modulus, got "+e);let t=le(n,e),r=e,s=Fe,i=be;for(;t!==Fe;){const a=r/t,c=r%t,u=s-i*a;r=t,t=c,s=i,i=u}if(r!==be)throw new Error("invert: does not exist");return le(s,e)}function Hl(n,e){const t=(n.ORDER+be)/Kl,r=n.pow(e,t);if(!n.eql(n.sqr(r),e))throw new Error("Cannot find square root");return r}function Hp(n,e){const t=(n.ORDER-Wl)/Vl,r=n.mul(e,Rt),s=n.pow(r,t),i=n.mul(e,s),o=n.mul(n.mul(i,Rt),s),a=n.mul(i,n.sub(o,n.ONE));if(!n.eql(n.sqr(a),e))throw new Error("Cannot find square root");return a}function Gp(n){if(n<BigInt(3))throw new Error("sqrt is not defined for small field");let e=n-be,t=0;for(;e%Rt===Fe;)e/=Rt,t++;let r=Rt;const s=Rn(n);for(;Ta(s,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return Hl;let i=s.pow(r,e);const o=(e+be)/Rt;return function(c,u){if(c.is0(u))return u;if(Ta(c,u)!==1)throw new Error("Cannot find square root");let l=t,d=c.mul(c.ONE,i),h=c.pow(u,e),p=c.pow(u,o);for(;!c.eql(h,c.ONE);){if(c.is0(h))return c.ZERO;let g=1,m=c.sqr(h);for(;!c.eql(m,c.ONE);)if(g++,m=c.sqr(m),g===l)throw new Error("Cannot find square root");const f=be<<BigInt(l-g-1),w=c.pow(d,f);l=g,d=c.sqr(w),h=c.mul(h,d),p=c.mul(p,w)}return p}}function Qp(n){return n%Kl===Vp?Hl:n%Vl===Wl?Hp:Gp(n)}const Yp=(n,e)=>(le(n,e)&be)===be,Xp=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Zp(n){const e={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},t=Xp.reduce((r,s)=>(r[s]="function",r),e);return kn(n,t),n}function jp(n,e,t){if(t<Fe)throw new Error("invalid exponent, negatives unsupported");if(t===Fe)return n.ONE;if(t===be)return e;let r=n.ONE,s=e;for(;t>Fe;)t&be&&(r=n.mul(r,s)),s=n.sqr(s),t>>=be;return r}function Gl(n,e,t=!1){const r=new Array(e.length).fill(t?n.ZERO:void 0),s=e.reduce((o,a,c)=>n.is0(a)?o:(r[c]=o,n.mul(o,a)),n.ONE),i=n.inv(s);return e.reduceRight((o,a,c)=>n.is0(a)?o:(r[c]=n.mul(o,r[c]),n.mul(o,a)),i),r}function Ta(n,e){const t=(n.ORDER-be)/Rt,r=n.pow(e,t),s=n.eql(r,n.ONE),i=n.eql(r,n.ZERO),o=n.eql(r,n.neg(n.ONE));if(!s&&!i&&!o)throw new Error("invalid Legendre symbol result");return s?1:i?0:-1}function Jp(n,e){e!==void 0&&us(e);const t=e!==void 0?e:n.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function Rn(n,e,t=!1,r={}){if(n<=Fe)throw new Error("invalid field: expected ORDER > 0, got "+n);let s,i;if(typeof e=="object"&&e!=null){if(r.sqrt||t)throw new Error("cannot specify opts in two arguments");const l=e;l.BITS&&(s=l.BITS),l.sqrt&&(i=l.sqrt),typeof l.isLE=="boolean"&&(t=l.isLE)}else typeof e=="number"&&(s=e),r.sqrt&&(i=r.sqrt);const{nBitLength:o,nByteLength:a}=Jp(n,s);if(a>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c;const u=Object.freeze({ORDER:n,isLE:t,BITS:o,BYTES:a,MASK:Hs(o),ZERO:Fe,ONE:be,create:l=>le(l,n),isValid:l=>{if(typeof l!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof l);return Fe<=l&&l<n},is0:l=>l===Fe,isValidNot0:l=>!u.is0(l)&&u.isValid(l),isOdd:l=>(l&be)===be,neg:l=>le(-l,n),eql:(l,d)=>l===d,sqr:l=>le(l*l,n),add:(l,d)=>le(l+d,n),sub:(l,d)=>le(l-d,n),mul:(l,d)=>le(l*d,n),pow:(l,d)=>jp(u,l,d),div:(l,d)=>le(l*Ia(d,n),n),sqrN:l=>l*l,addN:(l,d)=>l+d,subN:(l,d)=>l-d,mulN:(l,d)=>l*d,inv:l=>Ia(l,n),sqrt:i||(l=>(c||(c=Qp(n)),c(u,l))),toBytes:l=>t?xr(l,a):Oo(l,a),fromBytes:l=>{if(l.length!==a)throw new Error("Field.fromBytes: expected "+a+" bytes, got "+l.length);return t?Kt(l):Vs(l)},invertBatch:l=>Gl(u,l),cmov:(l,d,h)=>h?d:l});return Object.freeze(u)}function Ql(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const e=n.toString(2).length;return Math.ceil(e/8)}function Yl(n){const e=Ql(n);return e+Math.ceil(e/2)}function eg(n,e,t=!1){const r=n.length,s=Ql(e),i=Yl(e);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const o=t?Kt(n):Vs(n),a=le(o,e-be)+be;return t?xr(a,s):Oo(a,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const yn=BigInt(0),Nt=BigInt(1);function er(n,e){const t=e.negate();return n?t:e}function Xl(n,e,t){const r=e==="pz"?o=>o.pz:o=>o.ez,s=Gl(n.Fp,t.map(r));return t.map((o,a)=>o.toAffine(s[a])).map(n.fromAffine)}function Zl(n,e){if(!Number.isSafeInteger(n)||n<=0||n>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+n)}function ui(n,e){Zl(n,e);const t=Math.ceil(e/n)+1,r=2**(n-1),s=2**n,i=Hs(n),o=BigInt(n);return{windows:t,windowSize:r,mask:i,maxNumber:s,shiftBy:o}}function Pa(n,e,t){const{windowSize:r,mask:s,maxNumber:i,shiftBy:o}=t;let a=Number(n&s),c=n>>o;a>r&&(a-=i,c+=Nt);const u=e*r,l=u+Math.abs(a)-1,d=a===0,h=a<0,p=e%2!==0;return{nextN:c,offset:l,isZero:d,isNeg:h,isNegF:p,offsetF:u}}function tg(n,e){if(!Array.isArray(n))throw new Error("array expected");n.forEach((t,r)=>{if(!(t instanceof e))throw new Error("invalid point at index "+r)})}function ng(n,e){if(!Array.isArray(n))throw new Error("array of scalars expected");n.forEach((t,r)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+r)})}const di=new WeakMap,jl=new WeakMap;function hi(n){return jl.get(n)||1}function Da(n){if(n!==yn)throw new Error("invalid wNAF")}function Jl(n,e){return{constTimeNegate:er,hasPrecomputes(t){return hi(t)!==1},unsafeLadder(t,r,s=n.ZERO){let i=t;for(;r>yn;)r&Nt&&(s=s.add(i)),i=i.double(),r>>=Nt;return s},precomputeWindow(t,r){const{windows:s,windowSize:i}=ui(r,e),o=[];let a=t,c=a;for(let u=0;u<s;u++){c=a,o.push(c);for(let l=1;l<i;l++)c=c.add(a),o.push(c);a=c.double()}return o},wNAF(t,r,s){let i=n.ZERO,o=n.BASE;const a=ui(t,e);for(let c=0;c<a.windows;c++){const{nextN:u,offset:l,isZero:d,isNeg:h,isNegF:p,offsetF:g}=Pa(s,c,a);s=u,d?o=o.add(er(p,r[g])):i=i.add(er(h,r[l]))}return Da(s),{p:i,f:o}},wNAFUnsafe(t,r,s,i=n.ZERO){const o=ui(t,e);for(let a=0;a<o.windows&&s!==yn;a++){const{nextN:c,offset:u,isZero:l,isNeg:d}=Pa(s,a,o);if(s=c,!l){const h=r[u];i=i.add(d?h.negate():h)}}return Da(s),i},getPrecomputes(t,r,s){let i=di.get(r);return i||(i=this.precomputeWindow(r,t),t!==1&&(typeof s=="function"&&(i=s(i)),di.set(r,i))),i},wNAFCached(t,r,s){const i=hi(t);return this.wNAF(i,this.getPrecomputes(i,t,s),r)},wNAFCachedUnsafe(t,r,s,i){const o=hi(t);return o===1?this.unsafeLadder(t,r,i):this.wNAFUnsafe(o,this.getPrecomputes(o,t,s),r,i)},setWindowSize(t,r){Zl(r,e),jl.set(t,r),di.delete(t)}}}function rg(n,e,t,r){let s=e,i=n.ZERO,o=n.ZERO;for(;t>yn||r>yn;)t&Nt&&(i=i.add(s)),r&Nt&&(o=o.add(s)),s=s.double(),t>>=Nt,r>>=Nt;return{p1:i,p2:o}}function eu(n,e,t,r){tg(t,n),ng(r,e);const s=t.length,i=r.length;if(s!==i)throw new Error("arrays of points and scalars must have equal length");const o=n.ZERO,a=Kp(BigInt(s));let c=1;a>12?c=a-3:a>4?c=a-2:a>0&&(c=2);const u=Hs(c),l=new Array(Number(u)+1).fill(o),d=Math.floor((e.BITS-1)/c)*c;let h=o;for(let p=d;p>=0;p-=c){l.fill(o);for(let m=0;m<i;m++){const f=r[m],w=Number(f>>BigInt(p)&u);l[w]=l[w].add(t[m])}let g=o;for(let m=l.length-1,f=o;m>0;m--)f=f.add(l[m]),g=g.add(f);if(h=h.add(g),p!==0)for(let m=0;m<c;m++)h=h.double()}return h}function La(n,e){if(e){if(e.ORDER!==n)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return Zp(e),e}else return Rn(n)}function tu(n,e,t={}){if(!e||typeof e!="object")throw new Error(`expected valid ${n} CURVE object`);for(const a of["p","n","h"]){const c=e[a];if(!(typeof c=="bigint"&&c>yn))throw new Error(`CURVE.${a} must be positive bigint`)}const r=La(e.p,t.Fp),s=La(e.n,t.Fn),o=["Gx","Gy","a",n==="weierstrass"?"b":"d"];for(const a of o)if(!r.isValid(e[a]))throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);return{Fp:r,Fn:s}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ze=BigInt(0),Pe=BigInt(1),fi=BigInt(2),sg=BigInt(8),ig={zip215:!0};function og(n,e,t,r){const s=n.sqr(t),i=n.sqr(r),o=n.add(n.mul(e.a,s),i),a=n.add(n.ONE,n.mul(e.d,n.mul(s,i)));return n.eql(o,a)}function ag(n,e={}){const{Fp:t,Fn:r}=tu("edwards",n,e),{h:s,n:i}=n;kn(e,{},{uvRatio:"function"});const o=fi<<BigInt(r.BYTES*8)-Pe,a=m=>t.create(m),c=e.uvRatio||((m,f)=>{try{return{isValid:!0,value:t.sqrt(t.div(m,f))}}catch{return{isValid:!1,value:Ze}}});if(!og(t,n,n.Gx,n.Gy))throw new Error("bad curve params: generator point");function u(m,f,w=!1){const v=w?Pe:Ze;return At("coordinate "+m,f,v,o),f}function l(m){if(!(m instanceof p))throw new Error("ExtendedPoint expected")}const d=hs((m,f)=>{const{ex:w,ey:v,ez:x}=m,L=m.is0();f==null&&(f=L?sg:t.inv(x));const E=a(w*f),T=a(v*f),k=a(x*f);if(L)return{x:Ze,y:Pe};if(k!==Pe)throw new Error("invZ was invalid");return{x:E,y:T}}),h=hs(m=>{const{a:f,d:w}=n;if(m.is0())throw new Error("bad point: ZERO");const{ex:v,ey:x,ez:L,et:E}=m,T=a(v*v),k=a(x*x),D=a(L*L),y=a(D*D),S=a(T*f),b=a(D*a(S+k)),A=a(y+a(w*a(T*k)));if(b!==A)throw new Error("bad point: equation left != right (1)");const _=a(v*x),I=a(L*E);if(_!==I)throw new Error("bad point: equation left != right (2)");return!0});class p{constructor(f,w,v,x){this.ex=u("x",f),this.ey=u("y",w),this.ez=u("z",v,!0),this.et=u("t",x),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(f){if(f instanceof p)throw new Error("extended point not allowed");const{x:w,y:v}=f||{};return u("x",w),u("y",v),new p(w,v,Pe,a(w*v))}static normalizeZ(f){return Xl(p,"ez",f)}static msm(f,w){return eu(p,r,f,w)}_setWindowSize(f){this.precompute(f)}precompute(f=8,w=!0){return g.setWindowSize(this,f),w||this.multiply(fi),this}assertValidity(){h(this)}equals(f){l(f);const{ex:w,ey:v,ez:x}=this,{ex:L,ey:E,ez:T}=f,k=a(w*T),D=a(L*x),y=a(v*T),S=a(E*x);return k===D&&y===S}is0(){return this.equals(p.ZERO)}negate(){return new p(a(-this.ex),this.ey,this.ez,a(-this.et))}double(){const{a:f}=n,{ex:w,ey:v,ez:x}=this,L=a(w*w),E=a(v*v),T=a(fi*a(x*x)),k=a(f*L),D=w+v,y=a(a(D*D)-L-E),S=k+E,b=S-T,A=k-E,_=a(y*b),I=a(S*A),C=a(y*A),P=a(b*S);return new p(_,I,P,C)}add(f){l(f);const{a:w,d:v}=n,{ex:x,ey:L,ez:E,et:T}=this,{ex:k,ey:D,ez:y,et:S}=f,b=a(x*k),A=a(L*D),_=a(T*v*S),I=a(E*y),C=a((x+L)*(k+D)-b-A),P=I-_,R=I+_,O=a(A-w*b),N=a(C*P),F=a(R*O),M=a(C*O),B=a(P*R);return new p(N,F,B,M)}subtract(f){return this.add(f.negate())}multiply(f){const w=f;At("scalar",w,Pe,i);const{p:v,f:x}=g.wNAFCached(this,w,p.normalizeZ);return p.normalizeZ([v,x])[0]}multiplyUnsafe(f,w=p.ZERO){const v=f;return At("scalar",v,Ze,i),v===Ze?p.ZERO:this.is0()||v===Pe?this:g.wNAFCachedUnsafe(this,v,p.normalizeZ,w)}isSmallOrder(){return this.multiplyUnsafe(s).is0()}isTorsionFree(){return g.wNAFCachedUnsafe(this,i).is0()}toAffine(f){return d(this,f)}clearCofactor(){return s===Pe?this:this.multiplyUnsafe(s)}static fromBytes(f,w=!1){return st(f),this.fromHex(f,w)}static fromHex(f,w=!1){const{d:v,a:x}=n,L=t.BYTES;f=ce("pointHex",f,L),zt("zip215",w);const E=f.slice(),T=f[L-1];E[L-1]=T&-129;const k=Kt(E),D=w?o:t.ORDER;At("pointHex.y",k,Ze,D);const y=a(k*k),S=a(y-Pe),b=a(v*y-x);let{isValid:A,value:_}=c(S,b);if(!A)throw new Error("Point.fromHex: invalid y coordinate");const I=(_&Pe)===Pe,C=(T&128)!==0;if(!w&&_===Ze&&C)throw new Error("Point.fromHex: x=0 and x_0=1");return C!==I&&(_=a(-_)),p.fromAffine({x:_,y:k})}static fromPrivateScalar(f){return p.BASE.multiply(f)}toBytes(){const{x:f,y:w}=this.toAffine(),v=xr(w,t.BYTES);return v[v.length-1]|=f&Pe?128:0,v}toRawBytes(){return this.toBytes()}toHex(){return mn(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}p.BASE=new p(n.Gx,n.Gy,Pe,a(n.Gx*n.Gy)),p.ZERO=new p(Ze,Pe,Pe,Ze),p.Fp=t,p.Fn=r;const g=Jl(p,r.BYTES*8);return p}function cg(n,e){kn(e,{hash:"function"},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:t,hash:r}=e,{BASE:s,Fp:i,Fn:o}=n,a=o.ORDER,c=e.randomBytes||Ws,u=e.adjustScalarBytes||(E=>E),l=e.domain||((E,T,k)=>{if(zt("phflag",k),T.length||k)throw new Error("Contexts/pre-hash are not supported");return E});function d(E){return o.create(E)}function h(E){return d(Kt(E))}function p(E){const T=i.BYTES;E=ce("private key",E,T);const k=ce("hashed private key",r(E),2*T),D=u(k.slice(0,T)),y=k.slice(T,2*T),S=h(D);return{head:D,prefix:y,scalar:S}}function g(E){const{head:T,prefix:k,scalar:D}=p(E),y=s.multiply(D),S=y.toBytes();return{head:T,prefix:k,scalar:D,point:y,pointBytes:S}}function m(E){return g(E).pointBytes}function f(E=Uint8Array.of(),...T){const k=ht(...T);return h(r(l(k,ce("context",E),!!t)))}function w(E,T,k={}){E=ce("message",E),t&&(E=t(E));const{prefix:D,scalar:y,pointBytes:S}=g(T),b=f(k.context,D,E),A=s.multiply(b).toBytes(),_=f(k.context,A,S,E),I=d(b+_*y);At("signature.s",I,Ze,a);const C=i.BYTES,P=ht(A,xr(I,C));return ce("result",P,C*2)}const v=ig;function x(E,T,k,D=v){const{context:y,zip215:S}=D,b=i.BYTES;E=ce("signature",E,2*b),T=ce("message",T),k=ce("publicKey",k,b),S!==void 0&&zt("zip215",S),t&&(T=t(T));const A=Kt(E.slice(b,2*b));let _,I,C;try{_=n.fromHex(k,S),I=n.fromHex(E.slice(0,b),S),C=s.multiplyUnsafe(A)}catch{return!1}if(!S&&_.isSmallOrder())return!1;const P=f(y,I.toBytes(),_.toBytes(),T);return I.add(_.multiplyUnsafe(P)).subtract(C).clearCofactor().is0()}return s.precompute(8),{getPublicKey:m,sign:w,verify:x,utils:{getExtendedPublicKey:g,randomPrivateKey:()=>c(i.BYTES),precompute(E=8,T=n.BASE){return T.precompute(E,!1)}},Point:n}}function lg(n){const e={a:n.a,d:n.d,p:n.Fp.ORDER,n:n.n,h:n.h,Gx:n.Gx,Gy:n.Gy},t=n.Fp,r=Rn(e.n,n.nBitLength,!0),s={Fp:t,Fn:r,uvRatio:n.uvRatio},i={hash:n.hash,randomBytes:n.randomBytes,adjustScalarBytes:n.adjustScalarBytes,domain:n.domain,prehash:n.prehash,mapToCurve:n.mapToCurve};return{CURVE:e,curveOpts:s,eddsaOpts:i}}function ug(n,e){return Object.assign({},e,{ExtendedPoint:e.Point,CURVE:n})}function dg(n){const{CURVE:e,curveOpts:t,eddsaOpts:r}=lg(n),s=ag(e,t),i=cg(s,r);return ug(n,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const zn=BigInt(0),en=BigInt(1),Ur=BigInt(2);function hg(n){return kn(n,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...n})}function fg(n){const e=hg(n),{P:t,type:r,adjustScalarBytes:s,powPminus2:i,randomBytes:o}=e,a=r==="x25519";if(!a&&r!=="x448")throw new Error("invalid type");const c=o||Ws,u=a?255:448,l=a?32:56,d=BigInt(a?9:5),h=BigInt(a?121665:39081),p=a?Ur**BigInt(254):Ur**BigInt(447),g=a?BigInt(8)*Ur**BigInt(251)-en:BigInt(4)*Ur**BigInt(445)-en,m=p+g+en,f=y=>le(y,t),w=v(d);function v(y){return xr(f(y),l)}function x(y){const S=ce("u coordinate",y,l);return a&&(S[31]&=127),f(Kt(S))}function L(y){return Kt(s(ce("scalar",y,l)))}function E(y,S){const b=D(x(S),L(y));if(b===zn)throw new Error("invalid private or public key received");return v(b)}function T(y){return E(y,w)}function k(y,S,b){const A=f(y*(S-b));return S=f(S-A),b=f(b+A),{x_2:S,x_3:b}}function D(y,S){At("u",y,zn,t),At("scalar",S,p,m);const b=S,A=y;let _=en,I=zn,C=y,P=en,R=zn;for(let N=BigInt(u-1);N>=zn;N--){const F=b>>N&en;R^=F,{x_2:_,x_3:C}=k(R,_,C),{x_2:I,x_3:P}=k(R,I,P),R=F;const M=_+I,B=f(M*M),G=_-I,ne=f(G*G),V=B-ne,oe=C+P,Re=C-P,ve=f(Re*M),me=f(oe*G),Xt=ve+me,ot=ve-me;C=f(Xt*Xt),P=f(A*f(ot*ot)),_=f(B*ne),I=f(V*(B+f(h*V)))}({x_2:_,x_3:C}=k(R,_,C)),{x_2:I,x_3:P}=k(R,I,P);const O=i(I);return f(_*O)}return{scalarMult:E,scalarMultBase:T,getSharedSecret:(y,S)=>E(y,S),getPublicKey:y=>T(y),utils:{randomPrivateKey:()=>c(l)},GuBytes:w.slice()}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */BigInt(0);const pg=BigInt(1),ka=BigInt(2),gg=BigInt(3),mg=BigInt(5),yg=BigInt(8),Ar={p:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:yg,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function nu(n){const e=BigInt(10),t=BigInt(20),r=BigInt(40),s=BigInt(80),i=Ar.p,a=n*n%i*n%i,c=ae(a,ka,i)*a%i,u=ae(c,pg,i)*n%i,l=ae(u,mg,i)*u%i,d=ae(l,e,i)*l%i,h=ae(d,t,i)*d%i,p=ae(h,r,i)*h%i,g=ae(p,s,i)*p%i,m=ae(g,s,i)*p%i,f=ae(m,e,i)*l%i;return{pow_p_5_8:ae(f,ka,i)*n%i,b2:a}}function ru(n){return n[0]&=248,n[31]&=127,n[31]|=64,n}const Ra=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function wg(n,e){const t=Ar.p,r=le(e*e*e,t),s=le(r*r*e,t),i=nu(n*s).pow_p_5_8;let o=le(n*r*i,t);const a=le(e*o*o,t),c=o,u=le(o*Ra,t),l=a===n,d=a===le(-n,t),h=a===le(-n*Ra,t);return l&&(o=c),(d||h)&&(o=u),Yp(o,t)&&(o=le(-o,t)),{isValid:l||d,value:o}}const bg=Rn(Ar.p,void 0,!0),Eg={...Ar,Fp:bg,hash:qp,adjustScalarBytes:ru,uvRatio:wg},fs=dg(Eg),Br=(()=>{const n=Ar.p;return fg({P:n,type:"x25519",powPminus2:e=>{const{pow_p_5_8:t,b2:r}=nu(e);return le(ae(t,gg,n)*r,n)},adjustScalarBytes:ru})})();class Na extends Error{constructor(e="An error occurred while verifying a message"){super(e),this.name="VerificationError"}}class vg extends Error{constructor(e="Missing Web Crypto API"){super(e),this.name="WebCryptoMissingError"}}const Wt={get(n=globalThis){const e=n.crypto;if(e?.subtle==null)throw new vg("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return e}},su=32,Mo=64,eo=32;let ln;const iu=(async()=>{try{return await Wt.get().subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),!0}catch{return!1}})();function Sg(){const n=fs.utils.randomPrivateKey(),e=fs.getPublicKey(n);return{privateKey:Pg(n,e),publicKey:e}}async function xg(n,e){let t;n.length===Mo?t=n.subarray(0,32):t=n;const r={crv:"Ed25519",kty:"OKP",x:q(n.subarray(32),"base64url"),d:q(t,"base64url"),ext:!0,key_ops:["sign"]},s=await Wt.get().subtle.importKey("jwk",r,{name:"Ed25519"},!0,["sign"]),i=await Wt.get().subtle.sign({name:"Ed25519"},s,e instanceof Uint8Array?e:e.subarray());return new Uint8Array(i,0,i.byteLength)}function Ag(n,e){const t=n.subarray(0,eo);return fs.sign(e instanceof Uint8Array?e:e.subarray(),t)}async function _g(n,e){return ln==null&&(ln=await iu),ln?xg(n,e):Ag(n,e)}async function Cg(n,e,t){if(n.buffer instanceof ArrayBuffer){const r=await Wt.get().subtle.importKey("raw",n.buffer,{name:"Ed25519"},!1,["verify"]);return await Wt.get().subtle.verify({name:"Ed25519"},r,e,t instanceof Uint8Array?t:t.subarray())}throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys")}function Ig(n,e,t){return fs.verify(e,t instanceof Uint8Array?t:t.subarray(),n)}async function Tg(n,e,t){return ln==null&&(ln=await iu),ln?Cg(n,e,t):Ig(n,e,t)}function Pg(n,e){const t=new Uint8Array(Mo);for(let r=0;r<eo;r++)t[r]=n[r],t[eo+r]=e[r];return t}function Fo(n){return n==null?!1:typeof n.then=="function"&&typeof n.catch=="function"&&typeof n.finally=="function"}class ou{type="Ed25519";raw;constructor(e){this.raw=Uo(e,su)}toMultihash(){return vr.digest(ft(this))}toCID(){return re.createV1(114,this.toMultihash())}toString(){return ge.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Te(this.raw,e.raw)}verify(e,t,r){r?.signal?.throwIfAborted();const s=Tg(this.raw,t,e);return Fo(s)?s.then(i=>(r?.signal?.throwIfAborted(),i)):s}}class Dg{type="Ed25519";raw;publicKey;constructor(e,t){this.raw=Uo(e,Mo),this.publicKey=new ou(t)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Te(this.raw,e.raw)}sign(e,t){t?.signal?.throwIfAborted();const r=_g(this.raw,e);return Fo(r)?r.then(s=>(t?.signal?.throwIfAborted(),s)):(t?.signal?.throwIfAborted(),r)}}function au(n){return n=Uo(n,su),new ou(n)}async function Lg(){const{privateKey:n,publicKey:e}=Sg();return new Dg(n,e)}function Uo(n,e){if(n=Uint8Array.from(n??[]),n.length!==e)throw new K(`Key must be a Uint8Array of length ${e}, got ${n.length}`);return n}const kg=Math.pow(2,7),Rg=Math.pow(2,14),Ng=Math.pow(2,21),Bo=Math.pow(2,28),$o=Math.pow(2,35),qo=Math.pow(2,42),zo=Math.pow(2,49),X=128,Ae=127;function Ie(n){if(n<kg)return 1;if(n<Rg)return 2;if(n<Ng)return 3;if(n<Bo)return 4;if(n<$o)return 5;if(n<qo)return 6;if(n<zo)return 7;if(Number.MAX_SAFE_INTEGER!=null&&n>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function ps(n,e,t=0){switch(Ie(n)){case 8:e[t++]=n&255|X,n/=128;case 7:e[t++]=n&255|X,n/=128;case 6:e[t++]=n&255|X,n/=128;case 5:e[t++]=n&255|X,n/=128;case 4:e[t++]=n&255|X,n>>>=7;case 3:e[t++]=n&255|X,n>>>=7;case 2:e[t++]=n&255|X,n>>>=7;case 1:{e[t++]=n&255,n>>>=7;break}default:throw new Error("unreachable")}return e}function Og(n,e,t=0){switch(Ie(n)){case 8:e.set(t++,n&255|X),n/=128;case 7:e.set(t++,n&255|X),n/=128;case 6:e.set(t++,n&255|X),n/=128;case 5:e.set(t++,n&255|X),n/=128;case 4:e.set(t++,n&255|X),n>>>=7;case 3:e.set(t++,n&255|X),n>>>=7;case 2:e.set(t++,n&255|X),n>>>=7;case 1:{e.set(t++,n&255),n>>>=7;break}default:throw new Error("unreachable")}return e}function cu(n,e){let t=n[e],r=0;if(r+=t&Ae,t<X||(t=n[e+1],r+=(t&Ae)<<7,t<X)||(t=n[e+2],r+=(t&Ae)<<14,t<X)||(t=n[e+3],r+=(t&Ae)<<21,t<X)||(t=n[e+4],r+=(t&Ae)*Bo,t<X)||(t=n[e+5],r+=(t&Ae)*$o,t<X)||(t=n[e+6],r+=(t&Ae)*qo,t<X)||(t=n[e+7],r+=(t&Ae)*zo,t<X))return r;throw new RangeError("Could not decode varint")}function Mg(n,e){let t=n.get(e),r=0;if(r+=t&Ae,t<X||(t=n.get(e+1),r+=(t&Ae)<<7,t<X)||(t=n.get(e+2),r+=(t&Ae)<<14,t<X)||(t=n.get(e+3),r+=(t&Ae)<<21,t<X)||(t=n.get(e+4),r+=(t&Ae)*Bo,t<X)||(t=n.get(e+5),r+=(t&Ae)*$o,t<X)||(t=n.get(e+6),r+=(t&Ae)*qo,t<X)||(t=n.get(e+7),r+=(t&Ae)*zo,t<X))return r;throw new RangeError("Could not decode varint")}function un(n,e,t=0){return e==null&&(e=rt(Ie(n))),e instanceof Uint8Array?ps(n,e,t):Og(n,e,t)}function Gs(n,e=0){return n instanceof Uint8Array?cu(n,e):Mg(n,e)}const Ko=new Float32Array([-0]),_t=new Uint8Array(Ko.buffer);function Fg(n,e,t){Ko[0]=n,e[t]=_t[0],e[t+1]=_t[1],e[t+2]=_t[2],e[t+3]=_t[3]}function Ug(n,e){return _t[0]=n[e],_t[1]=n[e+1],_t[2]=n[e+2],_t[3]=n[e+3],Ko[0]}const Wo=new Float64Array([-0]),_e=new Uint8Array(Wo.buffer);function Bg(n,e,t){Wo[0]=n,e[t]=_e[0],e[t+1]=_e[1],e[t+2]=_e[2],e[t+3]=_e[3],e[t+4]=_e[4],e[t+5]=_e[5],e[t+6]=_e[6],e[t+7]=_e[7]}function $g(n,e){return _e[0]=n[e],_e[1]=n[e+1],_e[2]=n[e+2],_e[3]=n[e+3],_e[4]=n[e+4],_e[5]=n[e+5],_e[6]=n[e+6],_e[7]=n[e+7],Wo[0]}const qg=BigInt(Number.MAX_SAFE_INTEGER),zg=BigInt(Number.MIN_SAFE_INTEGER);class Ce{lo;hi;constructor(e,t){this.lo=e|0,this.hi=t|0}toNumber(e=!1){if(!e&&this.hi>>>31>0){const t=~this.lo+1>>>0;let r=~this.hi>>>0;return t===0&&(r=r+1>>>0),-(t+r*4294967296)}return this.lo+this.hi*4294967296}toBigInt(e=!1){if(e)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const t=~this.lo+1>>>0;let r=~this.hi>>>0;return t===0&&(r=r+1>>>0),-(BigInt(t)+(BigInt(r)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(e=!1){return this.toBigInt(e).toString()}zzEncode(){const e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this}zzDecode(){const e=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this}length(){const e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,r=this.hi>>>24;return r===0?t===0?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:r<128?9:10}static fromBigInt(e){if(e===0n)return Ut;if(e<qg&&e>zg)return this.fromNumber(Number(e));const t=e<0n;t&&(e=-e);let r=e>>32n,s=e-(r<<32n);return t&&(r=~r|0n,s=~s|0n,++s>Oa&&(s=0n,++r>Oa&&(r=0n))),new Ce(Number(s),Number(r))}static fromNumber(e){if(e===0)return Ut;const t=e<0;t&&(e=-e);let r=e>>>0,s=(e-r)/4294967296>>>0;return t&&(s=~s>>>0,r=~r>>>0,++r>4294967295&&(r=0,++s>4294967295&&(s=0))),new Ce(r,s)}static from(e){return typeof e=="number"?Ce.fromNumber(e):typeof e=="bigint"?Ce.fromBigInt(e):typeof e=="string"?Ce.fromBigInt(BigInt(e)):e.low!=null||e.high!=null?new Ce(e.low>>>0,e.high>>>0):Ut}}const Ut=new Ce(0,0);Ut.toBigInt=function(){return 0n};Ut.zzEncode=Ut.zzDecode=function(){return this};Ut.length=function(){return 1};const Oa=4294967296n;function Kg(n){let e=0,t=0;for(let r=0;r<n.length;++r)t=n.charCodeAt(r),t<128?e+=1:t<2048?e+=2:(t&64512)===55296&&(n.charCodeAt(r+1)&64512)===56320?(++r,e+=4):e+=3;return e}function Wg(n,e,t){if(t-e<1)return"";let s;const i=[];let o=0,a;for(;e<t;)a=n[e++],a<128?i[o++]=a:a>191&&a<224?i[o++]=(a&31)<<6|n[e++]&63:a>239&&a<365?(a=((a&7)<<18|(n[e++]&63)<<12|(n[e++]&63)<<6|n[e++]&63)-65536,i[o++]=55296+(a>>10),i[o++]=56320+(a&1023)):i[o++]=(a&15)<<12|(n[e++]&63)<<6|n[e++]&63,o>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,i)),o=0);return s!=null?(o>0&&s.push(String.fromCharCode.apply(String,i.slice(0,o))),s.join("")):String.fromCharCode.apply(String,i.slice(0,o))}function lu(n,e,t){const r=t;let s,i;for(let o=0;o<n.length;++o)s=n.charCodeAt(o),s<128?e[t++]=s:s<2048?(e[t++]=s>>6|192,e[t++]=s&63|128):(s&64512)===55296&&((i=n.charCodeAt(o+1))&64512)===56320?(s=65536+((s&1023)<<10)+(i&1023),++o,e[t++]=s>>18|240,e[t++]=s>>12&63|128,e[t++]=s>>6&63|128,e[t++]=s&63|128):(e[t++]=s>>12|224,e[t++]=s>>6&63|128,e[t++]=s&63|128);return t-r}function We(n,e){return RangeError(`index out of range: ${n.pos} + ${e??1} > ${n.len}`)}function $r(n,e){return(n[e-4]|n[e-3]<<8|n[e-2]<<16|n[e-1]<<24)>>>0}class Vg{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(e){this.buf=e,this.pos=0,this.len=e.length}uint32(){let e=4294967295;if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,We(this,10);return e}int32(){return this.uint32()|0}sint32(){const e=this.uint32();return e>>>1^-(e&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw We(this,4);return $r(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw We(this,4);return $r(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw We(this,4);const e=Ug(this.buf,this.pos);return this.pos+=4,e}double(){if(this.pos+8>this.len)throw We(this,4);const e=$g(this.buf,this.pos);return this.pos+=8,e}bytes(){const e=this.uint32(),t=this.pos,r=this.pos+e;if(r>this.len)throw We(this,e);return this.pos+=e,t===r?new Uint8Array(0):this.buf.subarray(t,r)}string(){const e=this.bytes();return Wg(e,0,e.length)}skip(e){if(typeof e=="number"){if(this.pos+e>this.len)throw We(this,e);this.pos+=e}else do if(this.pos>=this.len)throw We(this);while((this.buf[this.pos++]&128)!==0);return this}skipType(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(e=this.uint32()&7)!==4;)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${e} at offset ${this.pos}`)}return this}readLongVarint(){const e=new Ce(0,0);let t=0;if(this.len-this.pos>4){for(;t<4;++t)if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(this.buf[this.pos]&127)<<28)>>>0,e.hi=(e.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return e;t=0}else{for(;t<3;++t){if(this.pos>=this.len)throw We(this);if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(this.buf[this.pos++]&127)<<t*7)>>>0,e}if(this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw We(this);if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw We(this,8);const e=$r(this.buf,this.pos+=4),t=$r(this.buf,this.pos+=4);return new Ce(e,t)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const e=cu(this.buf,this.pos);return this.pos+=Ie(e),e}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function Hg(n){return new Vg(n instanceof Uint8Array?n:n.subarray())}function de(n,e,t){const r=Hg(n);return e.decode(r,void 0,t)}function Gg(n){let r,s=8192;return function(o){if(o<1||o>4096)return rt(o);s+o>8192&&(r=rt(8192),s=0);const a=r.subarray(s,s+=o);return(s&7)!==0&&(s=(s|7)+1),a}}class Gn{fn;len;next;val;constructor(e,t,r){this.fn=e,this.len=t,this.next=void 0,this.val=r}}function pi(){}class Qg{head;tail;len;next;constructor(e){this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}}const Yg=Gg();function Xg(n){return globalThis.Buffer!=null?rt(n):Yg(n)}class to{len;head;tail;states;constructor(){this.len=0,this.head=new Gn(pi,0,0),this.tail=this.head,this.states=null}_push(e,t,r){return this.tail=this.tail.next=new Gn(e,t,r),this.len+=t,this}uint32(e){return this.len+=(this.tail=this.tail.next=new jg((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this}int32(e){return e<0?this._push(qr,10,Ce.fromNumber(e)):this.uint32(e)}sint32(e){return this.uint32((e<<1^e>>31)>>>0)}uint64(e){const t=Ce.fromBigInt(e);return this._push(qr,t.length(),t)}uint64Number(e){return this._push(ps,Ie(e),e)}uint64String(e){return this.uint64(BigInt(e))}int64(e){return this.uint64(e)}int64Number(e){return this.uint64Number(e)}int64String(e){return this.uint64String(e)}sint64(e){const t=Ce.fromBigInt(e).zzEncode();return this._push(qr,t.length(),t)}sint64Number(e){const t=Ce.fromNumber(e).zzEncode();return this._push(qr,t.length(),t)}sint64String(e){return this.sint64(BigInt(e))}bool(e){return this._push(gi,1,e?1:0)}fixed32(e){return this._push(Kn,4,e>>>0)}sfixed32(e){return this.fixed32(e)}fixed64(e){const t=Ce.fromBigInt(e);return this._push(Kn,4,t.lo)._push(Kn,4,t.hi)}fixed64Number(e){const t=Ce.fromNumber(e);return this._push(Kn,4,t.lo)._push(Kn,4,t.hi)}fixed64String(e){return this.fixed64(BigInt(e))}sfixed64(e){return this.fixed64(e)}sfixed64Number(e){return this.fixed64Number(e)}sfixed64String(e){return this.fixed64String(e)}float(e){return this._push(Fg,4,e)}double(e){return this._push(Bg,8,e)}bytes(e){const t=e.length>>>0;return t===0?this._push(gi,1,0):this.uint32(t)._push(Jg,t,e)}string(e){const t=Kg(e);return t!==0?this.uint32(t)._push(lu,t,e):this._push(gi,1,0)}fork(){return this.states=new Qg(this),this.head=this.tail=new Gn(pi,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Gn(pi,0,0),this.len=0),this}ldelim(){const e=this.head,t=this.tail,r=this.len;return this.reset().uint32(r),r!==0&&(this.tail.next=e.next,this.tail=t,this.len+=r),this}finish(){let e=this.head.next;const t=Xg(this.len);let r=0;for(;e!=null;)e.fn(e.val,t,r),r+=e.len,e=e.next;return t}}function gi(n,e,t){e[t]=n&255}function Zg(n,e,t){for(;n>127;)e[t++]=n&127|128,n>>>=7;e[t]=n}class jg extends Gn{next;constructor(e,t){super(Zg,e,t),this.next=void 0}}function qr(n,e,t){for(;n.hi!==0;)e[t++]=n.lo&127|128,n.lo=(n.lo>>>7|n.hi<<25)>>>0,n.hi>>>=7;for(;n.lo>127;)e[t++]=n.lo&127|128,n.lo=n.lo>>>7;e[t++]=n.lo}function Kn(n,e,t){e[t]=n&255,e[t+1]=n>>>8&255,e[t+2]=n>>>16&255,e[t+3]=n>>>24}function Jg(n,e,t){e.set(n,t)}globalThis.Buffer!=null&&(to.prototype.bytes=function(n){const e=n.length>>>0;return this.uint32(e),e>0&&this._push(em,e,n),this},to.prototype.string=function(n){const e=globalThis.Buffer.byteLength(n);return this.uint32(e),e>0&&this._push(tm,e,n),this});function em(n,e,t){e.set(n,t)}function tm(n,e,t){n.length<40?lu(n,e,t):e.utf8Write!=null?e.utf8Write(n,t):e.set($(n),t)}function nm(){return new to}function he(n,e){const t=nm();return e.encode(n,t,{lengthDelimited:!1}),t.finish()}var gs;(function(n){n[n.VARINT=0]="VARINT",n[n.BIT64=1]="BIT64",n[n.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",n[n.START_GROUP=3]="START_GROUP",n[n.END_GROUP=4]="END_GROUP",n[n.BIT32=5]="BIT32"})(gs||(gs={}));function uu(n,e,t,r){return{name:n,type:e,encode:t,decode:r}}function Nn(n){function e(s){if(n[s.toString()]==null)throw new Error("Invalid enum value");return n[s]}const t=function(i,o){const a=e(i);o.int32(a)},r=function(i){const o=i.int32();return e(o)};return uu("enum",gs.VARINT,t,r)}function fe(n,e){return uu("message",gs.LENGTH_DELIMITED,n,e)}class mt extends Error{code="ERR_MAX_LENGTH";name="MaxLengthError"}class Ma extends Error{code="ERR_MAX_SIZE";name="MaxSizeError"}var we;(function(n){n.RSA="RSA",n.Ed25519="Ed25519",n.secp256k1="secp256k1",n.ECDSA="ECDSA"})(we||(we={}));var no;(function(n){n[n.RSA=0]="RSA",n[n.Ed25519=1]="Ed25519",n[n.secp256k1=2]="secp256k1",n[n.ECDSA=3]="ECDSA"})(no||(no={}));(function(n){n.codec=()=>Nn(no)})(we||(we={}));var wn;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.Type!=null&&(r.uint32(8),we.codec().encode(t.Type,r)),t.Data!=null&&(r.uint32(18),r.bytes(t.Data)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.Type=we.codec().decode(t);break}case 2:{i.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(wn||(wn={}));var Fa;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.Type!=null&&(r.uint32(8),we.codec().encode(t.Type,r)),t.Data!=null&&(r.uint32(18),r.bytes(t.Data)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.Type=we.codec().decode(t);break}case 2:{i.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(Fa||(Fa={}));function Vo(n){if(isNaN(n)||n<=0)throw new K("random bytes length must be a Number bigger than 0");return Ws(n)}const ns=ql;class rm{type="RSA";jwk;_raw;_multihash;constructor(e,t){this.jwk=e,this._multihash=t}get raw(){return this._raw==null&&(this._raw=cm(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return re.createV1(114,this._multihash)}toString(){return ge.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Te(this.raw,e.raw)}verify(e,t,r){return dm(this.jwk,t,e,r)}}const sm=18,im=1062,om=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function am(n){const e=Ks(n[1],{offset:0});return{kty:"RSA",n:q(e[0],"base64url"),e:q(e[1],"base64url")}}function cm(n){if(n.n==null||n.e==null)throw new K("JWK was missing components");return Jn([om,Nl(Jn([ji($(n.n,"base64url")),ji($(n.e,"base64url"))]))]).subarray()}function lm(n,e){if(n.byteLength>=im)throw new gl("Key size is too large");const t=Ks(n,{offset:0});return um(t,n,e)}function um(n,e,t){const r=am(n);if(t==null){const s=ns(wn.encode({Type:we.RSA,Data:e}));t=ar(sm,s)}return new rm(r,t)}async function dm(n,e,t,r){const s=await Wt.get().subtle.importKey("jwk",n,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);r?.signal?.throwIfAborted();const i=await Wt.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},s,e,t instanceof Uint8Array?t:t.subarray());return r?.signal?.throwIfAborted(),i}class du extends Fl{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,ko(e);const r=cr(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(r.length>s?e.create().update(r).digest():r);for(let o=0;o<i.length;o++)i[o]^=54;this.iHash.update(i),this.oHash=e.create();for(let o=0;o<i.length;o++)i[o]^=106;this.oHash.update(i),qt(i)}update(e){return ds(this),this.iHash.update(e),this}digestInto(e){ds(this),st(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:s,destroyed:i,blockLen:o,outputLen:a}=this;return e=e,e.finished=s,e.destroyed=i,e.blockLen=o,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Qs=(n,e,t)=>new du(n,e).update(t).digest();Qs.create=(n,e)=>new du(n,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ua(n){n.lowS!==void 0&&zt("lowS",n.lowS),n.prehash!==void 0&&zt("prehash",n.prehash)}class hm extends Error{constructor(e=""){super(e)}}const dt={Err:hm,_tlv:{encode:(n,e)=>{const{Err:t}=dt;if(n<0||n>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const r=e.length/2,s=Fr(r);if(s.length/2&128)throw new t("tlv.encode: long form length too big");const i=r>127?Fr(s.length/2|128):"";return Fr(n)+i+s+e},decode(n,e){const{Err:t}=dt;let r=0;if(n<0||n>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[r++]!==n)throw new t("tlv.decode: wrong tlv");const s=e[r++],i=!!(s&128);let o=0;if(!i)o=s;else{const c=s&127;if(!c)throw new t("tlv.decode(long): indefinite length not supported");if(c>4)throw new t("tlv.decode(long): byte length is too big");const u=e.subarray(r,r+c);if(u.length!==c)throw new t("tlv.decode: length bytes not complete");if(u[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const l of u)o=o<<8|l;if(r+=c,o<128)throw new t("tlv.decode(long): not minimal encoding")}const a=e.subarray(r,r+o);if(a.length!==o)throw new t("tlv.decode: wrong value length");return{v:a,l:e.subarray(r+o)}}},_int:{encode(n){const{Err:e}=dt;if(n<tr)throw new e("integer: negative integers are not allowed");let t=Fr(n);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(n){const{Err:e}=dt;if(n[0]&128)throw new e("invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return Vs(n)}},toSig(n){const{Err:e,_int:t,_tlv:r}=dt,s=ce("signature",n),{v:i,l:o}=r.decode(48,s);if(o.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=r.decode(2,i),{v:u,l}=r.decode(2,c);if(l.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(u)}},hexFromSig(n){const{_tlv:e,_int:t}=dt,r=e.encode(2,t.encode(n.r)),s=e.encode(2,t.encode(n.s)),i=r+s;return e.encode(48,i)}},tr=BigInt(0),nr=BigInt(1),fm=BigInt(2),zr=BigInt(3),pm=BigInt(4);function gm(n,e,t){function r(s){const i=n.sqr(s),o=n.mul(i,s);return n.add(n.add(o,n.mul(s,e)),t)}return r}function hu(n,e,t){const{BYTES:r}=n;function s(i){let o;if(typeof i=="bigint")o=i;else{let a=ce("private key",i);if(e){if(!e.includes(a.length*2))throw new Error("invalid private key");const c=new Uint8Array(r);c.set(a,c.length-a.length),a=c}try{o=n.fromBytes(a)}catch{throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof i}`)}}if(t&&(o=n.create(o)),!n.isValidNot0(o))throw new Error("invalid private key: out of range [1..N-1]");return o}return s}function mm(n,e={}){const{Fp:t,Fn:r}=tu("weierstrass",n,e),{h:s,n:i}=n;kn(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:o}=e;if(o&&(!t.is0(n.a)||typeof o.beta!="bigint"||typeof o.splitScalar!="function"))throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');function a(){if(!t.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function c(D,y,S){const{x:b,y:A}=y.toAffine(),_=t.toBytes(b);if(zt("isCompressed",S),S){a();const I=!t.isOdd(A);return ht(fu(I),_)}else return ht(Uint8Array.of(4),_,t.toBytes(A))}function u(D){st(D);const y=t.BYTES,S=y+1,b=2*y+1,A=D.length,_=D[0],I=D.subarray(1);if(A===S&&(_===2||_===3)){const C=t.fromBytes(I);if(!t.isValid(C))throw new Error("bad point: is not on curve, wrong x");const P=h(C);let R;try{R=t.sqrt(P)}catch(F){const M=F instanceof Error?": "+F.message:"";throw new Error("bad point: is not on curve, sqrt error"+M)}a();const O=t.isOdd(R);return(_&1)===1!==O&&(R=t.neg(R)),{x:C,y:R}}else if(A===b&&_===4){const C=t.fromBytes(I.subarray(y*0,y*1)),P=t.fromBytes(I.subarray(y*1,y*2));if(!p(C,P))throw new Error("bad point: is not on curve");return{x:C,y:P}}else throw new Error(`bad point: got length ${A}, expected compressed=${S} or uncompressed=${b}`)}const l=e.toBytes||c,d=e.fromBytes||u,h=gm(t,n.a,n.b);function p(D,y){const S=t.sqr(y),b=h(D);return t.eql(S,b)}if(!p(n.Gx,n.Gy))throw new Error("bad curve params: generator point");const g=t.mul(t.pow(n.a,zr),pm),m=t.mul(t.sqr(n.b),BigInt(27));if(t.is0(t.add(g,m)))throw new Error("bad curve params: a or b");function f(D,y,S=!1){if(!t.isValid(y)||S&&t.is0(y))throw new Error(`bad point coordinate ${D}`);return y}function w(D){if(!(D instanceof E))throw new Error("ProjectivePoint expected")}const v=hs((D,y)=>{const{px:S,py:b,pz:A}=D;if(t.eql(A,t.ONE))return{x:S,y:b};const _=D.is0();y==null&&(y=_?t.ONE:t.inv(A));const I=t.mul(S,y),C=t.mul(b,y),P=t.mul(A,y);if(_)return{x:t.ZERO,y:t.ZERO};if(!t.eql(P,t.ONE))throw new Error("invZ was invalid");return{x:I,y:C}}),x=hs(D=>{if(D.is0()){if(e.allowInfinityPoint&&!t.is0(D.py))return;throw new Error("bad point: ZERO")}const{x:y,y:S}=D.toAffine();if(!t.isValid(y)||!t.isValid(S))throw new Error("bad point: x or y not field elements");if(!p(y,S))throw new Error("bad point: equation left != right");if(!D.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function L(D,y,S,b,A){return S=new E(t.mul(S.px,D),S.py,S.pz),y=er(b,y),S=er(A,S),y.add(S)}class E{constructor(y,S,b){this.px=f("x",y),this.py=f("y",S,!0),this.pz=f("z",b),Object.freeze(this)}static fromAffine(y){const{x:S,y:b}=y||{};if(!y||!t.isValid(S)||!t.isValid(b))throw new Error("invalid affine point");if(y instanceof E)throw new Error("projective point not allowed");return t.is0(S)&&t.is0(b)?E.ZERO:new E(S,b,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(y){return Xl(E,"pz",y)}static fromBytes(y){return st(y),E.fromHex(y)}static fromHex(y){const S=E.fromAffine(d(ce("pointHex",y)));return S.assertValidity(),S}static fromPrivateKey(y){const S=hu(r,e.allowedPrivateKeyLengths,e.wrapPrivateKey);return E.BASE.multiply(S(y))}static msm(y,S){return eu(E,r,y,S)}precompute(y=8,S=!0){return k.setWindowSize(this,y),S||this.multiply(zr),this}_setWindowSize(y){this.precompute(y)}assertValidity(){x(this)}hasEvenY(){const{y}=this.toAffine();if(!t.isOdd)throw new Error("Field doesn't support isOdd");return!t.isOdd(y)}equals(y){w(y);const{px:S,py:b,pz:A}=this,{px:_,py:I,pz:C}=y,P=t.eql(t.mul(S,C),t.mul(_,A)),R=t.eql(t.mul(b,C),t.mul(I,A));return P&&R}negate(){return new E(this.px,t.neg(this.py),this.pz)}double(){const{a:y,b:S}=n,b=t.mul(S,zr),{px:A,py:_,pz:I}=this;let C=t.ZERO,P=t.ZERO,R=t.ZERO,O=t.mul(A,A),N=t.mul(_,_),F=t.mul(I,I),M=t.mul(A,_);return M=t.add(M,M),R=t.mul(A,I),R=t.add(R,R),C=t.mul(y,R),P=t.mul(b,F),P=t.add(C,P),C=t.sub(N,P),P=t.add(N,P),P=t.mul(C,P),C=t.mul(M,C),R=t.mul(b,R),F=t.mul(y,F),M=t.sub(O,F),M=t.mul(y,M),M=t.add(M,R),R=t.add(O,O),O=t.add(R,O),O=t.add(O,F),O=t.mul(O,M),P=t.add(P,O),F=t.mul(_,I),F=t.add(F,F),O=t.mul(F,M),C=t.sub(C,O),R=t.mul(F,N),R=t.add(R,R),R=t.add(R,R),new E(C,P,R)}add(y){w(y);const{px:S,py:b,pz:A}=this,{px:_,py:I,pz:C}=y;let P=t.ZERO,R=t.ZERO,O=t.ZERO;const N=n.a,F=t.mul(n.b,zr);let M=t.mul(S,_),B=t.mul(b,I),G=t.mul(A,C),ne=t.add(S,b),V=t.add(_,I);ne=t.mul(ne,V),V=t.add(M,B),ne=t.sub(ne,V),V=t.add(S,A);let oe=t.add(_,C);return V=t.mul(V,oe),oe=t.add(M,G),V=t.sub(V,oe),oe=t.add(b,A),P=t.add(I,C),oe=t.mul(oe,P),P=t.add(B,G),oe=t.sub(oe,P),O=t.mul(N,V),P=t.mul(F,G),O=t.add(P,O),P=t.sub(B,O),O=t.add(B,O),R=t.mul(P,O),B=t.add(M,M),B=t.add(B,M),G=t.mul(N,G),V=t.mul(F,V),B=t.add(B,G),G=t.sub(M,G),G=t.mul(N,G),V=t.add(V,G),M=t.mul(B,V),R=t.add(R,M),M=t.mul(oe,V),P=t.mul(ne,P),P=t.sub(P,M),M=t.mul(ne,B),O=t.mul(oe,O),O=t.add(O,M),new E(P,R,O)}subtract(y){return this.add(y.negate())}is0(){return this.equals(E.ZERO)}multiply(y){const{endo:S}=e;if(!r.isValidNot0(y))throw new Error("invalid scalar: out of range");let b,A;const _=I=>k.wNAFCached(this,I,E.normalizeZ);if(S){const{k1neg:I,k1:C,k2neg:P,k2:R}=S.splitScalar(y),{p:O,f:N}=_(C),{p:F,f:M}=_(R);A=N.add(M),b=L(S.beta,O,F,I,P)}else{const{p:I,f:C}=_(y);b=I,A=C}return E.normalizeZ([b,A])[0]}multiplyUnsafe(y){const{endo:S}=e,b=this;if(!r.isValid(y))throw new Error("invalid scalar: out of range");if(y===tr||b.is0())return E.ZERO;if(y===nr)return b;if(k.hasPrecomputes(this))return this.multiply(y);if(S){const{k1neg:A,k1:_,k2neg:I,k2:C}=S.splitScalar(y),{p1:P,p2:R}=rg(E,b,_,C);return L(S.beta,P,R,A,I)}else return k.wNAFCachedUnsafe(b,y)}multiplyAndAddUnsafe(y,S,b){const A=this.multiplyUnsafe(S).add(y.multiplyUnsafe(b));return A.is0()?void 0:A}toAffine(y){return v(this,y)}isTorsionFree(){const{isTorsionFree:y}=e;return s===nr?!0:y?y(E,this):k.wNAFCachedUnsafe(this,i).is0()}clearCofactor(){const{clearCofactor:y}=e;return s===nr?this:y?y(E,this):this.multiplyUnsafe(s)}toBytes(y=!0){return zt("isCompressed",y),this.assertValidity(),l(E,this,y)}toRawBytes(y=!0){return this.toBytes(y)}toHex(y=!0){return mn(this.toBytes(y))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}E.BASE=new E(n.Gx,n.Gy,t.ONE),E.ZERO=new E(t.ZERO,t.ONE,t.ZERO),E.Fp=t,E.Fn=r;const T=r.BITS,k=Jl(E,e.endo?Math.ceil(T/2):T);return E}function fu(n){return Uint8Array.of(n?2:3)}function ym(n,e,t={}){kn(e,{hash:"function"},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const r=e.randomBytes||Ws,s=e.hmac||((b,...A)=>Qs(e.hash,b,ht(...A))),{Fp:i,Fn:o}=n,{ORDER:a,BITS:c}=o;function u(b){const A=a>>nr;return b>A}function l(b){return u(b)?o.neg(b):b}function d(b,A){if(!o.isValidNot0(A))throw new Error(`invalid signature ${b}: out of range 1..CURVE.n`)}class h{constructor(A,_,I){d("r",A),d("s",_),this.r=A,this.s=_,I!=null&&(this.recovery=I),Object.freeze(this)}static fromCompact(A){const _=o.BYTES,I=ce("compactSignature",A,_*2);return new h(o.fromBytes(I.subarray(0,_)),o.fromBytes(I.subarray(_,_*2)))}static fromDER(A){const{r:_,s:I}=dt.toSig(ce("DER",A));return new h(_,I)}assertValidity(){}addRecoveryBit(A){return new h(this.r,this.s,A)}recoverPublicKey(A){const _=i.ORDER,{r:I,s:C,recovery:P}=this;if(P==null||![0,1,2,3].includes(P))throw new Error("recovery id invalid");if(a*fm<_&&P>1)throw new Error("recovery id is ambiguous for h>1 curve");const O=P===2||P===3?I+a:I;if(!i.isValid(O))throw new Error("recovery id 2 or 3 invalid");const N=i.toBytes(O),F=n.fromHex(ht(fu((P&1)===0),N)),M=o.inv(O),B=x(ce("msgHash",A)),G=o.create(-B*M),ne=o.create(C*M),V=n.BASE.multiplyUnsafe(G).add(F.multiplyUnsafe(ne));if(V.is0())throw new Error("point at infinify");return V.assertValidity(),V}hasHighS(){return u(this.s)}normalizeS(){return this.hasHighS()?new h(this.r,o.neg(this.s),this.recovery):this}toBytes(A){if(A==="compact")return ht(o.toBytes(this.r),o.toBytes(this.s));if(A==="der")return Ro(dt.hexFromSig(this));throw new Error("invalid format")}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return mn(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return mn(this.toBytes("compact"))}}const p=hu(o,t.allowedPrivateKeyLengths,t.wrapPrivateKey),g={isValidPrivateKey(b){try{return p(b),!0}catch{return!1}},normPrivateKeyToScalar:p,randomPrivateKey:()=>{const b=a;return eg(r(Yl(b)),b)},precompute(b=8,A=n.BASE){return A.precompute(b,!1)}};function m(b,A=!0){return n.fromPrivateKey(b).toBytes(A)}function f(b){if(typeof b=="bigint")return!1;if(b instanceof n)return!0;const _=ce("key",b).length,I=i.BYTES,C=I+1,P=2*I+1;if(!(t.allowedPrivateKeyLengths||o.BYTES===C))return _===C||_===P}function w(b,A,_=!0){if(f(b)===!0)throw new Error("first arg must be private key");if(f(A)===!1)throw new Error("second arg must be public key");return n.fromHex(A).multiply(p(b)).toBytes(_)}const v=e.bits2int||function(b){if(b.length>8192)throw new Error("input is too large");const A=Vs(b),_=b.length*8-c;return _>0?A>>BigInt(_):A},x=e.bits2int_modN||function(b){return o.create(v(b))},L=Hs(c);function E(b){return At("num < 2^"+c,b,tr,L),o.toBytes(b)}function T(b,A,_=k){if(["recovered","canonical"].some(ne=>ne in _))throw new Error("sign() legacy options not supported");const{hash:I}=e;let{lowS:C,prehash:P,extraEntropy:R}=_;C==null&&(C=!0),b=ce("msgHash",b),Ua(_),P&&(b=ce("prehashed msgHash",I(b)));const O=x(b),N=p(A),F=[E(N),E(O)];if(R!=null&&R!==!1){const ne=R===!0?r(i.BYTES):R;F.push(ce("extraEntropy",ne))}const M=ht(...F),B=O;function G(ne){const V=v(ne);if(!o.isValidNot0(V))return;const oe=o.inv(V),Re=n.BASE.multiply(V).toAffine(),ve=o.create(Re.x);if(ve===tr)return;const me=o.create(oe*o.create(B+ve*N));if(me===tr)return;let Xt=(Re.x===ve?0:2)|Number(Re.y&nr),ot=me;return C&&u(me)&&(ot=l(me),Xt^=1),new h(ve,ot,Xt)}return{seed:M,k2sig:G}}const k={lowS:e.lowS,prehash:!1},D={lowS:e.lowS,prehash:!1};function y(b,A,_=k){const{seed:I,k2sig:C}=T(b,A,_);return Wp(e.hash.outputLen,o.BYTES,s)(I,C)}n.BASE.precompute(8);function S(b,A,_,I=D){const C=b;A=ce("msgHash",A),_=ce("publicKey",_),Ua(I);const{lowS:P,prehash:R,format:O}=I;if("strict"in I)throw new Error("options.strict was renamed to lowS");if(O!==void 0&&!["compact","der","js"].includes(O))throw new Error('format must be "compact", "der" or "js"');const N=typeof C=="string"||Lo(C),F=!N&&!O&&typeof C=="object"&&C!==null&&typeof C.r=="bigint"&&typeof C.s=="bigint";if(!N&&!F)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let M,B;try{if(F)if(O===void 0||O==="js")M=new h(C.r,C.s);else throw new Error("invalid format");if(N){try{O!=="compact"&&(M=h.fromDER(C))}catch(ot){if(!(ot instanceof dt.Err))throw ot}!M&&O!=="der"&&(M=h.fromCompact(C))}B=n.fromHex(_)}catch{return!1}if(!M||P&&M.hasHighS())return!1;R&&(A=e.hash(A));const{r:G,s:ne}=M,V=x(A),oe=o.inv(ne),Re=o.create(V*oe),ve=o.create(G*oe),me=n.BASE.multiplyUnsafe(Re).add(B.multiplyUnsafe(ve));return me.is0()?!1:o.create(me.x)===G}return Object.freeze({getPublicKey:m,getSharedSecret:w,sign:y,verify:S,utils:g,Point:n,Signature:h})}function wm(n){const e={a:n.a,b:n.b,p:n.Fp.ORDER,n:n.n,h:n.h,Gx:n.Gx,Gy:n.Gy},t=n.Fp,r=Rn(e.n,n.nBitLength),s={Fp:t,Fn:r,allowedPrivateKeyLengths:n.allowedPrivateKeyLengths,allowInfinityPoint:n.allowInfinityPoint,endo:n.endo,wrapPrivateKey:n.wrapPrivateKey,isTorsionFree:n.isTorsionFree,clearCofactor:n.clearCofactor,fromBytes:n.fromBytes,toBytes:n.toBytes};return{CURVE:e,curveOpts:s}}function bm(n){const{CURVE:e,curveOpts:t}=wm(n),r={hash:n.hash,hmac:n.hmac,randomBytes:n.randomBytes,lowS:n.lowS,bits2int:n.bits2int,bits2int_modN:n.bits2int_modN};return{CURVE:e,curveOpts:t,ecdsaOpts:r}}function Em(n,e){return Object.assign({},e,{ProjectivePoint:e.Point,CURVE:n})}function vm(n){const{CURVE:e,curveOpts:t,ecdsaOpts:r}=bm(n),s=mm(e,t),i=ym(s,r,t);return Em(n,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Sm(n,e){const t=r=>vm({...n,hash:r});return{...t(e),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ms={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")};BigInt(0);const xm=BigInt(1),ro=BigInt(2),Ba=(n,e)=>(n+e/ro)/e;function Am(n){const e=ms.p,t=BigInt(3),r=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),u=n*n*n%e,l=u*u*n%e,d=ae(l,t,e)*l%e,h=ae(d,t,e)*l%e,p=ae(h,ro,e)*u%e,g=ae(p,s,e)*p%e,m=ae(g,i,e)*g%e,f=ae(m,a,e)*m%e,w=ae(f,c,e)*f%e,v=ae(w,a,e)*m%e,x=ae(v,t,e)*l%e,L=ae(x,o,e)*g%e,E=ae(L,r,e)*u%e,T=ae(E,ro,e);if(!so.eql(so.sqr(T),n))throw new Error("Cannot find square root");return T}const so=Rn(ms.p,void 0,void 0,{sqrt:Am}),ys=Sm({...ms,Fp:so,lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:n=>{const e=ms.n,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-xm*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=t,o=BigInt("0x100000000000000000000000000000000"),a=Ba(i*n,e),c=Ba(-r*n,e);let u=le(n-a*t-c*s,e),l=le(-a*r-c*i,e);const d=u>o,h=l>o;if(d&&(u=e-u),h&&(l=e-l),u>o||l>o)throw new Error("splitScalar: Endomorphism failed, k="+n);return{k1neg:d,k1:u,k2neg:h,k2:l}}}},ql);function _m(n,e,t,r){const s=Ll.digest(t instanceof Uint8Array?t:t.subarray());if(Fo(s))return s.then(({digest:i})=>(r?.signal?.throwIfAborted(),ys.verify(e,i,n))).catch(i=>{throw i.name==="AbortError"?i:new Na(String(i))});try{return r?.signal?.throwIfAborted(),ys.verify(e,s.digest,n)}catch(i){throw new Na(String(i))}}class Cm{type="secp256k1";raw;_key;constructor(e){this._key=Tm(e),this.raw=Im(this._key)}toMultihash(){return vr.digest(ft(this))}toCID(){return re.createV1(114,this.toMultihash())}toString(){return ge.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Te(this.raw,e.raw)}verify(e,t,r){return _m(this._key,t,e,r)}}function pu(n){return new Cm(n)}function Im(n){return ys.ProjectivePoint.fromHex(n).toRawBytes(!0)}function Tm(n){try{return ys.ProjectivePoint.fromHex(n),n}catch(e){throw new gl(String(e))}}async function Pm(n,e){return Lg()}function Pt(n,e){const{Type:t,Data:r}=wn.decode(n),s=r??new Uint8Array;switch(t){case we.RSA:return lm(s,e);case we.Ed25519:return au(s);case we.secp256k1:return pu(s);case we.ECDSA:return Ol(s);default:throw new Io}}function Dm(n){const{Type:e,Data:t}=wn.decode(n.digest),r=t??new Uint8Array;switch(e){case we.Ed25519:return au(r);case we.secp256k1:return pu(r);case we.ECDSA:return Ol(r);default:throw new Io}}function ft(n){return wn.encode({Type:we[n.type],Data:n.raw})}const gu=Symbol.for("nodejs.util.inspect.custom"),Lm=114;class Ho{type;multihash;publicKey;string;constructor(e){this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}[vo]=!0;toString(){return this.string==null&&(this.string=ge.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return re.createV1(Lm,this.multihash)}toJSON(){return this.toString()}equals(e){if(e==null)return!1;if(e instanceof Uint8Array)return Te(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(e?.toMultihash()?.bytes!=null)return Te(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[gu](){return`PeerId(${this.toString()})`}}class mu extends Ho{type="RSA";publicKey;constructor(e){super({...e,type:"RSA"}),this.publicKey=e.publicKey}}class yu extends Ho{type="Ed25519";publicKey;constructor(e){super({...e,type:"Ed25519"}),this.publicKey=e.publicKey}}class wu extends Ho{type="secp256k1";publicKey;constructor(e){super({...e,type:"secp256k1"}),this.publicKey=e.publicKey}}const km=2336;class bu{type="url";multihash;publicKey;url;constructor(e){this.url=e.toString(),this.multihash=vr.digest($(this.url))}[gu](){return`PeerId(${this.url})`}[vo]=!0;toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return re.createV1(km,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=q(e)),e.toString()===this.toString())}}const Rm=114,$a=2336;function yt(n,e){let t;if(n.charAt(0)==="1"||n.charAt(0)==="Q")t=Er(ge.decode(`z${n}`));else{if(n.startsWith("k51qzi5uqu5")||n.startsWith("kzwfwjn5ji4")||n.startsWith("k2k4r8")||n.startsWith("bafz"))return Cr(re.parse(n));throw new K('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return _r(t)}function lr(n){if(n.type==="Ed25519")return new yu({multihash:n.toCID().multihash,publicKey:n});if(n.type==="secp256k1")return new wu({multihash:n.toCID().multihash,publicKey:n});if(n.type==="RSA")return new mu({multihash:n.toCID().multihash,publicKey:n});throw new Io}function Nm(n){return lr(n.publicKey)}function _r(n){if(Mm(n))return new mu({multihash:n});if(Om(n))try{const e=Dm(n);if(e.type==="Ed25519")return new yu({multihash:n,publicKey:e});if(e.type==="secp256k1")return new wu({multihash:n,publicKey:e})}catch{const t=q(n.digest);return new bu(new URL(t))}throw new Oh("Supplied PeerID Multihash is invalid")}function Cr(n){if(n?.multihash==null||n.version==null||n.version===1&&n.code!==Rm&&n.code!==$a)throw new Nh("Supplied PeerID CID is invalid");if(n.code===$a){const e=q(n.multihash.digest);return new bu(new URL(e))}return _r(n.multihash)}function Om(n){return n.code===vr.code}function Mm(n){return n.code===Ll.code}const Fm=8,Go=1024*1024*4;let Um=class extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"},Eu=class extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"},Bm=class extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"},qa=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};function vu(n){return n[Symbol.asyncIterator]!=null}function Su(n,e){if(n.byteLength>e)throw new Eu("Message length too long")}const Ys=n=>{const e=Ie(n),t=rt(e);return un(n,t),Ys.bytes=e,t};Ys.bytes=0;function ws(n,e){e=e??{};const t=e.lengthEncoder??Ys,r=e?.maxDataLength??Go;function*s(i){Su(i,r);const o=t(i.byteLength);o instanceof Uint8Array?yield o:yield*o,i instanceof Uint8Array?yield i:yield*i}return vu(n)?async function*(){for await(const i of n)yield*s(i)}():function*(){for(const i of n)yield*s(i)}()}ws.single=(n,e)=>{e=e??{};const t=e.lengthEncoder??Ys,r=e?.maxDataLength??Go;return Su(n,r),new H(t(n.byteLength),n)};var kt;(function(n){n[n.LENGTH=0]="LENGTH",n[n.DATA=1]="DATA"})(kt||(kt={}));const Qo=n=>{const e=Gs(n);return Qo.bytes=Ie(e),e};Qo.bytes=0;function bs(n,e){const t=new H;let r=kt.LENGTH,s=-1;const i=e?.lengthDecoder??Qo,o=e?.maxLengthLength??Fm,a=e?.maxDataLength??Go;function*c(){for(;t.byteLength>0;){if(r===kt.LENGTH)try{if(s=i(t),s<0)throw new Um("Invalid message length");if(s>a)throw new Eu("Message length too long");const u=i.bytes;t.consume(u),e?.onLength!=null&&e.onLength(s),r=kt.DATA}catch(u){if(u instanceof RangeError){if(t.byteLength>o)throw new Bm("Message length length too long");break}throw u}if(r===kt.DATA){if(t.byteLength<s)break;const u=t.sublist(0,s);t.consume(s),e?.onData!=null&&e.onData(u),yield u,r=kt.LENGTH}}}return vu(n)?async function*(){for await(const u of n)t.append(u),yield*c();if(t.byteLength>0)throw new qa("Unexpected end of input")}():function*(){for(const u of n)t.append(u),yield*c();if(t.byteLength>0)throw new qa("Unexpected end of input")}()}bs.fromReader=(n,e)=>{let t=1;const r=async function*(){for(;;)try{const{done:i,value:o}=await n.next(t);if(i===!0)return;o!=null&&(yield o)}catch(i){if(i.code==="ERR_UNDER_READ")return{done:!0,value:null};throw i}finally{t=1}}();return bs(r,{...e??{},onLength:i=>{t=i}})};function z(){const n={};return n.promise=new Promise((e,t)=>{n.resolve=e,n.reject=t}),n}let za=class extends Error{type;code;constructor(e,t,r){super(e??"The operation was aborted"),this.type="aborted",this.name=r??"AbortError",this.code=t??"ABORT_ERR"}};async function ie(n,e,t){if(e==null)return n;if(e.aborted)return n.catch(()=>{}),Promise.reject(new za(t?.errorMessage,t?.errorCode,t?.errorName));let r;const s=new za(t?.errorMessage,t?.errorCode,t?.errorName);try{return await Promise.race([n,new Promise((i,o)=>{r=()=>{o(s)},e.addEventListener("abort",r)})])}finally{r!=null&&e.removeEventListener("abort",r)}}let $m=class{readNext;haveNext;ended;nextResult;error;constructor(){this.ended=!1,this.readNext=z(),this.haveNext=z()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=z(),e}async throw(e){return this.ended=!0,this.error=e,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=z(),await ie(this.readNext.promise,t?.signal,t)}};function qm(){return new $m}let zm=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};function Km(n,e){const t=qm();n.sink(t).catch(async o=>{await t.end(o)}),n.sink=async o=>{for await(const a of o)await t.push(a);await t.end()};let r=n.source;n.source[Symbol.iterator]!=null?r=n.source[Symbol.iterator]():n.source[Symbol.asyncIterator]!=null&&(r=n.source[Symbol.asyncIterator]());const s=new H;return{read:async o=>{if(o?.signal?.throwIfAborted(),o?.bytes==null){const{done:c,value:u}=await ie(r.next(),o?.signal);return c===!0?null:u}for(;s.byteLength<o.bytes;){const{value:c,done:u}=await ie(r.next(),o?.signal);if(u===!0)throw new zm("unexpected end of input");s.append(c)}const a=s.sublist(0,o.bytes);return s.consume(o.bytes),a},write:async(o,a)=>{a?.signal?.throwIfAborted(),o instanceof Uint8Array?await t.push(o,a):await t.push(o.subarray(),a)},unwrap:()=>{if(s.byteLength>0){const o=n.source;n.source=async function*(){e?.yieldBytes===!1?yield s:yield*s,yield*o}()}return n}}}class Wm extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"}class Vm extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"}class Hm extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"}function bn(n,e={}){const t=Km(n,e);e.maxDataLength!=null&&e.maxLengthLength==null&&(e.maxLengthLength=Ie(e.maxDataLength));const r=e?.lengthDecoder??Gs,s=e?.lengthEncoder??un;return{read:async o=>{let a=-1;const c=new H;for(;;){c.append(await t.read({...o,bytes:1}));try{a=r(c)}catch(u){if(u instanceof RangeError)continue;throw u}if(a<0)throw new Wm("Invalid message length");if(e?.maxLengthLength!=null&&c.byteLength>e.maxLengthLength)throw new Hm("message length length too long");if(a>-1)break}if(e?.maxDataLength!=null&&a>e.maxDataLength)throw new Vm("message length too long");return t.read({...o,bytes:a})},write:async(o,a)=>{await t.write(new H(s(o.byteLength),o),a)},writeV:async(o,a)=>{const c=new H(...o.flatMap(u=>[s(u.byteLength),u]));await t.write(c,a)},unwrap:()=>t.unwrap()}}function Ka(){const n=z();let e=!1;return{sink:async t=>{if(e)throw new Error("already piped");e=!0,n.resolve(t)},source:async function*(){yield*await n.promise}()}}function Gm(){const n=Ka(),e=Ka();return[{source:n.source,sink:e.sink},{source:e.source,sink:n.sink}]}class Wa{buffer;mask;top;btm;next;constructor(e){if(!(e>0)||(e-1&e)!==0)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){const e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return this.buffer[this.btm]===void 0}}class mi{size;hwm;head;tail;constructor(e={}){this.hwm=e.splitLimit??16,this.head=new Wa(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return e?.byteLength!=null?e.byteLength:1}push(e){if(e?.value!=null&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){const t=this.head;this.head=t.next=new Wa(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(e===void 0&&this.tail.next!=null){const t=this.tail.next;this.tail.next=null,this.tail=t,e=this.tail.shift()}return e?.value!=null&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}}let Qm=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.code=t??"ABORT_ERR"}};function On(n={}){return Ym(t=>{const r=t.shift();if(r==null)return{done:!0};if(r.error!=null)throw r.error;return{done:r.done===!0,value:r.value}},n)}function Ym(n,e){e=e??{};let t=e.onEnd,r=new mi,s,i,o,a=z();const c=async()=>{try{return r.isEmpty()?o?{done:!0}:await new Promise((f,w)=>{i=v=>{i=null,r.push(v);try{f(n(r))}catch(x){w(x)}return s}}):n(r)}finally{r.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=z()})}},u=f=>i!=null?i(f):(r.push(f),s),l=f=>(r=new mi,i!=null?i({error:f}):(r.push({error:f}),s)),d=f=>{if(o)return s;if(e?.objectMode!==!0&&f?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return u({done:!1,value:f})},h=f=>o?s:(o=!0,f!=null?l(f):u({done:!0})),p=()=>(r=new mi,h(),{done:!0}),g=f=>(h(f),{done:!0});if(s={[Symbol.asyncIterator](){return this},next:c,return:p,throw:g,push:d,end:h,get readableLength(){return r.size},onEmpty:async f=>{const w=f?.signal;if(w?.throwIfAborted(),r.isEmpty())return;let v,x;w!=null&&(v=new Promise((L,E)=>{x=()=>{E(new Qm)},w.addEventListener("abort",x)}));try{await Promise.race([a.promise,v])}finally{x!=null&&w!=null&&w?.removeEventListener("abort",x)}}},t==null)return s;const m=s;return s={[Symbol.asyncIterator](){return this},next(){return m.next()},throw(f){return m.throw(f),t!=null&&(t(f),t=void 0),{done:!0}},return(){return m.return(),t!=null&&(t(),t=void 0),{done:!0}},push:d,end(f){return m.end(f),t!=null&&(t(f),t=void 0),s},get readableLength(){return m.readableLength},onEmpty:f=>m.onEmpty(f)},s}let Xm=class{readNext;haveNext;ended;nextResult;error;constructor(){this.ended=!1,this.readNext=z(),this.haveNext=z()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=z(),e}async throw(e){return this.ended=!0,this.error=e,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=z(),await ie(this.readNext.promise,t?.signal,t)}};function Zm(){return new Xm}function jm(n){return n[Symbol.asyncIterator]!=null}async function Jm(n,e,t){try{await Promise.all(n.map(async r=>{for await(const s of r)await e.push(s,{signal:t}),t.throwIfAborted()})),await e.end(void 0,{signal:t})}catch(r){await e.end(r,{signal:t}).catch(()=>{})}}async function*ey(n){const e=new AbortController,t=Zm();Jm(n,t,e.signal).catch(()=>{});try{yield*t}finally{e.abort()}}function*ty(n){for(const e of n)yield*e}function Es(...n){const e=[];for(const t of n)jm(t)||e.push(t);return e.length===n.length?ty(e):ey(n)}function xu(n,...e){if(n==null)throw new Error("Empty pipeline");if(yi(n)){const r=n;n=()=>r.source}else if(_u(n)||Au(n)){const r=n;n=()=>r}const t=[n,...e];if(t.length>1&&yi(t[t.length-1])&&(t[t.length-1]=t[t.length-1].sink),t.length>2)for(let r=1;r<t.length-1;r++)yi(t[r])&&(t[r]=ry(t[r]));return ny(...t)}const ny=(...n)=>{let e;for(;n.length>0;)e=n.shift()(e);return e},Au=n=>n?.[Symbol.asyncIterator]!=null,_u=n=>n?.[Symbol.iterator]!=null,yi=n=>n==null?!1:n.sink!=null&&n.source!=null,ry=n=>e=>{const t=n.sink(e);if(t?.then!=null){const r=On({objectMode:!0});t.then(()=>{r.end()},o=>{r.end(o)});let s;const i=n.source;if(Au(i))s=async function*(){yield*i,r.end()};else if(_u(i))s=function*(){yield*i,r.end()};else throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");return Es(r,s())}return n.source},ur=65535,Va=ur-16,Ir=!!globalThis.process?.env?.DUMP_SESSION_KEYS;/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function Cu(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function io(n){if(typeof n!="boolean")throw new Error(`boolean expected, not ${n}`)}function wi(n){if(!Number.isSafeInteger(n)||n<0)throw new Error("positive integer expected, got "+n)}function Oe(n,...e){if(!Cu(n))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(n.length))throw new Error("Uint8Array expected of length "+e+", got length="+n.length)}function Ha(n,e=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(e&&n.finished)throw new Error("Hash#digest() has already been called")}function sy(n,e){Oe(n);const t=e.outputLen;if(n.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function Tt(n){return new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength/4))}function En(...n){for(let e=0;e<n.length;e++)n[e].fill(0)}function iy(n){return new DataView(n.buffer,n.byteOffset,n.byteLength)}const oy=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function ay(n){if(typeof n!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(n))}function oo(n){if(typeof n=="string")n=ay(n);else if(Cu(n))n=ao(n);else throw new Error("Uint8Array expected, got "+typeof n);return n}function cy(n,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(n,e)}function ly(n,e){if(n.length!==e.length)return!1;let t=0;for(let r=0;r<n.length;r++)t|=n[r]^e[r];return t===0}const uy=(n,e)=>{function t(r,...s){if(Oe(r),!oy)throw new Error("Non little-endian hardware is not yet supported");if(n.nonceLength!==void 0){const l=s[0];if(!l)throw new Error("nonce / iv required");n.varSizeNonce?Oe(l):Oe(l,n.nonceLength)}const i=n.tagLength;i&&s[1]!==void 0&&Oe(s[1]);const o=e(r,...s),a=(l,d)=>{if(d!==void 0){if(l!==2)throw new Error("cipher output not supported");Oe(d)}};let c=!1;return{encrypt(l,d){if(c)throw new Error("cannot encrypt() twice with same key + nonce");return c=!0,Oe(l),a(o.encrypt.length,d),o.encrypt(l,d)},decrypt(l,d){if(Oe(l),i&&l.length<i)throw new Error("invalid ciphertext length: smaller than tagLength="+i);return a(o.decrypt.length,d),o.decrypt(l,d)}}}return Object.assign(t,n),t};function Ga(n,e,t=!0){if(e===void 0)return new Uint8Array(n);if(e.length!==n)throw new Error("invalid output length, expected "+n+", got: "+e.length);if(t&&!hy(e))throw new Error("invalid output, must be aligned");return e}function Qa(n,e,t,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(e,t,r);const s=BigInt(32),i=BigInt(4294967295),o=Number(t>>s&i),a=Number(t&i),c=4,u=0;n.setUint32(e+c,o,r),n.setUint32(e+u,a,r)}function dy(n,e,t){io(t);const r=new Uint8Array(16),s=iy(r);return Qa(s,0,BigInt(e),t),Qa(s,8,BigInt(n),t),r}function hy(n){return n.byteOffset%4===0}function ao(n){return Uint8Array.from(n)}const Iu=n=>Uint8Array.from(n.split("").map(e=>e.charCodeAt(0))),fy=Iu("expand 16-byte k"),py=Iu("expand 32-byte k"),gy=Tt(fy),my=Tt(py);function Q(n,e){return n<<e|n>>>32-e}function co(n){return n.byteOffset%4===0}const Kr=64,yy=16,Tu=2**32-1,Ya=new Uint32Array;function wy(n,e,t,r,s,i,o,a){const c=s.length,u=new Uint8Array(Kr),l=Tt(u),d=co(s)&&co(i),h=d?Tt(s):Ya,p=d?Tt(i):Ya;for(let g=0;g<c;o++){if(n(e,t,r,l,o,a),o>=Tu)throw new Error("arx: counter overflow");const m=Math.min(Kr,c-g);if(d&&m===Kr){const f=g/4;if(g%4!==0)throw new Error("arx: invalid block position");for(let w=0,v;w<yy;w++)v=f+w,p[v]=h[v]^l[w];g+=Kr;continue}for(let f=0,w;f<m;f++)w=g+f,i[w]=s[w]^u[f];g+=m}}function by(n,e){const{allowShortKeys:t,extendNonceFn:r,counterLength:s,counterRight:i,rounds:o}=cy({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof n!="function")throw new Error("core must be a function");return wi(s),wi(o),io(i),io(t),(a,c,u,l,d=0)=>{Oe(a),Oe(c),Oe(u);const h=u.length;if(l===void 0&&(l=new Uint8Array(h)),Oe(l),wi(d),d<0||d>=Tu)throw new Error("arx: counter overflow");if(l.length<h)throw new Error(`arx: output (${l.length}) is shorter than data (${h})`);const p=[];let g=a.length,m,f;if(g===32)p.push(m=ao(a)),f=my;else if(g===16&&t)m=new Uint8Array(32),m.set(a),m.set(a,16),f=gy,p.push(m);else throw new Error(`arx: invalid 32-byte key, got length=${g}`);co(c)||p.push(c=ao(c));const w=Tt(m);if(r){if(c.length!==24)throw new Error("arx: extended nonce must be 24 bytes");r(f,w,Tt(c.subarray(0,16)),w),c=c.subarray(16)}const v=16-s;if(v!==c.length)throw new Error(`arx: nonce must be ${v} or 16 bytes`);if(v!==12){const L=new Uint8Array(12);L.set(c,i?0:12-c.length),c=L,p.push(c)}const x=Tt(c);return wy(n,f,w,x,u,l,d,o),En(...p),l}}const ye=(n,e)=>n[e++]&255|(n[e++]&255)<<8;class Ey{constructor(e){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,e=oo(e),Oe(e,32);const t=ye(e,0),r=ye(e,2),s=ye(e,4),i=ye(e,6),o=ye(e,8),a=ye(e,10),c=ye(e,12),u=ye(e,14);this.r[0]=t&8191,this.r[1]=(t>>>13|r<<3)&8191,this.r[2]=(r>>>10|s<<6)&7939,this.r[3]=(s>>>7|i<<9)&8191,this.r[4]=(i>>>4|o<<12)&255,this.r[5]=o>>>1&8190,this.r[6]=(o>>>14|a<<2)&8191,this.r[7]=(a>>>11|c<<5)&8065,this.r[8]=(c>>>8|u<<8)&8191,this.r[9]=u>>>5&127;for(let l=0;l<8;l++)this.pad[l]=ye(e,16+2*l)}process(e,t,r=!1){const s=r?0:2048,{h:i,r:o}=this,a=o[0],c=o[1],u=o[2],l=o[3],d=o[4],h=o[5],p=o[6],g=o[7],m=o[8],f=o[9],w=ye(e,t+0),v=ye(e,t+2),x=ye(e,t+4),L=ye(e,t+6),E=ye(e,t+8),T=ye(e,t+10),k=ye(e,t+12),D=ye(e,t+14);let y=i[0]+(w&8191),S=i[1]+((w>>>13|v<<3)&8191),b=i[2]+((v>>>10|x<<6)&8191),A=i[3]+((x>>>7|L<<9)&8191),_=i[4]+((L>>>4|E<<12)&8191),I=i[5]+(E>>>1&8191),C=i[6]+((E>>>14|T<<2)&8191),P=i[7]+((T>>>11|k<<5)&8191),R=i[8]+((k>>>8|D<<8)&8191),O=i[9]+(D>>>5|s),N=0,F=N+y*a+S*(5*f)+b*(5*m)+A*(5*g)+_*(5*p);N=F>>>13,F&=8191,F+=I*(5*h)+C*(5*d)+P*(5*l)+R*(5*u)+O*(5*c),N+=F>>>13,F&=8191;let M=N+y*c+S*a+b*(5*f)+A*(5*m)+_*(5*g);N=M>>>13,M&=8191,M+=I*(5*p)+C*(5*h)+P*(5*d)+R*(5*l)+O*(5*u),N+=M>>>13,M&=8191;let B=N+y*u+S*c+b*a+A*(5*f)+_*(5*m);N=B>>>13,B&=8191,B+=I*(5*g)+C*(5*p)+P*(5*h)+R*(5*d)+O*(5*l),N+=B>>>13,B&=8191;let G=N+y*l+S*u+b*c+A*a+_*(5*f);N=G>>>13,G&=8191,G+=I*(5*m)+C*(5*g)+P*(5*p)+R*(5*h)+O*(5*d),N+=G>>>13,G&=8191;let ne=N+y*d+S*l+b*u+A*c+_*a;N=ne>>>13,ne&=8191,ne+=I*(5*f)+C*(5*m)+P*(5*g)+R*(5*p)+O*(5*h),N+=ne>>>13,ne&=8191;let V=N+y*h+S*d+b*l+A*u+_*c;N=V>>>13,V&=8191,V+=I*a+C*(5*f)+P*(5*m)+R*(5*g)+O*(5*p),N+=V>>>13,V&=8191;let oe=N+y*p+S*h+b*d+A*l+_*u;N=oe>>>13,oe&=8191,oe+=I*c+C*a+P*(5*f)+R*(5*m)+O*(5*g),N+=oe>>>13,oe&=8191;let Re=N+y*g+S*p+b*h+A*d+_*l;N=Re>>>13,Re&=8191,Re+=I*u+C*c+P*a+R*(5*f)+O*(5*m),N+=Re>>>13,Re&=8191;let ve=N+y*m+S*g+b*p+A*h+_*d;N=ve>>>13,ve&=8191,ve+=I*l+C*u+P*c+R*a+O*(5*f),N+=ve>>>13,ve&=8191;let me=N+y*f+S*m+b*g+A*p+_*h;N=me>>>13,me&=8191,me+=I*d+C*l+P*u+R*c+O*a,N+=me>>>13,me&=8191,N=(N<<2)+N|0,N=N+F|0,F=N&8191,N=N>>>13,M+=N,i[0]=F,i[1]=M,i[2]=B,i[3]=G,i[4]=ne,i[5]=V,i[6]=oe,i[7]=Re,i[8]=ve,i[9]=me}finalize(){const{h:e,pad:t}=this,r=new Uint16Array(10);let s=e[1]>>>13;e[1]&=8191;for(let a=2;a<10;a++)e[a]+=s,s=e[a]>>>13,e[a]&=8191;e[0]+=s*5,s=e[0]>>>13,e[0]&=8191,e[1]+=s,s=e[1]>>>13,e[1]&=8191,e[2]+=s,r[0]=e[0]+5,s=r[0]>>>13,r[0]&=8191;for(let a=1;a<10;a++)r[a]=e[a]+s,s=r[a]>>>13,r[a]&=8191;r[9]-=8192;let i=(s^1)-1;for(let a=0;a<10;a++)r[a]&=i;i=~i;for(let a=0;a<10;a++)e[a]=e[a]&i|r[a];e[0]=(e[0]|e[1]<<13)&65535,e[1]=(e[1]>>>3|e[2]<<10)&65535,e[2]=(e[2]>>>6|e[3]<<7)&65535,e[3]=(e[3]>>>9|e[4]<<4)&65535,e[4]=(e[4]>>>12|e[5]<<1|e[6]<<14)&65535,e[5]=(e[6]>>>2|e[7]<<11)&65535,e[6]=(e[7]>>>5|e[8]<<8)&65535,e[7]=(e[8]>>>8|e[9]<<5)&65535;let o=e[0]+t[0];e[0]=o&65535;for(let a=1;a<8;a++)o=(e[a]+t[a]|0)+(o>>>16)|0,e[a]=o&65535;En(r)}update(e){Ha(this),e=oo(e),Oe(e);const{buffer:t,blockLen:r}=this,s=e.length;for(let i=0;i<s;){const o=Math.min(r-this.pos,s-i);if(o===r){for(;r<=s-i;i+=r)this.process(e,i);continue}t.set(e.subarray(i,i+o),this.pos),this.pos+=o,i+=o,this.pos===r&&(this.process(t,0,!1),this.pos=0)}return this}destroy(){En(this.h,this.r,this.buffer,this.pad)}digestInto(e){Ha(this),sy(e,this),this.finished=!0;const{buffer:t,h:r}=this;let{pos:s}=this;if(s){for(t[s++]=1;s<16;s++)t[s]=0;this.process(t,0,!0)}this.finalize();let i=0;for(let o=0;o<8;o++)e[i++]=r[o]>>>0,e[i++]=r[o]>>>8;return e}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}}function vy(n){const e=(r,s)=>n(s).update(oo(r)).digest(),t=n(new Uint8Array(32));return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=r=>n(r),e}const Sy=vy(n=>new Ey(n));function xy(n,e,t,r,s,i=20){let o=n[0],a=n[1],c=n[2],u=n[3],l=e[0],d=e[1],h=e[2],p=e[3],g=e[4],m=e[5],f=e[6],w=e[7],v=s,x=t[0],L=t[1],E=t[2],T=o,k=a,D=c,y=u,S=l,b=d,A=h,_=p,I=g,C=m,P=f,R=w,O=v,N=x,F=L,M=E;for(let G=0;G<i;G+=2)T=T+S|0,O=Q(O^T,16),I=I+O|0,S=Q(S^I,12),T=T+S|0,O=Q(O^T,8),I=I+O|0,S=Q(S^I,7),k=k+b|0,N=Q(N^k,16),C=C+N|0,b=Q(b^C,12),k=k+b|0,N=Q(N^k,8),C=C+N|0,b=Q(b^C,7),D=D+A|0,F=Q(F^D,16),P=P+F|0,A=Q(A^P,12),D=D+A|0,F=Q(F^D,8),P=P+F|0,A=Q(A^P,7),y=y+_|0,M=Q(M^y,16),R=R+M|0,_=Q(_^R,12),y=y+_|0,M=Q(M^y,8),R=R+M|0,_=Q(_^R,7),T=T+b|0,M=Q(M^T,16),P=P+M|0,b=Q(b^P,12),T=T+b|0,M=Q(M^T,8),P=P+M|0,b=Q(b^P,7),k=k+A|0,O=Q(O^k,16),R=R+O|0,A=Q(A^R,12),k=k+A|0,O=Q(O^k,8),R=R+O|0,A=Q(A^R,7),D=D+_|0,N=Q(N^D,16),I=I+N|0,_=Q(_^I,12),D=D+_|0,N=Q(N^D,8),I=I+N|0,_=Q(_^I,7),y=y+S|0,F=Q(F^y,16),C=C+F|0,S=Q(S^C,12),y=y+S|0,F=Q(F^y,8),C=C+F|0,S=Q(S^C,7);let B=0;r[B++]=o+T|0,r[B++]=a+k|0,r[B++]=c+D|0,r[B++]=u+y|0,r[B++]=l+S|0,r[B++]=d+b|0,r[B++]=h+A|0,r[B++]=p+_|0,r[B++]=g+I|0,r[B++]=m+C|0,r[B++]=f+P|0,r[B++]=w+R|0,r[B++]=v+O|0,r[B++]=x+N|0,r[B++]=L+F|0,r[B++]=E+M|0}const Ay=by(xy,{counterRight:!1,counterLength:4,allowShortKeys:!1}),_y=new Uint8Array(16),Xa=(n,e)=>{n.update(e);const t=e.length%16;t&&n.update(_y.subarray(t))},Cy=new Uint8Array(32);function Za(n,e,t,r,s){const i=n(e,t,Cy),o=Sy.create(i);s&&Xa(o,s),Xa(o,r);const a=dy(r.length,s?s.length:0,!0);o.update(a);const c=o.digest();return En(i,a),c}const Iy=n=>(e,t,r)=>({encrypt(i,o){const a=i.length;o=Ga(a+16,o,!1),o.set(i);const c=o.subarray(0,-16);n(e,t,c,c,1);const u=Za(n,e,t,c,r);return o.set(u,a),En(u),o},decrypt(i,o){o=Ga(i.length-16,o,!1);const a=i.subarray(0,-16),c=i.subarray(-16),u=Za(n,e,t,a,r);if(!ly(c,u))throw new Error("invalid tag");return o.set(i.subarray(0,-16)),n(e,t,o,o,1),En(u),o}}),ja=uy({blockSize:64,nonceLength:12,tagLength:16},Iy(Ay));function Ty(n,e,t){return ko(n),t===void 0&&(t=new Uint8Array(n.outputLen)),Qs(n,cr(t),cr(e))}const bi=Uint8Array.from([0]),Ja=Uint8Array.of();function Py(n,e,t,r=32){ko(n),us(r);const s=n.outputLen;if(r>255*s)throw new Error("Length should be <= 255*HashLen");const i=Math.ceil(r/s);t===void 0&&(t=Ja);const o=new Uint8Array(i*s),a=Qs.create(n,e),c=a._cloneInto(),u=new Uint8Array(a.outputLen);for(let l=0;l<i;l++)bi[0]=l+1,c.update(l===0?Ja:u).update(t).update(bi).digestInto(u),o.set(u,s*l),a._cloneInto(c);return a.destroy(),c.destroy(),qt(u,bi),o.slice(0,r)}const Dy={hashSHA256(n){return ns(n.subarray())},getHKDF(n,e){const t=Ty(ns,e,n),s=Py(ns,t,void 0,96),i=s.subarray(0,32),o=s.subarray(32,64),a=s.subarray(64,96);return[i,o,a]},generateX25519KeyPair(){const n=Br.utils.randomPrivateKey();return{publicKey:Br.getPublicKey(n),privateKey:n}},generateX25519KeyPairFromSeed(n){return{publicKey:Br.getPublicKey(n),privateKey:n}},generateX25519SharedKey(n,e){return Br.getSharedSecret(n.subarray(),e.subarray())},chaCha20Poly1305Encrypt(n,e,t,r){return ja(r,e,t).encrypt(n.subarray())},chaCha20Poly1305Decrypt(n,e,t,r,s){return ja(r,e,t).decrypt(n.subarray(),s)}},Ly=Dy;function ky(n){return{generateKeypair:n.generateX25519KeyPair,dh:(e,t)=>n.generateX25519SharedKey(e.privateKey,t).subarray(0,32),encrypt:n.chaCha20Poly1305Encrypt,decrypt:n.chaCha20Poly1305Decrypt,hash:n.hashSHA256,hkdf:n.getHKDF}}const vs=n=>{const e=rt(2);return e[0]=n>>8,e[1]=n,e};vs.bytes=2;const rs=n=>{if(n.length<2)throw RangeError("Could not decode int16BE");if(n instanceof Uint8Array){let e=0;return e+=n[0]<<8,e+=n[1],e}return n.getUint16(0)};rs.bytes=2;function Ry(n){return{xxHandshakeSuccesses:n.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:n.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:n.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:n.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:n.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}function Pu(n,e){!e.enabled||!Ir||(n?(e(`LOCAL_STATIC_PUBLIC_KEY ${q(n.publicKey,"hex")}`),e(`LOCAL_STATIC_PRIVATE_KEY ${q(n.privateKey,"hex")}`)):e("Missing local static keys."))}function Du(n,e){!e.enabled||!Ir||(n?(e(`LOCAL_PUBLIC_EPHEMERAL_KEY ${q(n.publicKey,"hex")}`),e(`LOCAL_PRIVATE_EPHEMERAL_KEY ${q(n.privateKey,"hex")}`)):e("Missing local ephemeral keys."))}function Ny(n,e){!e.enabled||!Ir||e(n?`REMOTE_STATIC_PUBLIC_KEY ${q(n.subarray(),"hex")}`:"Missing remote static public key.")}function Lu(n,e){!e.enabled||!Ir||e(n?`REMOTE_EPHEMERAL_PUBLIC_KEY ${q(n.subarray(),"hex")}`:"Missing remote ephemeral keys.")}function ku(n,e,t){!t.enabled||!Ir||(t(`CIPHER_STATE_1 ${n.n.getUint64()} ${n.k&&q(n.k,"hex")}`),t(`CIPHER_STATE_2 ${e.n.getUint64()} ${e.k&&q(e.k,"hex")}`))}class rr extends Error{code;constructor(e="Invalid crypto exchange"){super(e),this.code=rr.code}static code="ERR_INVALID_CRYPTO_EXCHANGE"}const Oy=0,My=4294967295,Fy="Cipherstate has reached maximum n, a new handshake must be performed";class Uy{n;bytes;view;constructor(e=Oy){this.n=e,this.bytes=j(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,e,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>My)throw new Error(Fy)}}const dn=j(0);class Wr{k;n;crypto;constructor(e,t=void 0,r=0){this.crypto=e,this.k=t,this.n=new Uy(r)}hasKey(){return!!this.k}encryptWithAd(e,t){if(!this.hasKey())return t;this.n.assertValue();const r=this.crypto.encrypt(t,this.n.getBytes(),e,this.k);return this.n.increment(),r}decryptWithAd(e,t,r){if(!this.hasKey())return t;this.n.assertValue();const s=this.crypto.decrypt(t,this.n.getBytes(),e,this.k,r);return this.n.increment(),s}}class By{cs;ck;h;crypto;constructor(e,t){this.crypto=e;const r=$(t,"utf-8");this.h=qy(e,r),this.ck=this.h,this.cs=new Wr(e)}mixKey(e){const[t,r]=this.crypto.hkdf(this.ck,e);this.ck=t,this.cs=new Wr(this.crypto,r)}mixHash(e){this.h=this.crypto.hash(new H(this.h,e))}encryptAndHash(e){const t=this.cs.encryptWithAd(this.h,e);return this.mixHash(t),t}decryptAndHash(e){const t=this.cs.decryptWithAd(this.h,e);return this.mixHash(e),t}split(){const[e,t]=this.crypto.hkdf(this.ck,dn);return[new Wr(this.crypto,e),new Wr(this.crypto,t)]}}class $y{ss;s;e;rs;re;initiator;crypto;constructor(e){const{crypto:t,protocolName:r,prologue:s,initiator:i,s:o,e:a,rs:c,re:u}=e;this.crypto=t,this.ss=new By(t,r),this.ss.mixHash(s),this.initiator=i,this.s=o,this.e=a,this.rs=c,this.re=u}writeE(){if(this.e)throw new Error("ephemeral keypair is already set");const e=this.crypto.generateKeypair();return this.ss.mixHash(e.publicKey),this.e=e,e.publicKey}writeS(){if(!this.s)throw new Error("static keypair is not set");return this.ss.encryptAndHash(this.s.publicKey)}writeEE(){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.re))}writeES(){if(this.initiator){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}else{if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}}writeSE(){if(this.initiator){if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}else{if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}}readE(e,t=0){if(this.re)throw new Error("remote ephemeral public key is already set");if(e.byteLength<t+32)throw new Error("message is not long enough");this.re=e.sublist(t,t+32),this.ss.mixHash(this.re)}readS(e,t=0){if(this.rs)throw new Error("remote static public key is already set");const r=32+(this.ss.cs.hasKey()?16:0);if(e.byteLength<t+r)throw new Error("message is not long enough");const s=e.sublist(t,t+r);return this.rs=this.ss.decryptAndHash(s),r}readEE(){this.writeEE()}readES(){this.writeES()}readSE(){this.writeSE()}}class Ru extends $y{writeMessageA(e){return new H(this.writeE(),this.ss.encryptAndHash(e))}writeMessageB(e){const t=this.writeE();this.writeEE();const r=this.writeS();return this.writeES(),new H(t,r,this.ss.encryptAndHash(e))}writeMessageC(e){const t=this.writeS();return this.writeSE(),new H(t,this.ss.encryptAndHash(e))}readMessageA(e){try{return this.readE(e),this.ss.decryptAndHash(e.sublist(32))}catch(t){throw new rr(`handshake stage 0 validation fail: ${t.message}`)}}readMessageB(e){try{this.readE(e),this.readEE();const t=this.readS(e,32);return this.readES(),this.ss.decryptAndHash(e.sublist(32+t))}catch(t){throw new rr(`handshake stage 1 validation fail: ${t.message}`)}}readMessageC(e){try{const t=this.readS(e);return this.readSE(),this.ss.decryptAndHash(e.sublist(t))}catch(t){throw new rr(`handshake stage 2 validation fail: ${t.message}`)}}}function qy(n,e){if(e.length<=32){const t=j(32);return t.set(e),t}else return n.hash(e)}var Ss;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.webtransportCerthashes!=null)for(const i of t.webtransportCerthashes)r.uint32(10),r.bytes(i);if(t.streamMuxers!=null)for(const i of t.streamMuxers)r.uint32(18),r.string(i);s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={webtransportCerthashes:[],streamMuxers:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{if(s.limits?.webtransportCerthashes!=null&&i.webtransportCerthashes.length===s.limits.webtransportCerthashes)throw new mt('Decode error - map field "webtransportCerthashes" had too many elements');i.webtransportCerthashes.push(t.bytes());break}case 2:{if(s.limits?.streamMuxers!=null&&i.streamMuxers.length===s.limits.streamMuxers)throw new mt('Decode error - map field "streamMuxers" had too many elements');i.streamMuxers.push(t.string());break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(Ss||(Ss={}));var xs;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.identityKey!=null&&t.identityKey.byteLength>0&&(r.uint32(10),r.bytes(t.identityKey)),t.identitySig!=null&&t.identitySig.byteLength>0&&(r.uint32(18),r.bytes(t.identitySig)),t.extensions!=null&&(r.uint32(34),Ss.codec().encode(t.extensions,r)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={identityKey:j(0),identitySig:j(0)},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.identityKey=t.bytes();break}case 2:{i.identitySig=t.bytes();break}case 4:{i.extensions=Ss.codec().decode(t,t.uint32(),{limits:s.limits?.extensions});break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(xs||(xs={}));async function Nu(n,e,t){const r=await n.sign(Mu(e));return xs.encode({identityKey:ft(n.publicKey),identitySig:r,extensions:t})}async function Ou(n,e,t){try{const r=xs.decode(n),s=Pt(r.identityKey);if(t?.equals(s)===!1)throw new Error(`Payload identity key ${s} does not match expected remote identity key ${t}`);if(!e)throw new Error("Remote static does not exist");const i=Mu(e);if(!await s.verify(i,r.identitySig))throw new Error("Invalid payload signature");return r}catch(r){throw new Dh(r.message)}}function Mu(n){const e=$("noise-libp2p-static-key:");return n instanceof Uint8Array?$t([e,n],e.length+n.length):(n.prepend(e),n)}async function zy(n,e){const{log:t,connection:r,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:u}=n,l=await Nu(i,a.publicKey,u),d=new Ru({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!0,prologue:o,s:a});Pu(d.s,t),t.trace("Stage 0 - Initiator starting to send first message."),await r.write(d.writeMessageA(dn),e),t.trace("Stage 0 - Initiator finished sending first message."),Du(d.e,t),t.trace("Stage 1 - Initiator waiting to receive first message from responder...");const h=d.readMessageB(await r.read(e));t.trace("Stage 1 - Initiator received the message."),Lu(d.re,t),Ny(d.rs,t),t.trace("Initiator going to check remote's signature...");const p=await Ou(h,d.rs,c);t.trace("All good with the signature!"),t.trace("Stage 2 - Initiator sending third handshake message."),await r.write(d.writeMessageC(l),e),t.trace("Stage 2 - Initiator sent message with signed payload.");const[g,m]=d.ss.split();return ku(g,m,t),{payload:p,encrypt:f=>g.encryptWithAd(dn,f),decrypt:(f,w)=>m.decryptWithAd(dn,f,w)}}async function Ky(n,e){const{log:t,connection:r,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:u}=n,l=await Nu(i,a.publicKey,u),d=new Ru({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!1,prologue:o,s:a});Pu(d.s,t),t.trace("Stage 0 - Responder waiting to receive first message."),d.readMessageA(await r.read(e)),t.trace("Stage 0 - Responder received first message."),Lu(d.re,t),t.trace("Stage 1 - Responder sending out first message with signed payload and static key."),await r.write(d.writeMessageB(l),e),t.trace("Stage 1 - Responder sent the second handshake message with signed payload."),Du(d.e,t),t.trace("Stage 2 - Responder waiting for third handshake message...");const h=d.readMessageC(await r.read(e));t.trace("Stage 2 - Responder received the message, finished handshake.");const p=await Ou(h,d.rs,c),[g,m]=d.ss.split();return ku(g,m,t),{payload:p,encrypt:f=>m.encryptWithAd(dn,f),decrypt:(f,w)=>g.decryptWithAd(dn,f,w)}}const ec=16;function Wy(n,e){return async function*(t){for await(const r of t)for(let s=0;s<r.length;s+=Va){let i=s+Va;i>r.length&&(i=r.length);let o;r instanceof Uint8Array?o=n.encrypt(r.subarray(s,i)):o=n.encrypt(r.sublist(s,i)),e?.encryptedPackets.increment(),yield new H(vs(o.byteLength),o)}}}function Vy(n,e){return async function*(t){for await(const r of t)for(let s=0;s<r.length;s+=ur){let i=s+ur;if(i>r.length&&(i=r.length),i-ec<s)throw new Error("Invalid chunk");const o=r.sublist(s,i),a=r.subarray(s,i-ec);try{const c=n.decrypt(o,a);e?.decryptedPackets.increment(),yield c}catch(c){throw e?.decryptErrors.increment(),c}}}}class Hy{protocol="/noise";crypto;prologue;staticKey;extensions;metrics;components;constructor(e,t={}){const{staticNoiseKey:r,extensions:s,crypto:i,prologueBytes:o}=t,{metrics:a}=e;this.components=e;const c=i??Ly;this.crypto=ky(c),this.extensions={webtransportCerthashes:[],...s},this.metrics=a?Ry(a):void 0,r?this.staticKey=c.generateX25519KeyPairFromSeed(r):this.staticKey=c.generateX25519KeyPair(),this.prologue=o??j(0)}[Symbol.toStringTag]="@chainsafe/libp2p-noise";[Ye]=["@libp2p/connection-encryption","@chainsafe/libp2p-noise"];async secureOutbound(e,t){const r=bn(e,{lengthEncoder:vs,lengthDecoder:rs,maxDataLength:ur}),s=await this.performHandshakeInitiator(r,this.components.privateKey,t?.remotePeer?.publicKey,t),i=await this.createSecureConnection(r,s);e.source=i.source,e.sink=i.sink;const o=Pt(s.payload.identityKey);return{conn:e,remoteExtensions:s.payload.extensions,remotePeer:lr(o),streamMuxer:t?.skipStreamMuxerNegotiation===!0?void 0:this.getStreamMuxer(s.payload.extensions?.streamMuxers)}}getStreamMuxer(e){if(e==null||e.length===0)return;const t=this.components.upgrader.getStreamMuxers();if(t!=null)for(const r of e){const s=t.get(r);if(s!=null)return s}if(e.length)throw new Lh("Early muxer negotiation was requested but the initiator and responder had no common muxers")}async secureInbound(e,t){const r=bn(e,{lengthEncoder:vs,lengthDecoder:rs,maxDataLength:ur}),s=await this.performHandshakeResponder(r,this.components.privateKey,t?.remotePeer?.publicKey,t),i=await this.createSecureConnection(r,s);e.source=i.source,e.sink=i.sink;const o=Pt(s.payload.identityKey);return{conn:e,remoteExtensions:s.payload.extensions,remotePeer:lr(o),streamMuxer:t?.skipStreamMuxerNegotiation===!0?void 0:this.getStreamMuxer(s.payload.extensions?.streamMuxers)}}async performHandshakeInitiator(e,t,r,s){let i;const o=s?.skipStreamMuxerNegotiation===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{i=await zy({connection:e,privateKey:t,remoteIdentityKey:r,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:o,webtransportCerthashes:[],...this.extensions}},s),this.metrics?.xxHandshakeSuccesses.increment()}catch(a){throw this.metrics?.xxHandshakeErrors.increment(),a}return i}async performHandshakeResponder(e,t,r,s){let i;const o=s?.skipStreamMuxerNegotiation===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{i=await Ky({connection:e,privateKey:t,remoteIdentityKey:r,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:o,webtransportCerthashes:[],...this.extensions}},s),this.metrics?.xxHandshakeSuccesses.increment()}catch(a){throw this.metrics?.xxHandshakeErrors.increment(),a}return i}async createSecureConnection(e,t){const[r,s]=Gm(),i=e.unwrap();return await xu(r,Wy(t,this.metrics),i,o=>bs(o,{lengthDecoder:rs}),Vy(t,this.metrics),r),s}}function Gy(n={}){return e=>new Hy(e,n)}function Fu(n){if(n!=null){if(typeof n[Symbol.iterator]=="function")return n[Symbol.iterator]();if(typeof n[Symbol.asyncIterator]=="function")return n[Symbol.asyncIterator]();if(typeof n.next=="function")return n}throw new Error("argument is not an iterator or iterable")}class sn extends Error{static name="InvalidFrameError";constructor(e="The frame was invalid"){super(e),this.name="InvalidFrameError"}}class Uu extends Error{static name="UnrequestedPingError";constructor(e="Unrequested ping error"){super(e),this.name="UnrequestedPingError"}}class Bu extends Error{static name="NotMatchingPingError";constructor(e="Unrequested ping error"){super(e),this.name="NotMatchingPingError"}}class Qy extends Error{static name="InvalidStateError";constructor(e="Invalid state"){super(e),this.name="InvalidStateError"}}class Yy extends Error{static name="StreamAlreadyExistsError";constructor(e="Strean already exists"){super(e),this.name="StreamAlreadyExistsError"}}class Xy extends Error{static name="DecodeInvalidVersionError";constructor(e="Decode invalid version"){super(e),this.name="DecodeInvalidVersionError"}}class Zy extends Error{static name="BothClientsError";constructor(e="Both clients"){super(e),this.name="BothClientsError"}}class $u extends Error{static name="ReceiveWindowExceededError";constructor(e="Receive window exceeded"){super(e),this.name="ReceiveWindowExceededError"}}const jy=new Set([sn.name,Uu.name,Bu.name,Yy.name,Xy.name,Zy.name,$u.name]),Yo=256*1024,Jy=16*1024*1024,ew={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3,initialStreamWindowSize:Yo,maxStreamWindowSize:Jy,maxMessageSize:64*1024};function tw(n){if(n.keepAliveInterval<=0)throw new K("keep-alive interval must be positive");if(n.maxInboundStreams<0)throw new K("max inbound streams must be larger or equal 0");if(n.maxOutboundStreams<0)throw new K("max outbound streams must be larger or equal 0");if(n.initialStreamWindowSize<Yo)throw new K("InitialStreamWindowSize must be larger or equal 256 kB");if(n.maxStreamWindowSize<n.initialStreamWindowSize)throw new K("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");if(n.maxStreamWindowSize>2**32-1)throw new K("MaxStreamWindowSize must be less than equal MAX_UINT32");if(n.maxMessageSize<1024)throw new K("MaxMessageSize must be greater than a kilobyte")}var pe;(function(n){n[n.Data=0]="Data",n[n.WindowUpdate=1]="WindowUpdate",n[n.Ping=2]="Ping",n[n.GoAway=3]="GoAway"})(pe||(pe={}));var ue;(function(n){n[n.SYN=1]="SYN",n[n.ACK=2]="ACK",n[n.FIN=4]="FIN",n[n.RST=8]="RST"})(ue||(ue={}));Object.values(ue).filter(n=>typeof n!="string");const nw=0;var je;(function(n){n[n.NormalTermination=0]="NormalTermination",n[n.ProtocolError=1]="ProtocolError",n[n.InternalError=2]="InternalError"})(je||(je={}));const sr=12,tc=2**24;function rw(n){if(n[0]!==nw)throw new sn("Invalid frame version");return{type:n[1],flag:(n[2]<<8)+n[3],streamID:n[4]*tc+(n[5]<<16)+(n[6]<<8)+n[7],length:n[8]*tc+(n[9]<<16)+(n[10]<<8)+n[11]}}class sw{source;buffer;frameInProgress;constructor(e){this.source=iw(e),this.buffer=new H,this.frameInProgress=!1}async*emitFrames(){for await(const e of this.source)for(this.buffer.append(e);;){const t=this.readHeader();if(t===void 0)break;const{type:r,length:s}=t;r===pe.Data?(this.frameInProgress=!0,yield{header:t,readData:this.readBytes.bind(this,s)}):yield{header:t}}}readHeader(){if(this.frameInProgress)throw new Qy("decoding frame already in progress");if(this.buffer.length<sr)return;const e=rw(this.buffer.subarray(0,sr));return this.buffer.consume(sr),e}async readBytes(e){if(this.buffer.length<e){for await(const r of this.source)if(this.buffer.append(r),this.buffer.length>=e)break}const t=this.buffer.sublist(0,e);return this.buffer.consume(e),this.frameInProgress=!1,t}}function iw(n){if(n[Symbol.iterator]!==void 0){const e=n[Symbol.iterator]();return e.return=void 0,{[Symbol.iterator](){return e}}}else if(n[Symbol.asyncIterator]!==void 0){const e=n[Symbol.asyncIterator]();return e.return=void 0,{[Symbol.asyncIterator](){return e}}}else throw new Error("a source must be either an iterable or an async iterable")}function nc(n){const e=new Uint8Array(sr);return e[1]=n.type,e[2]=n.flag>>>8,e[3]=n.flag,e[4]=n.streamID>>>24,e[5]=n.streamID>>>16,e[6]=n.streamID>>>8,e[7]=n.streamID,e[8]=n.length>>>24,e[9]=n.length>>>16,e[10]=n.length>>>8,e[11]=n.length,e}function ow(n){return n==null?!1:typeof n.then=="function"&&typeof n.catch=="function"&&typeof n.finally=="function"}function aw(n,e){const t=Fu(n).return?.();ow(t)&&t.catch(r=>{e.error("could not cause iterator to return",r)})}const cw=5e3;function Ei(n){return n==null?!1:typeof n.then=="function"&&typeof n.catch=="function"&&typeof n.finally=="function"}class qu{id;direction;timeline;protocol;metadata;source;status;readStatus;writeStatus;log;sinkController;sinkEnd;closed;endErr;streamSource;onEnd;onCloseRead;onCloseWrite;onReset;onAbort;sendCloseWriteTimeout;sendingData;constructor(e){this.sinkController=new AbortController,this.sinkEnd=z(),this.closed=z(),this.log=e.log,this.status="open",this.readStatus="ready",this.writeStatus="ready",this.id=e.id,this.metadata=e.metadata??{},this.direction=e.direction,this.timeline={open:Date.now()},this.sendCloseWriteTimeout=e.sendCloseWriteTimeout??cw,this.onEnd=e.onEnd,this.onCloseRead=e.onCloseRead,this.onCloseWrite=e.onCloseWrite,this.onReset=e.onReset,this.onAbort=e.onAbort,this.source=this.streamSource=On({onEnd:t=>{t!=null?this.log.trace("source ended with error",t):this.log.trace("source ended"),this.onSourceEnd(t)}}),this.sink=this.sink.bind(this)}async sink(e){if(this.writeStatus!=="ready")throw new Wi(`writable end state is "${this.writeStatus}" not "ready"`);try{this.writeStatus="writing";const t={signal:this.sinkController.signal};if(this.direction==="outbound"){const s=this.sendNewStream(t);Ei(s)&&await s}const r=()=>{aw(e,this.log)};try{this.sinkController.signal.addEventListener("abort",r),this.log.trace("sink reading from source");for await(let s of e){s=s instanceof Uint8Array?new H(s):s;const i=this.sendData(s,t);Ei(i)&&(this.sendingData=z(),await i,this.sendingData.resolve(),this.sendingData=void 0)}}finally{this.sinkController.signal.removeEventListener("abort",r)}this.log.trace('sink finished reading from source, write status is "%s"',this.writeStatus),this.writeStatus==="writing"&&(this.writeStatus="closing",this.log.trace("send close write to remote"),await this.sendCloseWrite({signal:AbortSignal.timeout(this.sendCloseWriteTimeout)}),this.writeStatus="closed"),this.onSinkEnd()}catch(t){throw this.log.trace("sink ended with error, calling abort with error",t),this.abort(t),t}finally{this.log.trace("resolve sink end"),this.sinkEnd.resolve()}}onSourceEnd(e){this.timeline.closeRead==null&&(this.timeline.closeRead=Date.now(),this.readStatus="closed",e!=null&&this.endErr==null&&(this.endErr=e),this.onCloseRead?.(),this.timeline.closeWrite!=null?(this.log.trace("source and sink ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("source ended, waiting for sink to end"))}onSinkEnd(e){this.timeline.closeWrite==null&&(this.timeline.closeWrite=Date.now(),this.writeStatus="closed",e!=null&&this.endErr==null&&(this.endErr=e),this.onCloseWrite?.(),this.timeline.closeRead!=null?(this.log.trace("sink and source ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("sink ended, waiting for source to end"))}async close(e){this.status==="open"&&(this.log.trace("closing gracefully"),this.status="closing",await ie(Promise.all([this.closeWrite(e),this.closeRead(e),this.closed.promise]),e?.signal),this.status="closed",this.log.trace("closed gracefully"))}async closeRead(e={}){if(this.readStatus==="closing"||this.readStatus==="closed")return;this.log.trace('closing readable end of stream with starting read status "%s"',this.readStatus);const t=this.readStatus;this.readStatus="closing",this.status!=="reset"&&this.status!=="aborted"&&this.timeline.closeRead==null&&(this.log.trace("send close read to remote"),await this.sendCloseRead(e)),t==="ready"&&(this.log.trace("ending internal source queue with %d queued bytes",this.streamSource.readableLength),this.streamSource.end()),this.log.trace("closed readable end of stream")}async closeWrite(e={}){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.log.trace('closing writable end of stream with starting write status "%s"',this.writeStatus),this.writeStatus==="ready"&&(this.log.trace("sink was never sunk, sink an empty array"),await ie(this.sink([]),e.signal)),this.writeStatus==="writing"&&(this.sendingData!=null&&await ie(this.sendingData.promise,e.signal),this.log.trace("aborting source passed to .sink"),this.sinkController.abort(),await ie(this.sinkEnd.promise,e.signal)),this.writeStatus="closed",this.log.trace("closed writable end of stream"))}abort(e){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;this.log("abort with error",e),this.log("try to send reset to remote");const t=this.sendReset();Ei(t)&&t.catch(r=>{this.log.error("error sending reset message",r)}),this.status="aborted",this.timeline.abort=Date.now(),this._closeSinkAndSource(e),this.onAbort?.(e)}reset(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;const e=new Rh("stream reset");this.status="reset",this.timeline.reset=Date.now(),this._closeSinkAndSource(e),this.onReset?.()}_closeSinkAndSource(e){this._closeSink(e),this._closeSource(e)}_closeSink(e){this.writeStatus==="writing"&&(this.log.trace("end sink source"),this.sinkController.abort()),this.onSinkEnd(e)}_closeSource(e){this.readStatus!=="closing"&&this.readStatus!=="closed"&&(this.log.trace("ending source with %d bytes to be read by consumer",this.streamSource.readableLength),this.readStatus="closing",this.streamSource.end(e))}remoteCloseWrite(){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("received remote close write but local source is already closed");return}this.log.trace("remote close write"),this._closeSource()}remoteCloseRead(){if(this.writeStatus==="closing"||this.writeStatus==="closed"){this.log("received remote close read but local sink is already closed");return}this.log.trace("remote close read"),this._closeSink()}destroy(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset"){this.log("received destroy but we are already closed");return}this.log.trace("stream destroyed"),this._closeSinkAndSource()}sourcePush(e){this.streamSource.push(e)}sourceReadableLength(){return this.streamSource.readableLength}}function zu(n){const[e,t]=n[Symbol.asyncIterator]!=null?[n[Symbol.asyncIterator](),Symbol.asyncIterator]:[n[Symbol.iterator](),Symbol.iterator],r=[];return{peek:()=>e.next(),push:s=>{r.push(s)},next:()=>r.length>0?{done:!1,value:r.shift()}:e.next(),[t](){return this}}}function lw(n){return n[Symbol.asyncIterator]!=null}function rc(n){return n?.then!=null}function Ku(n,e){let t=0;if(lw(n))return async function*(){for await(const c of n){const u=e(c,t++);rc(u)&&await u,yield c}}();const r=zu(n),{value:s,done:i}=r.next();if(i===!0)return function*(){}();if(typeof e(s,t++)?.then=="function")return async function*(){yield s;for(const c of r){const u=e(c,t++);rc(u)&&await u,yield c}}();const a=e;return function*(){yield s;for(const c of r)a(c,t++),yield c}()}var Ge;(function(n){n[n.Init=0]="Init",n[n.SYNSent=1]="SYNSent",n[n.SYNReceived=2]="SYNReceived",n[n.Established=3]="Established",n[n.Finished=4]="Finished"})(Ge||(Ge={}));class uw extends qu{name;state;config;_id;sendWindowCapacity;sendWindowCapacityUpdate;recvWindow;recvWindowCapacity;epochStart;getRTT;sendFrame;constructor(e){super({...e,onEnd:t=>{this.state=Ge.Finished,e.onEnd?.(t)}}),this.config=e.config,this._id=parseInt(e.id,10),this.name=e.name,this.state=e.state,this.sendWindowCapacity=Yo,this.recvWindow=this.config.initialStreamWindowSize,this.recvWindowCapacity=this.recvWindow,this.epochStart=Date.now(),this.getRTT=e.getRTT,this.sendFrame=e.sendFrame,this.source=Ku(this.source,()=>{this.sendWindowUpdate()})}async sendNewStream(){}async sendData(e,t={}){for(e=e.sublist();e.byteLength!==0;){if(this.sendWindowCapacity===0&&(this.log?.trace("wait for send window capacity, status %s",this.status),await this.waitForSendWindowCapacity(t),this.status==="closed"||this.status==="aborted"||this.status==="reset")){this.log?.trace("%s while waiting for send window capacity",this.status);return}const r=Math.min(this.sendWindowCapacity,this.config.maxMessageSize-sr,e.length),s=this.getSendFlags();this.sendFrame({type:pe.Data,flag:s,streamID:this._id,length:r},e.sublist(0,r)),this.sendWindowCapacity-=r,e.consume(r)}}async sendReset(){this.sendFrame({type:pe.WindowUpdate,flag:ue.RST,streamID:this._id,length:0})}async sendCloseWrite(){const e=this.getSendFlags()|ue.FIN;this.sendFrame({type:pe.WindowUpdate,flag:e,streamID:this._id,length:0})}async sendCloseRead(){}async waitForSendWindowCapacity(e={}){if(this.sendWindowCapacity>0)return;let t,r;const s=()=>{this.status==="open"||this.status==="closing"?r(new Bt("Stream aborted")):t()};e.signal?.addEventListener("abort",s);try{await new Promise((i,o)=>{this.sendWindowCapacityUpdate=()=>{i()},r=o,t=i})}finally{e.signal?.removeEventListener("abort",s)}}handleWindowUpdate(e){this.log?.trace("stream received window update id=%s",this._id),this.processFlags(e.flag);const t=this.sendWindowCapacity;this.sendWindowCapacity+=e.length,t===0&&e.length>0&&this.sendWindowCapacityUpdate?.()}async handleData(e,t){if(this.log?.trace("stream received data id=%s",this._id),this.processFlags(e.flag),this.recvWindowCapacity<e.length)throw new $u("Receive window exceeded");const r=await t();this.recvWindowCapacity-=e.length,this.sourcePush(r)}processFlags(e){(e&ue.ACK)===ue.ACK&&this.state===Ge.SYNSent&&(this.state=Ge.Established),(e&ue.FIN)===ue.FIN&&this.remoteCloseWrite(),(e&ue.RST)===ue.RST&&this.reset()}getSendFlags(){switch(this.state){case Ge.Init:return this.state=Ge.SYNSent,ue.SYN;case Ge.SYNReceived:return this.state=Ge.Established,ue.ACK;default:return 0}}sendWindowUpdate(){const e=this.getSendFlags(),t=Date.now(),r=this.getRTT();if(e===0&&r>-1&&t-this.epochStart<r*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.config.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&e===0)return;const s=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=t,this.sendFrame({type:pe.WindowUpdate,flag:e,streamID:this._id,length:s})}}const Wu="/yamux/1.0.0",dw=500;class hw{protocol=Wu;_components;_init;constructor(e,t={}){this._components=e,this._init=t}[Symbol.toStringTag]="@chainsafe/libp2p-yamux";[Ye]=["@libp2p/stream-multiplexing"];createStreamMuxer(e){return new fw(this._components,{...this._init,...e})}}class fw{protocol=Wu;source;sink;config;log;logger;closeController;nextStreamID;_streams;nextPingID;activePing;rtt;client;localGoAway;remoteGoAway;numInboundStreams;numOutboundStreams;onIncomingStream;onStreamEnd;constructor(e,t){this.client=t.direction==="outbound",this.config={...ew,...t},this.logger=e.logger,this.log=this.logger.forComponent("libp2p:yamux"),tw(this.config),this.closeController=new AbortController,this.closeController.signal,this.onIncomingStream=t.onIncomingStream,this.onStreamEnd=t.onStreamEnd,this._streams=new Map,this.source=On({onEnd:()=>{this.log?.trace("muxer source ended"),this._streams.forEach(r=>{r.destroy()})}}),this.sink=async r=>{const s=()=>{const a=Fu(r);if(a.return!=null){const c=a.return();pw(c)&&c.catch(u=>{this.log?.("could not cause sink source to return",u)})}};let i,o;try{const a=new sw(r);try{this.closeController.signal.addEventListener("abort",s);for await(const c of a.emitFrames())await this.handleFrame(c.header,c.readData)}finally{this.closeController.signal.removeEventListener("abort",s)}i=je.NormalTermination}catch(a){jy.has(a.name)?(this.log?.error("protocol error in sink",a),i=je.ProtocolError):(this.log?.error("internal error in sink",a),i=je.InternalError),o=a}this.log?.trace("muxer sink ended"),o!=null?this.abort(o,i):await this.close({reason:i})},this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,this.log?.trace("muxer created"),this.config.enableKeepAlive&&this.keepAliveLoop().catch(r=>this.log?.error("keepalive error: %s",r)),this.ping().catch(r=>this.log?.error("ping error: %s",r))}get streams(){return Array.from(this._streams.values())}newStream(e){if(this.remoteGoAway!==void 0)throw new Bn("Muxer closed remotely");if(this.localGoAway!==void 0)throw new Bn("Muxer closed locally");const t=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.config.maxOutboundStreams)throw new El("max outbound streams exceeded");this.log?.trace("new outgoing stream id=%s",t);const r=this._newStream(t,e,Ge.Init,"outbound");return this._streams.set(t,r),this.numOutboundStreams++,r.sendWindowUpdate(),r}async ping(){if(this.remoteGoAway!==void 0)throw new Bn("Muxer closed remotely");if(this.localGoAway!==void 0)throw new Bn("Muxer closed locally");if(this.activePing===void 0){let e=()=>{};this.activePing={id:this.nextPingID++,promise:new Promise((s,i)=>{const o=()=>{i(new Bn("Muxer closed locally"))};this.closeController.signal.addEventListener("abort",o,{once:!0}),e=()=>{this.closeController.signal.removeEventListener("abort",o),s()}}),resolve:e};const t=Date.now();this.sendPing(this.activePing.id);try{await this.activePing.promise}finally{delete this.activePing}const r=Date.now();this.rtt=r-t}else await this.activePing.promise;return this.rtt}getRTT(){return this.rtt}async close(e={}){if(this.closeController.signal.aborted)return;const t=e?.reason??je.NormalTermination;if(this.log?.trace("muxer close reason=%s",t),e.signal==null){const r=AbortSignal.timeout(dw);e={...e,signal:r}}try{await Promise.all([...this._streams.values()].map(async r=>r.close(e))),this.sendGoAway(t),this._closeMuxer()}catch(r){this.abort(r)}}abort(e,t){if(!this.closeController.signal.aborted){t=t??je.InternalError,this.log?.error("muxer abort reason=%s error=%s",t,e);for(const r of this._streams.values())r.abort(e);this.sendGoAway(t),this._closeMuxer()}}isClosed(){return this.closeController.signal.aborted}_closeMuxer(){this.closeController.abort(),this.source.end()}_newStream(e,t,r,s){if(this._streams.get(e)!=null)throw new K("Stream already exists with that id");const i=new uw({id:e.toString(),name:t,state:r,direction:s,sendFrame:this.sendFrame.bind(this),onEnd:()=>{this.closeStream(e),this.onStreamEnd?.(i)},log:this.logger.forComponent(`libp2p:yamux:${s}:${e}`),config:this.config,getRTT:this.getRTT.bind(this)});return i}closeStream(e){this.client===(e%2===0)?this.numInboundStreams--:this.numOutboundStreams--,this._streams.delete(e)}async keepAliveLoop(){for(this.log?.trace("muxer keepalive enabled interval=%s",this.config.keepAliveInterval);;){let e;try{await ie(new Promise(t=>{e=setTimeout(t,this.config.keepAliveInterval)}),this.closeController.signal),this.ping().catch(t=>this.log?.error("ping error: %s",t))}catch{clearInterval(e);return}}}async handleFrame(e,t){const{streamID:r,type:s,length:i}=e;if(this.log?.trace("received frame %o",e),r===0)switch(s){case pe.Ping:{this.handlePing(e);return}case pe.GoAway:{this.handleGoAway(i);return}default:throw new sn("Invalid frame type")}else switch(e.type){case pe.Data:case pe.WindowUpdate:{await this.handleStreamMessage(e,t);return}default:throw new sn("Invalid frame type")}}handlePing(e){if(e.flag===ue.SYN)this.log?.trace("received ping request pingId=%s",e.length),this.sendPing(e.length,ue.ACK);else if(e.flag===ue.ACK)this.log?.trace("received ping response pingId=%s",e.length),this.handlePingResponse(e.length);else throw new sn("Invalid frame flag")}handlePingResponse(e){if(this.activePing===void 0)throw new Uu("ping not requested");if(this.activePing.id!==e)throw new Bu("ping doesn't match our id");this.activePing.resolve()}handleGoAway(e){this.log?.trace("received GoAway reason=%s",je[e]??"unknown"),this.remoteGoAway=e;for(const t of this._streams.values())t.reset();this._closeMuxer()}async handleStreamMessage(e,t){const{streamID:r,flag:s,type:i}=e;(s&ue.SYN)===ue.SYN&&this.incomingStream(r);const o=this._streams.get(r);if(o===void 0){if(i===pe.Data){if(this.log?.("discarding data for stream id=%s",r),t===void 0)throw new Error("unreachable");await t()}else this.log?.trace("frame for missing stream id=%s",r);return}switch(i){case pe.WindowUpdate:{o.handleWindowUpdate(e);return}case pe.Data:{if(t===void 0)throw new Error("unreachable");await o.handleData(e,t);return}default:throw new Error("unreachable")}}incomingStream(e){if(this.client!==(e%2===0))throw new K("Both endpoints are clients");if(this._streams.has(e))return;if(this.log?.trace("new incoming stream id=%s",e),this.localGoAway!==void 0){this.sendFrame({type:pe.WindowUpdate,flag:ue.RST,streamID:e,length:0});return}if(this.numInboundStreams>=this.config.maxInboundStreams){this.log?.("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:pe.WindowUpdate,flag:ue.RST,streamID:e,length:0});return}const t=this._newStream(e,void 0,Ge.SYNReceived,"inbound");this.numInboundStreams++,this._streams.set(e,t),this.onIncomingStream?.(t)}sendFrame(e,t){if(this.log?.trace("sending frame %o",e),e.type===pe.Data){if(t===void 0)throw new sn("Invalid frame");this.source.push(new H(nc(e),t))}else this.source.push(nc(e))}sendPing(e,t=ue.SYN){t===ue.SYN?this.log?.trace("sending ping request pingId=%s",e):this.log?.trace("sending ping response pingId=%s",e),this.sendFrame({type:pe.Ping,flag:t,streamID:0,length:e})}sendGoAway(e=je.NormalTermination){this.log?.("sending GoAway reason=%s",je[e]),this.localGoAway=e,this.sendFrame({type:pe.GoAway,flag:0,streamID:0,length:e})}}function pw(n){return n!=null&&typeof n.then=="function"}function gw(n={}){return e=>new hw(e,n)}var As;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(r.uint32(10),r.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(r.uint32(18),r.bytes(t.payloadType)),t.payload!=null&&t.payload.byteLength>0&&(r.uint32(26),r.bytes(t.payload)),t.signature!=null&&t.signature.byteLength>0&&(r.uint32(42),r.bytes(t.signature)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={publicKey:j(0),payloadType:j(0),payload:j(0),signature:j(0)},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.publicKey=t.bytes();break}case 2:{i.payloadType=t.bytes();break}case 3:{i.payload=t.bytes();break}case 5:{i.signature=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(As||(As={}));class mw extends Error{constructor(e="Invalid signature"){super(e),this.name="InvalidSignatureError"}}class et{static createFromProtobuf=e=>{const t=As.decode(e),r=Pt(t.publicKey);return new et({publicKey:r,payloadType:t.payloadType,payload:t.payload,signature:t.signature})};static seal=async(e,t,r)=>{if(t==null)throw new Error("Missing private key");const s=e.domain,i=e.codec,o=e.marshal(),a=sc(s,i,o),c=await t.sign(a.subarray(),r);return new et({publicKey:t.publicKey,payloadType:i,payload:o,signature:c})};static openAndCertify=async(e,t,r)=>{const s=et.createFromProtobuf(e);if(!await s.validate(t,r))throw new mw("Envelope signature is not valid for the given domain");return s};publicKey;payloadType;payload;signature;marshaled;constructor(e){const{publicKey:t,payloadType:r,payload:s,signature:i}=e;this.publicKey=t,this.payloadType=r,this.payload=s,this.signature=i}marshal(){return this.marshaled==null&&(this.marshaled=As.encode({publicKey:ft(this.publicKey),payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(e){return e==null?!1:Te(this.marshal(),e.marshal())}async validate(e,t){const r=sc(e,this.payloadType,this.payload);return this.publicKey.verify(r.subarray(),this.signature,t)}}const sc=(n,e,t)=>{const r=$(n),s=un(r.byteLength),i=un(e.length),o=un(t.length);return new H(s,r,i,e,o,t)};function yw(n,e){const t=(r,s)=>r.toString().localeCompare(s.toString());return n.length!==e.length?!1:(e.sort(t),n.sort(t).every((r,s)=>e[s].equals(r)))}class ze extends Error{static name="InvalidMultiaddrError";name="InvalidMultiaddrError"}class dr extends Error{static name="ValidationError";name="ValidationError"}class ww extends Error{static name="InvalidParametersError";name="InvalidParametersError"}class bw extends Error{static name="UnknownProtocolError";name="UnknownProtocolError"}class Ew{index=0;input="";new(e){return this.index=0,this.input=e,this}readAtomically(e){const t=this.index,r=e();return r===void 0&&(this.index=t),r}parseWith(e){const t=e();if(this.index===this.input.length)return t}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(e){return this.readAtomically(()=>{const t=this.readChar();if(t===e)return t})}readSeparator(e,t,r){return this.readAtomically(()=>{if(!(t>0&&this.readGivenChar(e)===void 0))return r()})}readNumber(e,t,r,s){return this.readAtomically(()=>{let i=0,o=0;const a=this.peekChar();if(a===void 0)return;const c=a==="0",u=2**(8*s)-1;for(;;){const l=this.readAtomically(()=>{const d=this.readChar();if(d===void 0)return;const h=Number.parseInt(d,e);if(!Number.isNaN(h))return h});if(l===void 0)break;if(i*=e,i+=l,i>u||(o+=1,t!==void 0&&o>t))return}if(o!==0)return!r&&c&&o>1?void 0:i})}readIPv4Addr(){return this.readAtomically(()=>{const e=new Uint8Array(4);for(let t=0;t<e.length;t++){const r=this.readSeparator(".",t,()=>this.readNumber(10,3,!1,1));if(r===void 0)return;e[t]=r}return e})}readIPv6Addr(){const e=t=>{for(let r=0;r<t.length/2;r++){const s=r*2;if(r<t.length-3){const o=this.readSeparator(":",r,()=>this.readIPv4Addr());if(o!==void 0)return t[s]=o[0],t[s+1]=o[1],t[s+2]=o[2],t[s+3]=o[3],[s+4,!0]}const i=this.readSeparator(":",r,()=>this.readNumber(16,4,!0,2));if(i===void 0)return[s,!1];t[s]=i>>8,t[s+1]=i&255}return[t.length,!1]};return this.readAtomically(()=>{const t=new Uint8Array(16),[r,s]=e(t);if(r===16)return t;if(s||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;const i=new Uint8Array(14),o=16-(r+2),[a]=e(i.subarray(0,o));return t.set(i.subarray(0,a),16-a),t})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}}const Vu=45,vw=15,vn=new Ew;function Hu(n){if(!(n.length>vw))return vn.new(n).parseWith(()=>vn.readIPv4Addr())}function Gu(n){if(n.includes("%")&&(n=n.split("%")[0]),!(n.length>Vu))return vn.new(n).parseWith(()=>vn.readIPv6Addr())}function lo(n,e=!1){if(n.includes("%")&&(n=n.split("%")[0]),n.length>Vu)return;const t=vn.new(n).parseWith(()=>vn.readIPAddr());if(t)return e&&t.length===4?Uint8Array.from([0,0,0,0,0,0,0,0,0,0,255,255,t[0],t[1],t[2],t[3]]):t}function Sn(n){return!!Hu(n)}function Qu(n){return!!Gu(n)}const Vt=4,pt=6,_s=273,Sw=33,Ke=41,Qt=42,Xo=43,Tr=53,Pr=54,Mn=55,Dr=56,xw=132,Aw=301,_w=302,Yu=400,J=421,Cw=444,Iw=445,Tw=446,Pw=447,hn=448,Xu=449,Dw=454,Zu=460,ju=461,Ju=465,hr=466,fn=480,Lw=481,uo=443,Zo=477,ed=478,kw=479,Rw=277,Nw=275,Ow=276,td=280,ss=281,Yt=290,nd=777;function ic(n){return e=>q(e,n)}function oc(n){return e=>$(e,n)}function Qn(n){return new DataView(n.buffer).getUint16(n.byteOffset).toString()}function on(n){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof n=="string"?parseInt(n):n),new Uint8Array(e)}function Mw(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=$(e[0],"base32"),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const s=on(r);return $t([t,s],t.length+s.length)}function Fw(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=It.decode(`b${e[0]}`),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const s=on(r);return $t([t,s],t.length+s.length)}function ac(n){const e=n.subarray(0,n.length-2),t=n.subarray(n.length-2),r=q(e,"base32"),s=Qn(t);return`${r}:${s}`}const rd=function(n){n=n.toString().trim();const e=new Uint8Array(4);return n.split(/\./g).forEach((t,r)=>{const s=parseInt(t,10);if(isNaN(s)||s<0||s>255)throw new ze("Invalid byte value in IP address");e[r]=s}),e},Uw=function(n){let e=0;n=n.toString().trim();const t=n.split(":",8);let r;for(r=0;r<t.length;r++){const i=Sn(t[r]);let o;i&&(o=rd(t[r]),t[r]=q(o.subarray(0,2),"base16")),o!=null&&++r<8&&t.splice(r,0,q(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(r=0;r<t.length&&t[r]!=="";r++);const i=[r,1];for(r=9-t.length;r>0;r--)i.push("0");t.splice.apply(t,i)}const s=new Uint8Array(e+16);for(r=0;r<t.length;r++){t[r]===""&&(t[r]="0");const i=parseInt(t[r],16);if(isNaN(i)||i<0||i>65535)throw new ze("Invalid byte value in IP address");s[e++]=i>>8&255,s[e++]=i&255}return s},Bw=function(n){if(n.byteLength!==4)throw new ze("IPv4 address was incorrect length");const e=[];for(let t=0;t<n.byteLength;t++)e.push(n[t]);return e.join(".")},$w=function(n){if(n.byteLength!==16)throw new ze("IPv6 address was incorrect length");const e=[];for(let r=0;r<n.byteLength;r+=2){const s=n[r],i=n[r+1],o=`${s.toString(16).padStart(2,"0")}${i.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const r=new URL(`http://[${t}]`);return r.hostname.substring(1,r.hostname.length-1)}catch{throw new ze(`Invalid IPv6 address "${t}"`)}};function qw(n){try{const e=new URL(`http://[${n}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new ze(`Invalid IPv6 address "${n}"`)}}const vi=Object.values(Xi).map(n=>n.decoder),zw=function(){let n=vi[0].or(vi[1]);return vi.slice(2).forEach(e=>n=n.or(e)),n}();function Kw(n){return zw.decode(n)}function Ww(n){return e=>n.encoder.encode(e)}function Vw(n){if(parseInt(n).toString()!==n)throw new dr("Value must be an integer")}function Hw(n){if(n<0)throw new dr("Value must be a positive integer, or zero")}function Gw(n){return e=>{if(e>n)throw new dr(`Value must be smaller than or equal to ${n}`)}}function Qw(...n){return e=>{for(const t of n)t(e)}}const Vr=Qw(Vw,Hw,Gw(65535)),xe=-1;class Yw{protocolsByCode=new Map;protocolsByName=new Map;getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new bw(`Protocol ${e} was unknown`);return t}addProtocol(e){this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),e.aliases?.forEach(t=>{this.protocolsByName.set(t,e)})}removeProtocol(e){const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),t.aliases?.forEach(r=>{this.protocolsByName.delete(r)}))}}const tt=new Yw,Xw=[{code:Vt,name:"ip4",size:32,valueToBytes:rd,bytesToValue:Bw,validate:n=>{if(!Sn(n))throw new dr(`Invalid IPv4 address "${n}"`)}},{code:pt,name:"tcp",size:16,valueToBytes:on,bytesToValue:Qn,validate:Vr},{code:_s,name:"udp",size:16,valueToBytes:on,bytesToValue:Qn,validate:Vr},{code:Sw,name:"dccp",size:16,valueToBytes:on,bytesToValue:Qn,validate:Vr},{code:Ke,name:"ip6",size:128,valueToBytes:Uw,bytesToValue:$w,stringToValue:qw,validate:n=>{if(!Qu(n))throw new dr(`Invalid IPv6 address "${n}"`)}},{code:Qt,name:"ip6zone",size:xe},{code:Xo,name:"ipcidr",size:8,bytesToValue:ic("base10"),valueToBytes:oc("base10")},{code:Tr,name:"dns",size:xe,resolvable:!0},{code:Pr,name:"dns4",size:xe,resolvable:!0},{code:Mn,name:"dns6",size:xe,resolvable:!0},{code:Dr,name:"dnsaddr",size:xe,resolvable:!0},{code:xw,name:"sctp",size:16,valueToBytes:on,bytesToValue:Qn,validate:Vr},{code:Aw,name:"udt"},{code:_w,name:"utp"},{code:Yu,name:"unix",size:xe,path:!0,stringToValue:n=>decodeURIComponent(n),valueToString:n=>encodeURIComponent(n)},{code:J,name:"p2p",aliases:["ipfs"],size:xe,bytesToValue:ic("base58btc"),valueToBytes:n=>n.startsWith("Q")||n.startsWith("1")?oc("base58btc")(n):re.parse(n).multihash.bytes},{code:Cw,name:"onion",size:96,bytesToValue:ac,valueToBytes:Mw},{code:Iw,name:"onion3",size:296,bytesToValue:ac,valueToBytes:Fw},{code:Tw,name:"garlic64",size:xe},{code:Pw,name:"garlic32",size:xe},{code:hn,name:"tls"},{code:Xu,name:"sni",size:xe},{code:Dw,name:"noise"},{code:Zu,name:"quic"},{code:ju,name:"quic-v1"},{code:Ju,name:"webtransport"},{code:hr,name:"certhash",size:xe,bytesToValue:Ww(Dl),valueToBytes:Kw},{code:fn,name:"http"},{code:Lw,name:"http-path",size:xe,stringToValue:n=>`/${decodeURIComponent(n)}`,valueToString:n=>encodeURIComponent(n.substring(1))},{code:uo,name:"https"},{code:Zo,name:"ws"},{code:ed,name:"wss"},{code:kw,name:"p2p-websocket-star"},{code:Rw,name:"p2p-stardust"},{code:Nw,name:"p2p-webrtc-star"},{code:Ow,name:"p2p-webrtc-direct"},{code:td,name:"webrtc-direct"},{code:ss,name:"webrtc"},{code:Yt,name:"p2p-circuit"},{code:nd,name:"memory",size:xe}];Xw.forEach(n=>{tt.addProtocol(n)});function Zw(n){const e=[];let t=0;for(;t<n.length;){const r=Gs(n,t),s=tt.getProtocol(r),i=Ie(r),o=tb(s,n,t+i);let a=0;o>0&&s.size===xe&&(a=Ie(o));const c=i+a+o,u={code:r,name:s.name,bytes:n.subarray(t,t+c)};if(o>0){const l=t+i+a,d=n.subarray(l,l+o);u.value=s.bytesToValue?.(d)??q(d)}e.push(u),t+=c}return e}function jw(n){let e=0;const t=[];for(const r of n){if(r.bytes==null){const s=tt.getProtocol(r.code),i=Ie(r.code);let o,a=0,c=0;r.value!=null&&(o=s.valueToBytes?.(r.value)??$(r.value),a=o.byteLength,s.size===xe&&(c=Ie(a)));const u=new Uint8Array(i+c+a);let l=0;ps(r.code,u,l),l+=i,o!=null&&(s.size===xe&&(ps(a,u,l),l+=c),u.set(o,l)),r.bytes=u}t.push(r.bytes),e+=r.bytes.byteLength}return $t(t,e)}function Jw(n){if(n.charAt(0)!=="/")throw new ze('String multiaddr must start with "/"');const e=[];let t="protocol",r="",s="";for(let i=1;i<n.length;i++){const o=n.charAt(i);o!=="/"&&(t==="protocol"?s+=n.charAt(i):r+=n.charAt(i));const a=i===n.length-1;if(o==="/"||a){const c=tt.getProtocol(s);if(t==="protocol"){if(c.size==null||c.size===0){e.push({code:c.code,name:c.name}),r="",s="",t="protocol";continue}else if(a)throw new ze(`Component ${s} was missing value`);t="value"}else if(t==="value"){const u={code:c.code,name:c.name};if(c.size!=null&&c.size!==0){if(r==="")throw new ze(`Component ${s} was missing value`);u.value=c.stringToValue?.(r)??r}e.push(u),r="",s="",t="protocol"}}}if(s!==""&&r!=="")throw new ze("Incomplete multiaddr");return e}function eb(n){return`/${n.flatMap(e=>{if(e.value==null)return e.name;const t=tt.getProtocol(e.code);if(t==null)throw new ze(`Unknown protocol code ${e.code}`);return[e.name,t.valueToString?.(e.value)??e.value]}).join("/")}`}function tb(n,e,t){return n.size==null||n.size===0?0:n.size>0?n.size/8:Gs(e,t)}const nb=Symbol.for("nodejs.util.inspect.custom"),sd=Symbol.for("@multiformats/multiaddr"),rb=[Tr,Pr,Mn,Dr];class sb extends Error{constructor(e="No available resolver"){super(e),this.name="NoAvailableResolverError"}}function ib(n){if(n==null&&(n="/"),Xs(n))return n.getComponents();if(n instanceof Uint8Array)return Zw(n);if(typeof n=="string")return n=n.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),n===""&&(n="/"),Jw(n);if(Array.isArray(n))return n;throw new ze("Must be a string, Uint8Array, Component[], or another Multiaddr")}class an{[sd]=!0;#e;#n;#t;constructor(e="/",t={}){this.#e=ib(e),t.validate!==!1&&ob(this)}get bytes(){return this.#t==null&&(this.#t=jw(this.#e)),this.#t}toString(){return this.#n==null&&(this.#n=eb(this.#e)),this.#n}toJSON(){return this.toString()}toOptions(){let e,t,r,s,i="";for(const{code:a,name:c,value:u}of this.#e)a===Qt&&(i=`%${u??""}`),rb.includes(a)&&(t="tcp",s=443,r=`${u??""}${i}`,e=a===Mn?6:4),(a===pt||a===_s)&&(t=c==="tcp"?"tcp":"udp",s=parseInt(u??"")),(a===Vt||a===Ke)&&(t="tcp",r=`${u??""}${i}`,e=a===Ke?6:4);if(e==null||t==null||r==null||s==null)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:e,host:r,transport:t,port:s}}getComponents(){return[...this.#e]}protos(){return this.#e.map(({code:e,value:t})=>{const r=tt.getProtocol(e);return{code:e,size:r.size??0,name:r.name,resolvable:!!r.resolvable,path:!!r.path}})}protoCodes(){return this.#e.map(({code:e})=>e)}protoNames(){return this.#e.map(({name:e})=>e)}tuples(){return this.#e.map(({code:e,value:t})=>{if(t==null)return[e];const r=tt.getProtocol(e),s=[e];return t!=null&&s.push(r.valueToBytes?.(t)??$(t)),s})}stringTuples(){return this.#e.map(({code:e,value:t})=>t==null?[e]:[e,t])}encapsulate(e){const t=new an(e);return new an([...this.#e,...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),r=this.toString(),s=r.lastIndexOf(t);if(s<0)throw new ww(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);return new an(r.slice(0,s),{validate:!1})}decapsulateCode(e){let t;for(let r=this.#e.length-1;r>-1;r--)if(this.#e[r].code===e){t=r;break}return new an(this.#e.slice(0,t),{validate:!1})}getPeerId(){try{let e=[];this.#e.forEach(({code:r,value:s})=>{r===J&&e.push([r,s]),r===Yt&&(e=[])});const t=e.pop();if(t?.[1]!=null){const r=t[1];return r[0]==="Q"||r[0]==="1"?q(ge.decode(`z${r}`),"base58btc"):q(re.parse(r).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){for(const e of this.#e)if(tt.getProtocol(e.code).path)return e.value??null;return null}equals(e){return Te(this.bytes,e.bytes)}async resolve(e){const t=this.protos().find(i=>i.resolvable);if(t==null)return[this];const r=yb.get(t.name);if(r==null)throw new sb(`no available resolver for ${t.name}`);return(await r(this,e)).map(i=>W(i))}nodeAddress(){const e=this.toOptions();if(e.transport!=="tcp"&&e.transport!=="udp")throw new Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:e.family,address:e.host,port:e.port}}isThinWaistAddress(){return!(this.#e.length!==2||this.#e[0].code!==Vt&&this.#e[0].code!==Ke||this.#e[1].code!==pt&&this.#e[1].code!==_s)}[nb](){return`Multiaddr(${this.toString()})`}}function ob(n){n.getComponents().forEach(e=>{const t=tt.getProtocol(e.code);e.value!=null&&t.validate?.(e.value)})}function ab(n,e,t){let r=0;for(const s of n)if(!(r<e)){if(r>t)break;if(s!==255)return!1;r++}return!0}function cb(n,e,t,r){let s=0;for(const i of n)if(!(s<t)){if(s>r)break;if(i!==e[s])return!1;s++}return!0}function lb(n){switch(n.length){case fr:return n.join(".");case pr:{const e=[];for(let t=0;t<n.length;t++)t%2===0&&e.push(n[t].toString(16).padStart(2,"0")+n[t+1].toString(16).padStart(2,"0"));return e.join(":")}default:throw new Error("Invalid ip length")}}function ub(n){let e=0;for(let[t,r]of n.entries()){if(r===255){e+=8;continue}for(;(r&128)!=0;)e++,r=r<<1;if((r&128)!=0)return-1;for(let s=t+1;s<n.length;s++)if(n[s]!=0)return-1;break}return e}function db(n){let e="0x";for(const t of n)e+=(t>>4).toString(16)+(t&15).toString(16);return e}const fr=4,pr=16,hb=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function id(n,e){e.length===pr&&n.length===fr&&ab(e,0,11)&&(e=e.slice(12)),e.length===fr&&n.length===pr&&cb(n,hb,0,11)&&(n=n.slice(12));const t=n.length;if(t!=e.length)throw new Error("Failed to mask ip");const r=new Uint8Array(t);for(let s=0;s<t;s++)r[s]=n[s]&e[s];return r}function fb(n,e){if(typeof e=="string"&&(e=lo(e)),e==null)throw new Error("Invalid ip");if(e.length!==n.network.length)return!1;for(let t=0;t<e.length;t++)if((n.network[t]&n.mask[t])!==(e[t]&n.mask[t]))return!1;return!0}function pb(n){const[e,t]=n.split("/");if(!e||!t)throw new Error("Failed to parse given CIDR: "+n);let r=fr,s=Hu(e);if(s==null&&(r=pr,s=Gu(e),s==null))throw new Error("Failed to parse given CIDR: "+n);const i=parseInt(t,10);if(Number.isNaN(i)||String(i).length!==t.length||i<0||i>r*8)throw new Error("Failed to parse given CIDR: "+n);const o=od(i,8*r);return{network:id(s,o),mask:o}}function od(n,e){if(e!==8*fr&&e!==8*pr)throw new Error("Invalid CIDR mask");if(n<0||n>e)throw new Error("Invalid CIDR mask");const t=e/8,r=new Uint8Array(t);for(let s=0;s<t;s++){if(n>=8){r[s]=255,n-=8;continue}r[s]=255-(255>>n),n=0}return r}class ad{constructor(e,t){if(t==null)({network:this.network,mask:this.mask}=pb(e));else{const r=lo(e);if(r==null)throw new Error("Failed to parse network");t=String(t);const s=parseInt(t,10);if(Number.isNaN(s)||String(s).length!==t.length||s<0||s>r.length*8){const i=lo(t);if(i==null)throw new Error("Failed to parse mask");this.mask=i}else this.mask=od(s,8*r.length);this.network=id(r,this.mask)}}contains(e){return fb({network:this.network,mask:this.mask},e)}toString(){const e=ub(this.mask),t=e!==-1?String(e):db(this.mask);return lb(this.network)+"/"+t}}function gb(n,e){return new ad(n).contains(e)}function mb(n){let e,t;if(n.getComponents().forEach(r=>{(r.name==="ip4"||r.name==="ip6")&&(t=r.value),r.name==="ipcidr"&&(e=r.value)}),e==null||t==null)throw new Error("Invalid multiaddr");return new ad(t,e)}const yb=new Map;function Xs(n){return!!n?.[sd]}function W(n){return new an(n)}function Lr(n){const e=tt.getProtocol(n);return{code:e.code,size:e.size??0,name:e.name,resolvable:!!e.resolvable,path:!!e.path}}const wb="libp2p-peer-record",bb=Uint8Array.from([3,1]);var Cs;(function(n){(function(t){let r;t.codec=()=>(r==null&&(r=fe((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.multiaddr!=null&&s.multiaddr.byteLength>0&&(i.uint32(10),i.bytes(s.multiaddr)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={multiaddr:j(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const u=s.uint32();switch(u>>>3){case 1:{a.multiaddr=s.bytes();break}default:{s.skipType(u&7);break}}}return a})),r),t.encode=s=>he(s,t.codec()),t.decode=(s,i)=>de(s,t.codec(),i)})(n.AddressInfo||(n.AddressInfo={}));let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.peerId!=null&&t.peerId.byteLength>0&&(r.uint32(10),r.bytes(t.peerId)),t.seq!=null&&t.seq!==0n&&(r.uint32(16),r.uint64(t.seq)),t.addresses!=null)for(const i of t.addresses)r.uint32(26),n.AddressInfo.codec().encode(i,r);s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={peerId:j(0),seq:0n,addresses:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.peerId=t.bytes();break}case 2:{i.seq=t.uint64();break}case 3:{if(s.limits?.addresses!=null&&i.addresses.length===s.limits.addresses)throw new mt('Decode error - map field "addresses" had too many elements');i.addresses.push(n.AddressInfo.codec().decode(t,t.uint32(),{limits:s.limits?.addresses$}));break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(Cs||(Cs={}));class $e{static createFromProtobuf=e=>{const t=Cs.decode(e),r=_r(Er(t.peerId)),s=(t.addresses??[]).map(o=>W(o.multiaddr)),i=t.seq;return new $e({peerId:r,multiaddrs:s,seqNumber:i})};static DOMAIN=wb;static CODEC=bb;peerId;multiaddrs;seqNumber;domain=$e.DOMAIN;codec=$e.CODEC;marshaled;constructor(e){const{peerId:t,multiaddrs:r,seqNumber:s}=e;this.peerId=t,this.multiaddrs=r??[],this.seqNumber=s??BigInt(Date.now())}marshal(){return this.marshaled==null&&(this.marshaled=Cs.encode({peerId:this.peerId.toMultihash().bytes,seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map(e=>({multiaddr:e.bytes}))})),this.marshaled}equals(e){return!(!(e instanceof $e)||!this.peerId.equals(e.peerId)||this.seqNumber!==e.seqNumber||!yw(this.multiaddrs,e.multiaddrs))}}function wt(n,e){const t=bn(n,e),r={read:async(s,i)=>{const o=await t.read(i);return s.decode(o)},write:async(s,i,o)=>{await t.write(i.encode(s),o)},writeV:async(s,i,o)=>{await t.writeV(s.map(a=>i.encode(a)),o)},pb:s=>({read:async i=>r.read(s,i),write:async(i,o)=>r.write(i,s,o),writeV:async(i,o)=>r.writeV(i,s,o),unwrap:()=>r}),unwrap:()=>t.unwrap()};return r}const Eb=290,vb=1,cd=2e3,Sb=100,Hr=`${So}-circuit-relay`;BigInt(1<<17);const Is="/libp2p/circuit/relay/0.2.0/hop",cc="/libp2p/circuit/relay/0.2.0/stop",lc=300,xb=4096,Ab=.001;var xn;(function(n){(function(r){r.RESERVE="RESERVE",r.CONNECT="CONNECT",r.STATUS="STATUS"})(n.Type||(n.Type={}));let e;(function(r){r[r.RESERVE=0]="RESERVE",r[r.CONNECT=1]="CONNECT",r[r.STATUS=2]="STATUS"})(e||(e={})),function(r){r.codec=()=>Nn(e)}(n.Type||(n.Type={}));let t;n.codec=()=>(t==null&&(t=fe((r,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),r.type!=null&&(s.uint32(8),n.Type.codec().encode(r.type,s)),r.peer!=null&&(s.uint32(18),An.codec().encode(r.peer,s)),r.reservation!=null&&(s.uint32(26),Ts.codec().encode(r.reservation,s)),r.limit!=null&&(s.uint32(34),_n.codec().encode(r.limit,s)),r.status!=null&&(s.uint32(40),Le.codec().encode(r.status,s)),i.lengthDelimited!==!1&&s.ldelim()},(r,s,i={})=>{const o={},a=s==null?r.len:r.pos+s;for(;r.pos<a;){const c=r.uint32();switch(c>>>3){case 1:{o.type=n.Type.codec().decode(r);break}case 2:{o.peer=An.codec().decode(r,r.uint32(),{limits:i.limits?.peer});break}case 3:{o.reservation=Ts.codec().decode(r,r.uint32(),{limits:i.limits?.reservation});break}case 4:{o.limit=_n.codec().decode(r,r.uint32(),{limits:i.limits?.limit});break}case 5:{o.status=Le.codec().decode(r);break}default:{r.skipType(c&7);break}}}return o})),t),n.encode=r=>he(r,n.codec()),n.decode=(r,s)=>de(r,n.codec(),s)})(xn||(xn={}));var ut;(function(n){(function(r){r.CONNECT="CONNECT",r.STATUS="STATUS"})(n.Type||(n.Type={}));let e;(function(r){r[r.CONNECT=0]="CONNECT",r[r.STATUS=1]="STATUS"})(e||(e={})),function(r){r.codec=()=>Nn(e)}(n.Type||(n.Type={}));let t;n.codec=()=>(t==null&&(t=fe((r,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),r.type!=null&&(s.uint32(8),n.Type.codec().encode(r.type,s)),r.peer!=null&&(s.uint32(18),An.codec().encode(r.peer,s)),r.limit!=null&&(s.uint32(26),_n.codec().encode(r.limit,s)),r.status!=null&&(s.uint32(32),Le.codec().encode(r.status,s)),i.lengthDelimited!==!1&&s.ldelim()},(r,s,i={})=>{const o={},a=s==null?r.len:r.pos+s;for(;r.pos<a;){const c=r.uint32();switch(c>>>3){case 1:{o.type=n.Type.codec().decode(r);break}case 2:{o.peer=An.codec().decode(r,r.uint32(),{limits:i.limits?.peer});break}case 3:{o.limit=_n.codec().decode(r,r.uint32(),{limits:i.limits?.limit});break}case 4:{o.status=Le.codec().decode(r);break}default:{r.skipType(c&7);break}}}return o})),t),n.encode=r=>he(r,n.codec()),n.decode=(r,s)=>de(r,n.codec(),s)})(ut||(ut={}));var An;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.id!=null&&t.id.byteLength>0&&(r.uint32(10),r.bytes(t.id)),t.addrs!=null)for(const i of t.addrs)r.uint32(18),r.bytes(i);s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={id:j(0),addrs:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.id=t.bytes();break}case 2:{if(s.limits?.addrs!=null&&i.addrs.length===s.limits.addrs)throw new mt('Decode error - map field "addrs" had too many elements');i.addrs.push(t.bytes());break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(An||(An={}));var Ts;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.expire!=null&&t.expire!==0n&&(r.uint32(8),r.uint64(t.expire)),t.addrs!=null)for(const i of t.addrs)r.uint32(18),r.bytes(i);t.voucher!=null&&(r.uint32(26),Ds.codec().encode(t.voucher,r)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={expire:0n,addrs:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.expire=t.uint64();break}case 2:{if(s.limits?.addrs!=null&&i.addrs.length===s.limits.addrs)throw new mt('Decode error - map field "addrs" had too many elements');i.addrs.push(t.bytes());break}case 3:{i.voucher=Ds.codec().decode(t,t.uint32(),{limits:s.limits?.voucher});break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(Ts||(Ts={}));var _n;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.duration!=null&&(r.uint32(8),r.uint32(t.duration)),t.data!=null&&(r.uint32(16),r.uint64(t.data)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.duration=t.uint32();break}case 2:{i.data=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(_n||(_n={}));var Le;(function(n){n.UNUSED="UNUSED",n.OK="OK",n.RESERVATION_REFUSED="RESERVATION_REFUSED",n.RESOURCE_LIMIT_EXCEEDED="RESOURCE_LIMIT_EXCEEDED",n.PERMISSION_DENIED="PERMISSION_DENIED",n.CONNECTION_FAILED="CONNECTION_FAILED",n.NO_RESERVATION="NO_RESERVATION",n.MALFORMED_MESSAGE="MALFORMED_MESSAGE",n.UNEXPECTED_MESSAGE="UNEXPECTED_MESSAGE"})(Le||(Le={}));var ho;(function(n){n[n.UNUSED=0]="UNUSED",n[n.OK=100]="OK",n[n.RESERVATION_REFUSED=200]="RESERVATION_REFUSED",n[n.RESOURCE_LIMIT_EXCEEDED=201]="RESOURCE_LIMIT_EXCEEDED",n[n.PERMISSION_DENIED=202]="PERMISSION_DENIED",n[n.CONNECTION_FAILED=203]="CONNECTION_FAILED",n[n.NO_RESERVATION=204]="NO_RESERVATION",n[n.MALFORMED_MESSAGE=400]="MALFORMED_MESSAGE",n[n.UNEXPECTED_MESSAGE=401]="UNEXPECTED_MESSAGE"})(ho||(ho={}));(function(n){n.codec=()=>Nn(ho)})(Le||(Le={}));var Ps;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.relay!=null&&t.relay.byteLength>0&&(r.uint32(10),r.bytes(t.relay)),t.peer!=null&&t.peer.byteLength>0&&(r.uint32(18),r.bytes(t.peer)),t.expiration!=null&&t.expiration!==0n&&(r.uint32(24),r.uint64(t.expiration)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={relay:j(0),peer:j(0),expiration:0n},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.relay=t.bytes();break}case 2:{i.peer=t.bytes();break}case 3:{i.expiration=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(Ps||(Ps={}));var Ds;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(r.uint32(10),r.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(r.uint32(18),r.bytes(t.payloadType)),t.payload!=null&&(r.uint32(26),Ps.codec().encode(t.payload,r)),t.signature!=null&&t.signature.byteLength>0&&(r.uint32(42),r.bytes(t.signature)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={publicKey:j(0),payloadType:j(0),signature:j(0)},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.publicKey=t.bytes();break}case 2:{i.payloadType=t.bytes();break}case 3:{i.payload=Ps.codec().decode(t,t.uint32(),{limits:s.limits?.payload});break}case 5:{i.signature=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(Ds||(Ds={}));const se=n=>({match:e=>{const t=e[0];return t==null||t.code!==n||t.value!=null?!1:e.slice(1)}}),U=(n,e)=>({match:t=>{const r=t[0];return r?.code!==n||r.value==null||e!=null&&r.value!==e?!1:t.slice(1)}}),Y=n=>({match:e=>{const t=n.match(e);return t===!1?e:t}}),ke=(...n)=>({match:e=>{let t;for(const r of n){const s=r.match(e);s!==!1&&(t==null||s.length<t.length)&&(t=s)}return t??!1}}),Z=(...n)=>({match:e=>{for(const t of n){const r=t.match(e);if(r===!1)return!1;e=r}return e}});function te(...n){function e(s){if(s==null)return!1;let i=s.getComponents();for(const o of n){const a=o.match(i);if(a===!1)return!1;i=a}return i}function t(s){return e(s)!==!1}function r(s){const i=e(s);return i===!1?!1:i.length===0}return{matchers:n,matches:t,exactMatch:r}}const _b=U(J),Cb=te(_b),Zs=U(Pr),js=U(Mn),Js=U(Dr),jo=U(Tr);te(Zs,Y(U(J)));te(js,Y(U(J)));te(Js,Y(U(J)));te(ke(jo,Js,Zs,js),Y(U(J)));const ld=Z(U(Vt),Y(U(Xo))),ud=Z(Y(U(Qt)),U(Ke),Y(U(Xo))),Jo=ke(ld,ud),Ht=ke(Jo,jo,Zs,js,Js),Ib=te(ke(Jo,Z(ke(jo,Js,Zs,js),Y(U(J))))),uc=te(ld),dc=te(ud);te(Jo);const ea=Z(Ht,U(pt)),kr=Z(Ht,U(_s)),Ls=te(Z(ea,Y(U(J))));te(kr);const ta=Z(kr,se(Zu),Y(U(J))),ei=Z(kr,se(ju),Y(U(J))),Tb=ke(ta,ei);te(ta);const Pb=te(ei),fo=ke(Ht,ea,kr,ta,ei),dd=ke(Z(fo,se(Zo),Y(U(J)))),gr=te(dd),hd=ke(Z(fo,se(ed),Y(U(J))),Z(fo,se(hn),Y(U(Xu)),se(Zo),Y(U(J)))),ks=te(hd),fd=Z(kr,se(td),Y(U(hr)),Y(U(hr)),Y(U(J))),hc=te(fd),pd=Z(ei,se(Ju),Y(U(hr)),Y(U(hr)),Y(U(J))),fc=te(pd),Rs=ke(dd,hd,Z(ea,Y(U(J))),Z(Tb,Y(U(J))),Z(Ht,Y(U(J))),fd,pd,U(J)),gd=te(Rs),Db=Z(Rs,se(Yt),U(J)),mr=te(Db),Lb=ke(Z(Rs,se(Yt),se(ss),Y(U(J))),Z(Rs,se(ss),Y(U(J))),Z(se(ss),Y(U(J)))),po=te(Lb),kb=ke(Z(Ht,U(pt),se(fn),Y(U(J))),Z(Ht,se(fn),Y(U(J))));te(kb);const Rb=Z(Ht,ke(Z(U(pt,"443"),se(fn)),Z(U(pt),se(uo)),Z(U(pt),se(hn),se(fn)),Z(se(hn),se(fn)),se(hn),se(uo)),Y(U(J)));te(Rb);const Nb=ke(Z(U(nd),Y(U(J))));te(Nb);const Ob=ke(Z(U(Yu),Y(U(J))));te(Ob);function Dt(n){const e=new globalThis.AbortController;function t(){e.abort();for(const i of n)i?.removeEventListener!=null&&i.removeEventListener("abort",t)}for(const i of n){if(i?.aborted===!0){t();break}i?.addEventListener!=null&&i.addEventListener("abort",t)}function r(){for(const i of n)i?.removeEventListener!=null&&i.removeEventListener("abort",t)}const s=e.signal;return s.clear=r,s}class pc extends Error{static name="HadEnoughRelaysError";name="HadEnoughRelaysError"}class Mb extends Error{static name="DoubleRelayError";name="DoubleRelayError"}class Fb extends Error{static name="RelayQueueFullError";name="RelayQueueFullError"}function gc(n){const e=n*BigInt(1e3),t=new Date().getTime();return Number(e-BigInt(t))}class mc{expires;bytes;constructor(e){e?.duration!=null&&e?.duration!==0&&(this.expires=Date.now()+e.duration*1e3),this.bytes=e?.data,this.bytes===0n&&(this.bytes=void 0),this.onData=this.onData.bind(this)}onData(e){this.bytes!=null&&(this.bytes-=BigInt(e.byteLength),this.bytes<0n&&(this.bytes=0n))}getLimits(){if(this.expires==null&&this.bytes==null)return;const e={};if(this.bytes!=null){const t=this;Object.defineProperty(e,"bytes",{get(){return t.bytes}})}if(this.expires!=null){const t=this;Object.defineProperty(e,"seconds",{get(){return Math.round(((t.expires??0)-Date.now())/1e3)}})}return e}}const md=te(Z(gd.matchers[0],se(Yt))),yd=te(se(Yt));function ir(n,e){const t={[Symbol.iterator]:()=>t,next:()=>{const r=n.next(),s=r.value;return r.done===!0||s==null?{done:!0,value:void 0}:{done:!1,value:e(s)}}};return t}function Si(n){const e=Er(ge.decode(`z${n}`));return _r(e)}class Fn{map;constructor(e){if(this.map=new Map,e!=null)for(const[t,r]of e.entries())this.map.set(t.toString(),{key:t,value:r})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(e){return this.map.delete(e.toString())}entries(){return ir(this.map.entries(),e=>[e[1].key,e[1].value])}forEach(e){this.map.forEach((t,r)=>{e(t.value,t.key,this)})}get(e){return this.map.get(e.toString())?.value}has(e){return this.map.has(e.toString())}set(e,t){this.map.set(e.toString(),{key:e,value:t})}keys(){return ir(this.map.values(),e=>e.key)}values(){return ir(this.map.values(),e=>e.value)}get size(){return this.map.size}}class pn{set;constructor(e){if(this.set=new Set,e!=null)for(const t of e)this.set.add(t.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(e){this.set.add(e.toString())}clear(){this.set.clear()}delete(e){this.set.delete(e.toString())}entries(){return ir(this.set.entries(),e=>{const t=Si(e[0]);return[t,t]})}forEach(e){this.set.forEach(t=>{const r=Si(t);e(r,r,this)})}has(e){return this.set.has(e.toString())}values(){return ir(this.set.values(),e=>Si(e))}intersection(e){const t=new pn;for(const r of e)this.has(r)&&t.add(r);return t}difference(e){const t=new pn;for(const r of this)e.has(r)||t.add(r);return t}union(e){const t=new pn;for(const r of e)t.add(r);for(const r of this)t.add(r);return t}}const na={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},wd={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},bd=new globalThis.TextEncoder;function Ub(n,e){const t=na[e];let r=wd[e];for(let s=0;s<n.length;s++)r^=BigInt(n[s]),r=BigInt.asUintN(e,r*t);return r}function Bb(n,e,t){if(t.length===0)throw new Error("The `utf8Buffer` option must have a length greater than zero");const r=na[e];let s=wd[e],i=n;for(;i.length>0;){const o=bd.encodeInto(i,t);i=i.slice(o.read);for(let a=0;a<o.written;a++)s^=BigInt(t[a]),s=BigInt.asUintN(e,s*r)}return s}function $b(n,{size:e=32,utf8Buffer:t}={}){if(!na[e])throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if(typeof n=="string"){if(t)return Bb(n,e,t);n=bd.encode(n)}return Ub(n,e)}const ra={hash:n=>Number($b(n,{size:32})),hashV:(n,e)=>qb(ra.hash(n,e))};function qb(n){let e=n.toString(16);return e.length%2===1&&(e=`0${e}`),$(e,"base16")}const Ed=64;class Ot{fp;h;seed;constructor(e,t,r,s=2){if(s>Ed)throw new TypeError("Invalid Fingerprint Size");const i=t.hashV(e,r),o=j(s);for(let a=0;a<o.length;a++)o[a]=i[a];o.length===0&&(o[0]=7),this.fp=o,this.h=t,this.seed=r}hash(){return this.h.hash(this.fp,this.seed)}equals(e){return e?.fp instanceof Uint8Array?Te(this.fp,e.fp):!1}}function Ns(n,e){return Math.floor(Math.random()*(e-n))+n}class Gr{contents;constructor(e){this.contents=new Array(e).fill(null)}has(e){if(!(e instanceof Ot))throw new TypeError("Invalid Fingerprint");return this.contents.some(t=>e.equals(t))}add(e){if(!(e instanceof Ot))throw new TypeError("Invalid Fingerprint");for(let t=0;t<this.contents.length;t++)if(this.contents[t]==null)return this.contents[t]=e,!0;return!0}swap(e){if(!(e instanceof Ot))throw new TypeError("Invalid Fingerprint");const t=Ns(0,this.contents.length-1),r=this.contents[t];return this.contents[t]=e,r}remove(e){if(!(e instanceof Ot))throw new TypeError("Invalid Fingerprint");const t=this.contents.findIndex(r=>e.equals(r));return t>-1?(this.contents[t]=null,!0):!1}}const zb=500;class yc{bucketSize;filterSize;fingerprintSize;buckets;count;hash;seed;constructor(e){this.filterSize=e.filterSize,this.bucketSize=e.bucketSize??4,this.fingerprintSize=e.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=e.hash??ra,this.seed=e.seed??Ns(0,Math.pow(2,10))}add(e){typeof e=="string"&&(e=$(e));const t=new Ot(e,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(e,this.seed)%this.filterSize,s=(r^t.hash())%this.filterSize;if(this.buckets[r]==null&&(this.buckets[r]=new Gr(this.bucketSize)),this.buckets[s]==null&&(this.buckets[s]=new Gr(this.bucketSize)),this.buckets[r].add(t)||this.buckets[s].add(t))return this.count++,!0;const i=[r,s];let o=i[Ns(0,i.length-1)];this.buckets[o]==null&&(this.buckets[o]=new Gr(this.bucketSize));for(let a=0;a<zb;a++){const c=this.buckets[o].swap(t);if(c!=null&&(o=(o^c.hash())%this.filterSize,this.buckets[o]==null&&(this.buckets[o]=new Gr(this.bucketSize)),this.buckets[o].add(c)))return this.count++,!0}return!1}has(e){typeof e=="string"&&(e=$(e));const t=new Ot(e,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(e,this.seed)%this.filterSize,s=this.buckets[r]?.has(t)??!1;if(s)return s;const i=(r^t.hash())%this.filterSize;return this.buckets[i]?.has(t)??!1}remove(e){typeof e=="string"&&(e=$(e));const t=new Ot(e,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(e,this.seed)%this.filterSize,s=this.buckets[r]?.remove(t)??!1;if(s)return this.count--,s;const i=(r^t.hash())%this.filterSize,o=this.buckets[i]?.remove(t)??!1;return o&&this.count--,o}get reliable(){return Math.floor(100*(this.count/this.filterSize))<=90}}const Kb={1:.5,2:.84,4:.95,8:.98};function Wb(n=.001){return n>.002?2:n>1e-5?4:8}function Vb(n,e=.001){const t=Wb(e),r=Kb[t],s=Math.round(n/r),i=Math.min(Math.ceil(Math.log2(1/e)+Math.log2(2*t)),Ed);return{filterSize:s,bucketSize:t,fingerprintSize:i}}class Hb{filterSize;bucketSize;fingerprintSize;scale;filterSeries;hash;seed;constructor(e){this.bucketSize=e.bucketSize??4,this.filterSize=e.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=e.fingerprintSize??2,this.scale=e.scale??2,this.hash=e.hash??ra,this.seed=e.seed??Ns(0,Math.pow(2,10)),this.filterSeries=[new yc({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(e){if(typeof e=="string"&&(e=$(e)),this.has(e))return!0;let t=this.filterSeries.find(r=>r.reliable);if(t==null){const r=this.filterSize*Math.pow(this.scale,this.filterSeries.length);t=new yc({filterSize:r,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(t)}return t.add(e)}has(e){typeof e=="string"&&(e=$(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].has(e))return!0;return!1}remove(e){typeof e=="string"&&(e=$(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].remove(e))return!0;return!1}get count(){return this.filterSeries.reduce((e,t)=>e+t.count,0)}}function yr(n,e=.001,t){return new Hb({...Vb(n,e)})}class Gb{filter;constructor(e,t){this.filter=yr(e,t)}has(e){return this.filter.has(e.toMultihash().bytes)}add(e){this.filter.add(e.toMultihash().bytes)}remove(e){this.filter.remove?.(e.toMultihash().bytes)}}function Qb(n,e=.001){return new Gb(n,e)}class Yb extends Fn{metric;constructor(e){super();const{name:t,metrics:r}=e;this.metric=r.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){const t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function Xb(n){const{name:e,metrics:t}=n;let r;return t!=null?r=new Yb({name:e,metrics:t}):r=new Fn,r}function wc(n){const{stream:e,remoteAddr:t,logger:r,onDataRead:s,onDataWrite:i}=n,o=r.forComponent("libp2p:stream:converter");let a=!1,c=!1;const u=e.close.bind(e);e.close=async g=>{await u(g),p(!0)};const l=e.abort.bind(e);e.abort=g=>{l(g),p(!0)};const d=e.sink.bind(e);e.sink=async g=>{try{await d(xu(g,m=>Ku(m,f=>i?.(f))))}catch(m){m.type!=="aborted"&&o.error("%s error in sink",t,m)}finally{c=!0,p()}};const h={log:o,sink:e.sink,source:async function*(){try{for await(const g of e.source)s?.(g),yield g}finally{a=!0,p()}}(),remoteAddr:t,timeline:{open:Date.now(),close:void 0},close:e.close,abort:e.abort};function p(g){g===!0&&(a=!0,c=!0),a&&c&&h.timeline.close==null&&(h.timeline.close=Date.now())}return h}class ee extends Event{type;detail;constructor(e,t){super(e),this.type=e,this.detail=t}}let Cn=class extends Error{static name="AbortError";name="AbortError";constructor(e="The operation was aborted",...t){super(e,...t)}};async function gt(n,e,t,r){const s=new Cn(r?.errorMessage);r?.errorCode!=null&&(s.code=r.errorCode);const i=r?.errorEvent??"error";return t?.aborted===!0?Promise.reject(s):new Promise((o,a)=>{function c(){Ai(t,"abort",d),Ai(n,e,u),Ai(n,i,l)}const u=h=>{try{if(r?.filter?.(h)===!1)return}catch(p){c(),a(p);return}c(),o(h)},l=h=>{if(c(),h instanceof Error){a(h);return}a(h.detail??r?.error??new Error(`The "${r?.errorEvent}" event was emitted but the event had no '.detail' field. Pass an 'error' option to race-event to change this message.`))},d=()=>{c(),a(s)};xi(t,"abort",d),xi(n,e,u),xi(n,i,l)})}function xi(n,e,t){n!=null&&(vd(n)?n.addListener(e,t):n.addEventListener(e,t))}function Ai(n,e,t){n!=null&&(vd(n)?n.removeListener(e,t):n.removeEventListener(e,t))}function vd(n){return typeof n.on=="function"&&typeof n.emit=="function"}function Os(n,e){let t;const r=function(){const s=function(){t=void 0,n()};clearTimeout(t),t=setTimeout(s,e)};return r.start=()=>{},r.stop=()=>{clearTimeout(t)},r}class Zb extends Error{remainingPoints;msBeforeNext;consumedPoints;isFirstInDuration;constructor(e="Rate limit exceeded",t){super(e),this.name="RateLimitError",this.remainingPoints=t.remainingPoints,this.msBeforeNext=t.msBeforeNext,this.consumedPoints=t.consumedPoints,this.isFirstInDuration=t.isFirstInDuration}}let jb=class extends Error{static name="QueueFullError";constructor(e="The queue was full"){super(e),this.name="QueueFullError"}},Jb=class{deferred;signal;constructor(e){this.signal=e,this.deferred=z(),this.onAbort=this.onAbort.bind(this),this.signal?.addEventListener("abort",this.onAbort)}onAbort(){this.deferred.reject(this.signal?.reason??new Bt)}cleanup(){this.signal?.removeEventListener("abort",this.onAbort)}};function e0(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}let t0=class{id;fn;options;recipients;status;timeline;controller;constructor(e,t){this.id=e0(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,r)=>t&&r.signal?.aborted===!0,!0)&&(this.controller.abort(new Bt),this.cleanup())}async join(e={}){const t=new Jb(e.signal);return this.recipients.push(t),e.signal?.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await ie(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{e.cleanup(),e.signal?.removeEventListener("abort",this.onAbort)})}},Sd=class extends nt{concurrency;maxSize;queue;pending;sort;constructor(e={}){super(),this.concurrency=e.concurrency??Number.POSITIVE_INFINITY,this.maxSize=e.maxSize??Number.POSITIVE_INFINITY,this.pending=0,e.metricName!=null&&e.metrics?.registerMetricGroup(e.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})}),this.sort=e.sort,this.queue=[],this.emitEmpty=Os(this.emitEmpty.bind(this),1),this.emitIdle=Os(this.emitIdle.bind(this),1)}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(const t of this.queue)if(t.status==="queued"){e=t;break}return e==null?!1:(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let t=0;t<this.queue.length;t++)if(this.queue[t]===e){this.queue.splice(t,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")}),!0)}return!1}enqueue(e){this.queue.push(e),this.sort!=null&&this.queue.sort(this.sort)}async add(e,t){if(t?.signal?.throwIfAborted(),this.size===this.maxSize)throw new jb;const r=new t0(e,t);return this.enqueue(r),this.safeDispatchEvent("add"),this.tryToStartAnother(),r.join(t).then(s=>(this.safeDispatchEvent("completed",{detail:s}),this.safeDispatchEvent("success",{detail:{job:r,result:s}}),s)).catch(s=>{if(r.status==="queued"){for(let i=0;i<this.queue.length;i++)if(this.queue[i]===r){this.queue.splice(i,1);break}}throw this.safeDispatchEvent("error",{detail:s}),this.safeDispatchEvent("failure",{detail:{job:r,error:s}}),s})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new Bt)}),this.clear()}async onEmpty(e){this.size!==0&&await gt(this,"empty",e?.signal)}async onSizeLessThan(e,t){this.size<e||await gt(this,"next",t?.signal,{filter:()=>this.size<e})}async onIdle(e){this.pending===0&&this.size===0||await gt(this,"idle",e?.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){e?.signal?.throwIfAborted();const t=On({objectMode:!0}),r=c=>{c!=null?this.abort():this.clear(),t.end(c)},s=c=>{c.detail!=null&&t.push(c.detail)},i=c=>{r(c.detail)},o=()=>{r()},a=()=>{r(new Bt("Queue aborted"))};this.addEventListener("completed",s),this.addEventListener("error",i),this.addEventListener("idle",o),e?.signal?.addEventListener("abort",a);try{yield*t}finally{this.removeEventListener("completed",s),this.removeEventListener("error",i),this.removeEventListener("idle",o),e?.signal?.removeEventListener("abort",a),r()}}};class sa extends Sd{has(e){return this.find(e)!=null}find(e){return this.queue.find(t=>e.equals(t.options.peerId))}}class n0 extends nt{components;started;running;topologyId;log;discoveryController;filter;queue;constructor(e,t={}){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:discover-relays"),this.components=e,this.started=!1,this.running=!1,this.filter=t.filter,this.discoveryController=new AbortController,this.discoveryController.signal,this.dialPeer=this.dialPeer.bind(this),this.onPeer=this.onPeer.bind(this)}isStarted(){return this.started}async start(){this.topologyId=await this.components.registrar.register(Is,{filter:this.filter,onConnect:e=>{this.log.trace("discovered relay %p queue (length: %d, active %d)",e,this.queue?.size,this.queue?.running),this.safeDispatchEvent("relay:discover",{detail:e})}}),this.started=!0}stop(){this.topologyId!=null&&this.components.registrar.unregister(this.topologyId),this.running&&this.stopDiscovery(),this.started=!1}startDiscovery(){this.running||(this.log("start discovery"),this.running=!0,this.discoveryController=new AbortController,this.discoveryController.signal,this.components.events.addEventListener("peer:discovery",this.onPeer),Promise.resolve().then(async()=>{this.log("searching peer store for relays");const e=await this.components.peerStore.all({filters:[r=>r.protocols.includes(Is)],orders:[()=>Math.random()<.5?1:-1,(r,s)=>{const i=bc(r),o=bc(s);return i>o?-1:o>i?1:0}]});for(const r of e)this.log.trace("found relay peer %p in peer store",r.id),this.safeDispatchEvent("relay:discover",{detail:r.id});this.log("found %d relay peers in peer store",e.length);const t=this.queue=new sa({concurrency:5});this.log("start random walk");for await(const r of this.components.randomWalk.walk({signal:this.discoveryController.signal})){if(this.log.trace("found random peer %p",r.id),t.has(r.id)){this.log.trace("random peer %p was already in queue",r.id);continue}if(this.components.connectionManager.getConnections(r.id)?.length>0){this.log.trace("random peer %p was already connected",r.id);continue}if(!await this.components.connectionManager.isDialable(r.multiaddrs)){this.log.trace("random peer %p was not dialable",r.id,r.multiaddrs.map(s=>s.toString()));continue}t.queued>10&&(this.log.trace("wait for space in queue for %p",r.id),await t.onSizeLessThan(10,{signal:this.discoveryController.signal})),this.log("adding random peer %p to dial queue (length: %d, active %d)",r.id,t.size,t.running),t.add(this.dialPeer,{peerId:r.id,signal:this.discoveryController.signal}).catch(s=>{this.log.error("error opening connection to random peer %p",r.id,s)})}this.log("stop random walk"),await t.onIdle()}).catch(e=>{this.discoveryController.signal.aborted||this.log.error("failed when finding relays on the network",e)}))}stopDiscovery(){this.log("stop discovery"),this.running=!1,this.discoveryController?.abort(),this.queue?.clear(),this.components.events.removeEventListener("peer:discovery",this.onPeer)}onPeer(e){this.log.trace("maybe dialing discovered peer %p - %e",e.detail.id),this.maybeDialPeer(e).catch(t=>{this.log.trace("error dialing discovered peer %p - %e",e.detail.id,t)})}async maybeDialPeer(e){if(this.queue==null)return;const t=e.detail.id,r=e.detail.multiaddrs;if(this.queue.has(t)){this.log.trace("random peer %p was already in queue",t);return}if(this.components.connectionManager.getConnections(t)?.length>0){this.log.trace("random peer %p was already connected",t);return}if(!await this.components.connectionManager.isDialable(r)){this.log.trace("random peer %p was not dialable",t);return}this.queue?.add(this.dialPeer,{peerId:e.detail.id,signal:this.discoveryController.signal}).catch(s=>{this.log.error("error opening connection to discovered peer %p",e.detail.id,s)})}async dialPeer({peerId:e,signal:t}){const r=Dt([AbortSignal.timeout(5e3),t]);try{await this.components.connectionManager.openConnection(e,{signal:r})}finally{r.clear()}}}function bc(n){const e=n.metadata.get("last-dial-success");return e==null?0:new Date(q(e)).getTime()}class r0 extends nt{connectionManager;addressManager;reservationStore;listeningAddrs;log;listenTimeout;reservationId;relay;constructor(e,t={}){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:transport:listener"),this.connectionManager=e.connectionManager,this.addressManager=e.addressManager,this.reservationStore=e.reservationStore,this.listeningAddrs=[],this.listenTimeout=t.listenTimeout??cd,this.reservationStore.addEventListener("relay:removed",this._onRemoveRelayPeer),this.reservationStore.addEventListener("relay:created-reservation",this._onAddRelayPeer)}_onRemoveRelayPeer=e=>{this.log("relay removed %p our relay %p",e.detail.relay,this.relay,this.relay?.equals(e.detail.relay)),this.relay?.equals(e.detail.relay)===!0&&(this.log("relay peer removed %p",e.detail.relay),this.listeningAddrs.forEach(t=>{this.addressManager.removeObservedAddr(t)}),this.listeningAddrs=[],this.safeDispatchEvent("listening"))};_onAddRelayPeer=e=>{const{details:t}=e.detail;t.type!=="configured"&&t.id===this.reservationId&&this.addedRelay(e.detail)};async listen(e){if(yd.exactMatch(e))this.log("searching for circuit relay servers"),this.reservationId=this.reservationStore.reserveRelay();else if(md.exactMatch(e)){this.log("listen on specific relay server %a",e);const t=AbortSignal.timeout(this.listenTimeout),r=e.decapsulate("/p2p-circuit"),s=await this.connectionManager.openConnection(r,{signal:t});if(!this.reservationStore.hasReservation(s.remotePeer)){this.log("making reservation on peer %p",s.remotePeer);const i=await this.reservationStore.addRelay(s.remotePeer,"configured");this.addedRelay(i)}}else throw new Hi(`Could not listen on p2p-circuit address "${e}"`)}getAddrs(){return[...this.listeningAddrs.values()].flat()}updateAnnounceAddrs(){}async close(){this.reservationStore.cancelReservations(),this.listeningAddrs=[],this.reservationStore.removeEventListener("relay:removed",this._onRemoveRelayPeer),queueMicrotask(()=>{this.safeDispatchEvent("close")})}addedRelay(e){this.log("relay peer added %p",e.relay),this.relay=e.relay,this.listeningAddrs=e.details.reservation.addrs.map(t=>W(t).encapsulate("/p2p-circuit")),this.listeningAddrs.forEach(t=>{this.addressManager.confirmObservedAddr(t,{type:"transport"})}),queueMicrotask(()=>{this.safeDispatchEvent("listening")})}}function s0(n){return new r0(n)}const i0="useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";let o0=(n=21)=>{let e="",t=crypto.getRandomValues(new Uint8Array(n|=0));for(;n--;)e+=i0[t[n]&63];return e};const a0=60*1e3*10,c0=60*1e3*5,l0=30*1e3;class u0 extends nt{peerId;connectionManager;peerStore;events;reserveQueue;reservations;pendingReservations;maxReservationQueueLength;reservationCompletionTimeout;started;log;relayFilter;constructor(e,t){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:transport:reservation-store"),this.peerId=e.peerId,this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.reservations=new Fn,this.pendingReservations=[],this.maxReservationQueueLength=t?.maxReservationQueueLength??Sb,this.reservationCompletionTimeout=t?.reservationCompletionTimeout??cd,this.started=!1,this.relayFilter=yr(100),this.reserveQueue=new sa({concurrency:t?.reservationConcurrency??vb,metricName:"libp2p_relay_reservation_queue",metrics:e.metrics}),this.events.addEventListener("connection:close",r=>{[...this.reservations.values()].find(i=>i.connection===r.detail.id)!=null&&this.#n(r.detail.remotePeer).catch(i=>{this.log("could not remove relay %p - %e",r.detail,i)})})}isStarted(){return this.started}start(){this.started=!0}afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[t=>t.tags.has(Hr)]});this.log("removing tag from %d old relays",e.length),await Promise.all(e.map(async t=>{await this.peerStore.merge(t.id,{tags:{[Hr]:void 0}})})),this.log("redialing %d old relays",e.length),await Promise.all(e.map(async t=>this.addRelay(t.id,"discovered"))),this.#t()}).catch(e=>{this.log.error(e)})}stop(){this.reserveQueue.clear(),this.reservations.forEach(({timeout:e})=>{clearTimeout(e)}),this.reservations.clear(),this.started=!1}reserveRelay(){const e=o0();return this.pendingReservations.push(e),this.#t(),e}async addRelay(e,t){if(this.peerId.equals(e))throw this.log.trace("not trying to use self as relay"),new Hi("Cannot use self as relay");if(this.reserveQueue.size>this.maxReservationQueueLength)throw new Fb("The reservation queue is full");const r=this.reserveQueue.find(e);if(r!=null)return this.log.trace("potential relay peer %p is already in the reservation queue",e),r.join();if(this.relayFilter.has(e.toMultihash().bytes))throw new Hi("The relay was previously invalid");return this.log.trace("try to reserve relay slot with %p",e),this.reserveQueue.add(async()=>{const s=Date.now();try{const i=this.reservations.get(e);if(i!=null){const g=this.connectionManager.getConnections(e);let m=!1;if(g.length===0&&this.log("already have relay reservation with %p but we are no longer connected",e),g.map(f=>f.id).includes(i.connection)&&(this.log("already have relay reservation with %p and the original connection is still open",e),m=!0),m&&gc(i.reservation.expire)>a0)return this.log("already have relay reservation with %p but we are still connected and it does not expire soon",e),{relay:e,details:i};await this.#n(e)}if(t==="discovered"&&this.pendingReservations.length===0)throw new pc("Not making reservation on discovered relay because we do not need any more relays");const o=AbortSignal.timeout(this.reservationCompletionTimeout);const a=await this.connectionManager.openConnection(e,{signal:o});if(mr.matches(a.remoteAddr))throw new Mb("not creating reservation over relayed connection");const c=await this.#e(a,{signal:o}),u=gc(c.expire);this.log("created reservation on relay peer %p, expiry date is %s",e,new Date(Date.now()+u).toString());const l=Math.min(Math.max(u-c0,l0),Math.pow(2,31)-1),d=setTimeout(()=>{this.log("refresh reservation to relay %p",e),this.addRelay(e,t).catch(async g=>{this.log.error("could not refresh reservation to relay %p - %e",e,g),await this.#n(e)}).catch(g=>{this.log.error("could not remove expired reservation to relay %p - %e",e,g)})},l);let h;if(t==="discovered"){const g=this.pendingReservations.pop();if(g==null)throw new pc("Made reservation on relay but did not need any more discovered relays");h={timeout:d,reservation:c,type:t,connection:a.id,id:g}}else h={timeout:d,reservation:c,type:t,connection:a.id};this.reservations.set(e,h),await this.peerStore.merge(e,{tags:{[Hr]:{value:1,ttl:u}}}),this.#t();const p={relay:e,details:h};return this.safeDispatchEvent("relay:created-reservation",{detail:p}),p}catch(i){throw t==="discovered"&&i.name==="HadEnoughRelaysError"||this.log.error("could not reserve slot on %p after %dms - %e",e,Date.now()-s,i),(i.name==="DialError"||i.name==="UnsupportedProtocolError")&&this.relayFilter.add(e.toMultihash().bytes),this.#n(e).catch(o=>{this.log.error("could not remove reservation on %p after reserving slot failed - %e",e,o)}),i}},{peerId:e})}hasReservation(e){return this.reservations.has(e)}getReservation(e){return this.reservations.get(e)?.reservation}reservationCount(e){return e==null?this.reservations.size:[...this.reservations.values()].reduce((t,r)=>(r.type===e&&t++,t),0)}cancelReservations(){[...this.reservations.values()].forEach(e=>{clearTimeout(e.timeout)}),this.reservations.clear()}async#e(e,t){t.signal?.throwIfAborted(),this.log("requesting reservation from %p",e.remotePeer);const r=await e.newStream(Is,t),i=wt(r).pb(xn);this.log.trace("send RESERVE to %p",e.remotePeer),await i.write({type:xn.Type.RESERVE},t);let o;try{this.log.trace("reading response from %p",e.remotePeer),o=await i.read(t)}catch(c){throw r.abort(c),c}finally{r.status!=="closed"&&await r.close(t)}if(this.log.trace("read response %o",o),o.status===Le.OK&&o.reservation!=null){const c=new Set;c.add(e.remoteAddr.toString());for(const u of o.reservation.addrs){let l=W(u);l.getPeerId()==null&&(l=l.encapsulate(`/p2p/${e.remotePeer}`)),l=W(l.toString().replace(`/p2p/${e.remotePeer}/p2p/${e.remotePeer}`,`/p2p/${e.remotePeer}`)),c.add(l.toString())}return o.reservation.addrs=[...c].map(u=>W(u).bytes),o.reservation}const a=`reservation failed with status ${o.status??"undefined"}`;throw this.log.error(a),new Error(a)}async#n(e){const t=this.reservations.get(e);t!=null&&(this.log("removing relay reservation with %p from local store",e),clearTimeout(t.timeout),this.reservations.delete(e),t.type==="discovered"&&this.pendingReservations.push(t.id),await this.peerStore.merge(e,{tags:{[Hr]:void 0}}),this.safeDispatchEvent("relay:removed",{detail:{relay:e,details:t}}),this.#t())}#t(){if(this.pendingReservations.length===0){this.log.trace("have discovered enough relays"),this.reserveQueue.clear(),this.safeDispatchEvent("relay:found-enough-relays");return}this.relayFilter=yr(100),this.log("not discovered enough relays %d/%d",this.reservations.size,this.pendingReservations.length),this.safeDispatchEvent("relay:not-enough-relays")}}const d0=n=>{if(n.peer==null)return!1;try{n.peer.addrs.forEach(W)}catch{return!1}return!0},Ec={maxInboundStopStreams:lc,maxOutboundStopStreams:lc};class h0{discovery;registrar;peerStore;connectionManager;transportManager;peerId;upgrader;addressManager;connectionGater;reservationStore;logger;maxInboundStopStreams;maxOutboundStopStreams;started;log;shutdownController;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:circuit-relay:transport"),this.registrar=e.registrar,this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.transportManager=e.transportManager,this.logger=e.logger,this.peerId=e.peerId,this.upgrader=e.upgrader,this.addressManager=e.addressManager,this.connectionGater=e.connectionGater,this.maxInboundStopStreams=t.maxInboundStopStreams??Ec.maxInboundStopStreams,this.maxOutboundStopStreams=t.maxOutboundStopStreams??Ec.maxOutboundStopStreams,this.shutdownController=new AbortController,this.discovery=new n0(e,{filter:t.discoveryFilter??Qb(xb,Ab)}),this.discovery.addEventListener("relay:discover",r=>{this.reservationStore.addRelay(r.detail,"discovered").catch(s=>{s.name!=="HadEnoughRelaysError"&&s.name!=="RelayQueueFullError"&&this.log.error("could not add discovered relay %p",r.detail,s)})}),this.reservationStore=new u0(e,t),this.reservationStore.addEventListener("relay:not-enough-relays",()=>{this.discovery?.startDiscovery()}),this.reservationStore.addEventListener("relay:found-enough-relays",()=>{this.discovery?.stopDiscovery()}),this.started=!1}[Symbol.toStringTag]="@libp2p/circuit-relay-v2-transport";[Ye]=["@libp2p/transport","@libp2p/circuit-relay-v2-transport"];get[os](){return this.discovery!=null?["@libp2p/identify"]:[]}[xo]=!0;isStarted(){return this.started}async start(){this.shutdownController=new AbortController,this.shutdownController.signal,await this.registrar.handle(cc,e=>{const t=this.upgrader.createInboundAbortSignal(this.shutdownController.signal);this.onStop(e,t).catch(r=>{this.log.error("error while handling STOP protocol",r),e.stream.abort(r)}).finally(()=>{t.clear()})},{maxInboundStreams:this.maxInboundStopStreams,maxOutboundStreams:this.maxOutboundStopStreams,runOnLimitedConnection:!0}),await vl(this.discovery,this.reservationStore),this.started=!0}async stop(){this.shutdownController.abort(),await Sl(this.discovery,this.reservationStore),await this.registrar.unhandle(cc),this.started=!1}async dial(e,t){if(e.protoCodes().filter(p=>p===Eb).length!==1){const p="Invalid circuit relay address";throw this.log.error(p,e),new jn(p)}const r=e.toString().split("/p2p-circuit"),s=W(r[0]),i=W(r[r.length-1]),o=s.getPeerId(),a=i.getPeerId();if(o==null||a==null){const p=`ircuit relay dial to ${e.toString()} failed as address did not have both relay and destination PeerIDs`;throw this.log.error(`c${p}`),new jn(`C${p}`)}const c=yt(o),u=yt(a);let d=this.connectionManager.getConnections(c)[0];d==null?(await this.peerStore.merge(c,{multiaddrs:[s]}),t.onProgress?.(new ee("circuit-relay:open-connection")),d=await this.connectionManager.openConnection(c,t)):t.onProgress?.(new ee("circuit-relay:reuse-connection"));let h;try{t.onProgress?.(new ee("circuit-relay:open-hop-stream")),h=await d.newStream(Is,t);const p=wt(h),g=p.pb(xn);t.onProgress?.(new ee("circuit-relay:write-connect-message")),await g.write({type:xn.Type.CONNECT,peer:{id:u.toMultihash().bytes,addrs:[W(i).bytes]}},t),t.onProgress?.(new ee("circuit-relay:read-connect-response"));const m=await g.read(t);if(m.status!==Le.OK)throw new Je(`failed to connect via relay with status ${m?.status?.toString()??"undefined"}`);const f=new mc(m.limit),w=wc({stream:p.unwrap(),remoteAddr:e,localAddr:s.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`),logger:this.logger,onDataRead:f.onData,onDataWrite:f.onData});return this.log("new outbound relayed connection %a",w.remoteAddr),await this.upgrader.upgradeOutbound(w,{...t,limits:f.getLimits()})}catch(p){throw this.log.error("circuit relay dial to destination %p via relay %p failed",u,c,p),h?.abort(p),p}}createListener(e){return s0({peerId:this.peerId,connectionManager:this.connectionManager,addressManager:this.addressManager,reservationStore:this.reservationStore,logger:this.logger})}listenFilter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>md.exactMatch(t)||yd.exactMatch(t))}dialFilter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>mr.exactMatch(t))}async onStop({connection:e,stream:t},r){if(!this.reservationStore.hasReservation(e.remotePeer))try{this.log("dialed via relay we did not have a reservation on, start listening on that relay address"),await this.transportManager.listen([e.remoteAddr.encapsulate("/p2p-circuit")])}catch(l){this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on",l)}const s=wt(t).pb(ut),i=await s.read({signal:r});if(this.log("new circuit relay v2 stop stream from %p with type %s",e.remotePeer,i.type),i?.type===void 0){this.log.error("type was missing from circuit v2 stop protocol request from %s",e.remotePeer),await s.write({type:ut.Type.STATUS,status:Le.MALFORMED_MESSAGE},{signal:r}),await t.close();return}if(i.type!==ut.Type.CONNECT){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await s.write({type:ut.Type.STATUS,status:Le.UNEXPECTED_MESSAGE},{signal:r}),await t.close();return}if(!d0(i)){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await s.write({type:ut.Type.STATUS,status:Le.MALFORMED_MESSAGE},{signal:r}),await t.close({signal:r});return}const o=_r(Er(i.peer.id));if(await this.connectionGater.denyInboundRelayedConnection?.(e.remotePeer,o)===!0){this.log.error("connection gater denied inbound relayed connection from %p",e.remotePeer),await s.write({type:ut.Type.STATUS,status:Le.PERMISSION_DENIED},{signal:r}),await t.close({signal:r});return}this.log.trace("sending success response to %p",e.remotePeer),await s.write({type:ut.Type.STATUS,status:Le.OK},{signal:r});const a=new mc(i.limit),c=e.remoteAddr.encapsulate(`/p2p-circuit/p2p/${o.toString()}`);this.addressManager.getAddresses()[0];const u=wc({stream:s.unwrap().unwrap(),remoteAddr:c,logger:this.logger,onDataRead:a.onData,onDataWrite:a.onData});this.log("new inbound relayed connection %a",u.remoteAddr),await this.upgrader.upgradeInbound(u,{limits:a.getLimits(),signal:r}),this.log("%s connection %a upgraded","inbound",u.remoteAddr)}}function f0(n={}){return e=>new h0(e,n)}function p0(n){return n[Symbol.asyncIterator]!=null}function go(n){if(p0(n))return(async()=>{for await(const e of n);})();for(const e of n);}const Qr=globalThis.CustomEvent??Event;async function*xd(n,e={}){let t=e.concurrency??1/0;t<1&&(t=1/0);const r=e.ordered??!1,s=new EventTarget,i=[];let o=z(),a=z(),c=!1,u,l=!1;s.addEventListener("task-complete",()=>{a.resolve()}),Promise.resolve().then(async()=>{try{for await(const g of n){if(i.length===t&&(o=z(),await o.promise),l)break;const m={done:!1};i.push(m),g().then(f=>{m.done=!0,m.ok=!0,m.value=f,s.dispatchEvent(new Qr("task-complete"))},f=>{m.done=!0,m.err=f,s.dispatchEvent(new Qr("task-complete"))})}c=!0,s.dispatchEvent(new Qr("task-complete"))}catch(g){u=g,s.dispatchEvent(new Qr("task-complete"))}});function d(){return r?i[0]?.done:!!i.find(g=>g.done)}function*h(){for(;i.length>0&&i[0].done;){const g=i[0];if(i.shift(),g.ok)yield g.value;else throw l=!0,o.resolve(),g.err;o.resolve()}}function*p(){for(;d();)for(let g=0;g<i.length;g++)if(i[g].done){const m=i[g];if(i.splice(g,1),g--,m.ok)yield m.value;else throw l=!0,o.resolve(),m.err;o.resolve()}}for(;;){if(d()||(a=z(),await a.promise),u!=null||(r?yield*h():yield*p(),u!=null))throw u;if(c&&i.length===0)break}}const g0="0.1.0",m0="id",y0="id/push",w0="1.0.0",b0="1.0.0",E0=1024*8,v0=32,S0=1e3;var In;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.protocolVersion!=null&&(r.uint32(42),r.string(t.protocolVersion)),t.agentVersion!=null&&(r.uint32(50),r.string(t.agentVersion)),t.publicKey!=null&&(r.uint32(10),r.bytes(t.publicKey)),t.listenAddrs!=null)for(const i of t.listenAddrs)r.uint32(18),r.bytes(i);if(t.observedAddr!=null&&(r.uint32(34),r.bytes(t.observedAddr)),t.protocols!=null)for(const i of t.protocols)r.uint32(26),r.string(i);t.signedPeerRecord!=null&&(r.uint32(66),r.bytes(t.signedPeerRecord)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={listenAddrs:[],protocols:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 5:{i.protocolVersion=t.string();break}case 6:{i.agentVersion=t.string();break}case 1:{i.publicKey=t.bytes();break}case 2:{if(s.limits?.listenAddrs!=null&&i.listenAddrs.length===s.limits.listenAddrs)throw new mt('Decode error - map field "listenAddrs" had too many elements');i.listenAddrs.push(t.bytes());break}case 4:{i.observedAddr=t.bytes();break}case 3:{if(s.limits?.protocols!=null&&i.protocols.length===s.limits.protocols)throw new mt('Decode error - map field "protocols" had too many elements');i.protocols.push(t.string());break}case 8:{i.signedPeerRecord=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(In||(In={}));const qe={protocolPrefix:"ipfs",timeout:5e3,maxInboundStreams:1,maxOutboundStreams:1,maxObservedAddresses:10,maxMessageSize:E0,runOnConnectionOpen:!0,runOnSelfUpdate:!0,runOnLimitedConnection:!0,concurrency:v0};function x0(n){if(n!=null&&n.length>0)try{return W(n)}catch{}}function A0(n,e){return e??n.userAgent}async function Ad(n,e,t,r,s){if(t("received identify from %p",r.remotePeer),s==null)throw new Je("message was null or undefined");const i={};if(s.listenAddrs.length>0&&(i.addresses=s.listenAddrs.map(c=>({isCertified:!1,multiaddr:W(c)}))),s.protocols.length>0&&(i.protocols=s.protocols),s.publicKey!=null){const c=Pt(s.publicKey);if(!lr(c).equals(r.remotePeer))throw new Je("public key did not match remote PeerId");i.publicKey=c}let o;if(s.signedPeerRecord!=null){t.trace("received signedPeerRecord from %p",r.remotePeer);let c=s.signedPeerRecord;const u=await et.openAndCertify(c,$e.DOMAIN);let l=$e.createFromProtobuf(u.payload);const d=Cr(u.publicKey.toCID());if(!l.peerId.equals(d))throw new Je("signing key does not match PeerId in the PeerRecord");if(!r.remotePeer.equals(l.peerId))throw new Je("signing key does not match remote PeerId");let h;try{h=await n.get(l.peerId)}catch(p){if(p.name!=="NotFoundError")throw p}if(h!=null&&(i.metadata=h.metadata,h.peerRecordEnvelope!=null)){const p=et.createFromProtobuf(h.peerRecordEnvelope),g=$e.createFromProtobuf(p.payload);g.seqNumber>=l.seqNumber&&(t("sequence number was lower or equal to existing sequence number - stored: %d received: %d",g.seqNumber,l.seqNumber),l=g,c=h.peerRecordEnvelope)}i.peerRecordEnvelope=c,i.addresses=l.multiaddrs.map(p=>({isCertified:!0,multiaddr:p})),o={seq:l.seqNumber,addresses:l.multiaddrs}}else t("%p did not send a signed peer record",r.remotePeer);if(t.trace("patching %p with",r.remotePeer,i),await n.patch(r.remotePeer,i),s.agentVersion!=null||s.protocolVersion!=null){const c={};s.agentVersion!=null&&(c.AgentVersion=$(s.agentVersion)),s.protocolVersion!=null&&(c.ProtocolVersion=$(s.protocolVersion)),t.trace("merging %p metadata",r.remotePeer,c),await n.merge(r.remotePeer,{metadata:c})}const a={peerId:r.remotePeer,protocolVersion:s.protocolVersion,agentVersion:s.agentVersion,publicKey:s.publicKey,listenAddrs:s.listenAddrs.map(c=>W(c)),observedAddr:s.observedAddr==null?void 0:W(s.observedAddr),protocols:s.protocols,signedPeerRecord:o,connection:r};return e.safeDispatchEvent("peer:identify",{detail:a}),a}class _d{host;protocol;started;timeout;peerId;privateKey;peerStore;registrar;addressManager;maxInboundStreams;maxOutboundStreams;maxMessageSize;maxObservedAddresses;events;runOnLimitedConnection;log;constructor(e,t){this.protocol=t.protocol,this.started=!1,this.peerId=e.peerId,this.privateKey=e.privateKey,this.peerStore=e.peerStore,this.registrar=e.registrar,this.addressManager=e.addressManager,this.events=e.events,this.log=t.log,this.timeout=t.timeout??qe.timeout,this.maxInboundStreams=t.maxInboundStreams??qe.maxInboundStreams,this.maxOutboundStreams=t.maxOutboundStreams??qe.maxOutboundStreams,this.maxMessageSize=t.maxMessageSize??qe.maxMessageSize,this.maxObservedAddresses=t.maxObservedAddresses??qe.maxObservedAddresses,this.runOnLimitedConnection=t.runOnLimitedConnection??qe.runOnLimitedConnection,this.host={protocolVersion:`${t.protocolPrefix??qe.protocolPrefix}/${g0}`,agentVersion:A0(e.nodeInfo,t.agentVersion)}}isStarted(){return this.started}async start(){this.started||(await this.peerStore.merge(this.peerId,{metadata:{AgentVersion:$(this.host.agentVersion),ProtocolVersion:$(this.host.protocolVersion)}}),await this.registrar.handle(this.protocol,e=>{this.handleProtocol(e).catch(t=>{this.log.error(t)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0)}async stop(){await this.registrar.unhandle(this.protocol),this.started=!1}}class _0 extends _d{connectionManager;concurrency;_push;constructor(e,t={}){super(e,{...t,protocol:`/${t.protocolPrefix??qe.protocolPrefix}/${y0}/${b0}`,log:e.logger.forComponent("libp2p:identify-push")}),this.connectionManager=e.connectionManager,this.concurrency=t.concurrency??qe.concurrency,this._push=Os(this.sendPushMessage.bind(this),t.debounce??S0),(t.runOnSelfUpdate??qe.runOnSelfUpdate)&&e.events.addEventListener("self:peer:update",r=>{this.push().catch(s=>{this.log.error("error pushing updates to peers - %e",s)})})}[Ye]=["@libp2p/identify-push"];async push(){this._push()}async sendPushMessage(){if(this.isStarted())try{const e=this.addressManager.getAddresses().map(l=>l.decapsulateCode(Lr("p2p").code)),t=new $e({peerId:this.peerId,multiaddrs:e}),r=await et.seal(t,this.privateKey),s=this.registrar.getProtocols(),i=await this.peerStore.get(this.peerId),o=q(i.metadata.get("AgentVersion")??$(this.host.agentVersion)),a=q(i.metadata.get("ProtocolVersion")??$(this.host.protocolVersion)),c=this;async function*u(){for(const l of c.connectionManager.getConnections())(await c.peerStore.get(l.remotePeer)).protocols.includes(c.protocol)&&(yield async()=>{let h;const p=AbortSignal.timeout(c.timeout);try{h=await l.newStream(c.protocol,{signal:p,runOnLimitedConnection:c.runOnLimitedConnection}),await wt(h,{maxDataLength:c.maxMessageSize}).pb(In).write({listenAddrs:e.map(m=>m.bytes),signedPeerRecord:r.marshal(),protocols:s,agentVersion:o,protocolVersion:a},{signal:p}),await h.close({signal:p})}catch(g){c.log.error("could not push identify update to peer",g),h?.abort(g)}})}await go(xd(u(),{concurrency:this.concurrency}))}catch(e){this.log.error("error pushing updates to peers - %e",e)}}async handleProtocol(e){const{connection:t,stream:r}=e;try{if(this.peerId.equals(t.remotePeer))throw new Error("received push from ourselves?");const s={signal:AbortSignal.timeout(this.timeout)},o=await wt(r,{maxDataLength:this.maxMessageSize}).pb(In).read(s);await r.close(s),await Ad(this.peerStore,this.events,this.log,t,o)}catch(s){this.log.error("received invalid message",s),r.abort(s);return}this.log.trace("handled push from %p",t.remotePeer)}}function C0(n){try{for(const{code:e,value:t}of n.getComponents())if(t!=null&&e===Ke)return gb("2000::/3",t)}catch{}return!1}function ia(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var tn={},vc;function I0(){return vc||(vc=1,function(){var n,e,t,r,s,i,o,a;a=function(c){var u,l,d,h;return u=(c&255<<24)>>>24,l=(c&255<<16)>>>16,d=(c&65280)>>>8,h=c&255,[u,l,d,h].join(".")},o=function(c){var u,l,d,h,p,g;for(u=[],d=h=0;h<=3&&c.length!==0;d=++h){if(d>0){if(c[0]!==".")throw new Error("Invalid IP");c=c.substring(1)}g=e(c),p=g[0],l=g[1],c=c.substring(l),u.push(p)}if(c.length!==0)throw new Error("Invalid IP");switch(u.length){case 1:if(u[0]>4294967295)throw new Error("Invalid IP");return u[0]>>>0;case 2:if(u[0]>255||u[1]>16777215)throw new Error("Invalid IP");return(u[0]<<24|u[1])>>>0;case 3:if(u[0]>255||u[1]>255||u[2]>65535)throw new Error("Invalid IP");return(u[0]<<24|u[1]<<16|u[2])>>>0;case 4:if(u[0]>255||u[1]>255||u[2]>255||u[3]>255)throw new Error("Invalid IP");return(u[0]<<24|u[1]<<16|u[2]<<8|u[3])>>>0;default:throw new Error("Invalid IP")}},t=function(c){return c.charCodeAt(0)},r=t("0"),i=t("a"),s=t("A"),e=function(c){var u,l,d,h,p;for(h=0,u=10,l="9",d=0,c.length>1&&c[d]==="0"&&(c[d+1]==="x"||c[d+1]==="X"?(d+=2,u=16):"0"<=c[d+1]&&c[d+1]<="9"&&(d++,u=8,l="7")),p=d;d<c.length;){if("0"<=c[d]&&c[d]<=l)h=h*u+(t(c[d])-r)>>>0;else if(u===16)if("a"<=c[d]&&c[d]<="f")h=h*u+(10+t(c[d])-i)>>>0;else if("A"<=c[d]&&c[d]<="F")h=h*u+(10+t(c[d])-s)>>>0;else break;else break;if(h>4294967295)throw new Error("too large");d++}if(d===p)throw new Error("empty octet");return[h,d]},n=function(){function c(u,l){var d,h,p;if(typeof u!="string")throw new Error("Missing `net' parameter");if(l||(p=u.split("/",2),u=p[0],l=p[1]),l||(l=32),typeof l=="string"&&l.indexOf(".")>-1){try{this.maskLong=o(l)}catch{throw new Error("Invalid mask: "+l)}for(d=h=32;h>=0;d=--h)if(this.maskLong===4294967295<<32-d>>>0){this.bitmask=d;break}}else if(l||l===0)this.bitmask=parseInt(l,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(o(u)&this.maskLong)>>>0}catch{throw new Error("Invalid net address: "+u)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+l);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return c.prototype.contains=function(u){return typeof u=="string"&&(u.indexOf("/")>0||u.split(".").length!==4)&&(u=new c(u)),u instanceof c?this.contains(u.base)&&this.contains(u.broadcast||u.last):(o(u)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},c.prototype.next=function(u){return u==null&&(u=1),new c(a(this.netLong+this.size*u),this.mask)},c.prototype.forEach=function(u){var l,d,h;for(h=o(this.first),d=o(this.last),l=0;h<=d;)u(a(h),h,l),l++,h++},c.prototype.toString=function(){return this.base+"/"+this.bitmask},c}(),tn.ip2long=o,tn.long2ip=a,tn.Netmask=n}.call(tn)),tn}var T0=I0();const P0=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"],D0=P0.map(n=>new T0.Netmask(n));function oa(n){for(const e of D0)if(e.contains(n))return!0;return!1}function L0(n){return/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(n)}function k0(n){const e=n.split(":");if(e.length<2)return!1;const t=e[e.length-1].padStart(4,"0"),r=e[e.length-2].padStart(4,"0"),s=`${parseInt(r.substring(0,2),16)}.${parseInt(r.substring(2),16)}.${parseInt(t.substring(0,2),16)}.${parseInt(t.substring(2),16)}`;return oa(s)}function R0(n){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(n)}function N0(n){const e=n.split(":"),t=e[e.length-1];return oa(t)}function O0(n){return/^::$/.test(n)||/^::1$/.test(n)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(n)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(n)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(n)||/^ff([0-9a-fA-F]{2,2}):/i.test(n)}function ti(n){if(Sn(n))return oa(n);if(L0(n))return k0(n);if(R0(n))return N0(n);if(Qu(n))return O0(n)}function Cd(n){try{for(const{code:e}of n.getComponents())if(e!==Qt)return e===Vt||e===Ke}catch{}return!1}function wr(n){try{if(!Cd(n))return!1;const[[,e]]=n.stringTuples();return e==null?!1:ti(e)??!1}catch{}return!0}class M0 extends _d{constructor(e,t={}){super(e,{...t,protocol:`/${t.protocolPrefix??qe.protocolPrefix}/${m0}/${w0}`,log:e.logger.forComponent("libp2p:identify")}),(t.runOnConnectionOpen??qe.runOnConnectionOpen)&&e.events.addEventListener("connection:open",r=>{const s=r.detail;this.identify(s).catch(i=>{i.name!==_o.name&&this.log.error("error during identify trigged by connection:open",i)})})}[Ye]=["@libp2p/identify"];async _identify(e,t={}){let r;if(t.signal==null){const s=AbortSignal.timeout(this.timeout);t={...t,signal:s}}try{r=await e.newStream(this.protocol,{...t,runOnLimitedConnection:this.runOnLimitedConnection});const i=await wt(r,{maxDataLength:this.maxMessageSize}).pb(In).read(t);return await r.close(t),i}catch(s){throw r?.abort(s),s}}async identify(e,t={}){const r=await this._identify(e,t),{publicKey:s,protocols:i,observedAddr:o}=r;if(s==null)throw new Je("public key was missing from identify message");const a=Pt(s),c=Cr(a.toCID());if(!e.remotePeer.equals(c))throw new Je("identified peer does not match the expected peer");if(this.peerId.equals(c))throw new Je("identified peer is our own peer id?");return this.maybeAddObservedAddress(o),this.log("identify completed for peer %p and protocols %o",c,i),Ad(this.peerStore,this.events,this.log,e,r)}maybeAddObservedAddress(e){const t=x0(e);if(t==null)return;if(this.log.trace("our observed address was %a",t),wr(t)){this.log.trace("our observed address was private");return}const r=t.getComponents();if((r[0].code===Ke||r[0].code===Qt&&r[1].code===Ke)&&!C0(t)){this.log.trace("our observed address was IPv6 but not a global unicast address");return}Ls.exactMatch(t)||(this.log.trace("storing the observed address"),this.addressManager.addObservedAddr(t))}async handleProtocol(e){const{connection:t,stream:r}=e,s=AbortSignal.timeout(this.timeout);try{const i=await this.peerStore.get(this.peerId),o=this.addressManager.getAddresses().map(l=>l.decapsulateCode(Lr("p2p").code));let a=i.peerRecordEnvelope;if(o.length>0&&a==null){const l=new $e({peerId:this.peerId,multiaddrs:o});a=(await et.seal(l,this.privateKey)).marshal().subarray()}let c=t.remoteAddr.bytes;Ib.matches(t.remoteAddr)||(c=void 0),await wt(r).pb(In).write({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:ft(this.privateKey.publicKey),listenAddrs:o.map(l=>l.bytes),signedPeerRecord:a,observedAddr:c,protocols:i.protocols},{signal:s}),await r.close({signal:s})}catch(i){this.log.error("could not respond to identify request",i),r.abort(i)}}}function F0(n={}){return e=>new M0(e,n)}function U0(n={}){return e=>new _0(e,n)}let B0=class{readNext;haveNext;ended;nextResult;error;constructor(){this.ended=!1,this.readNext=z(),this.haveNext=z()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=z(),e}async throw(e){return this.ended=!0,this.error=e,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=z(),await ie(this.readNext.promise,t?.signal,t)}};function $0(){return new B0}let q0=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};function Sc(n,e){const t=$0();n.sink(t).catch(async o=>{await t.end(o)}),n.sink=async o=>{for await(const a of o)await t.push(a);await t.end()};let r=n.source;n.source[Symbol.iterator]!=null?r=n.source[Symbol.iterator]():n.source[Symbol.asyncIterator]!=null&&(r=n.source[Symbol.asyncIterator]());const s=new H;return{read:async o=>{if(o?.signal?.throwIfAborted(),o?.bytes==null){const{done:c,value:u}=await ie(r.next(),o?.signal);return c===!0?null:u}for(;s.byteLength<o.bytes;){const{value:c,done:u}=await ie(r.next(),o?.signal);if(u===!0)throw new q0("unexpected end of input");s.append(c)}const a=s.sublist(0,o.bytes);return s.consume(o.bytes),a},write:async(o,a)=>{a?.signal?.throwIfAborted(),o instanceof Uint8Array?await t.push(o,a):await t.push(o.subarray(),a)},unwrap:()=>{if(s.byteLength>0){const o=n.source;n.source=async function*(){yield*s,yield*o}()}return n}}}const _i=32,z0="1.0.0",K0="ping",W0="ipfs",V0=1e4,H0=2,G0=1;class Q0{protocol;components;started;timeout;maxInboundStreams;maxOutboundStreams;runOnLimitedConnection;log;constructor(e,t={}){this.components=e,this.log=e.logger.forComponent("libp2p:ping"),this.started=!1,this.protocol=`/${t.protocolPrefix??W0}/${K0}/${z0}`,this.timeout=t.timeout??V0,this.maxInboundStreams=t.maxInboundStreams??H0,this.maxOutboundStreams=t.maxOutboundStreams??G0,this.runOnLimitedConnection=t.runOnLimitedConnection??!0,this.handleMessage=this.handleMessage.bind(this)}[Symbol.toStringTag]="@libp2p/ping";[Ye]=["@libp2p/ping"];async start(){await this.components.registrar.handle(this.protocol,this.handleMessage,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}isStarted(){return this.started}handleMessage(e){this.log("incoming ping from %p",e.connection.remotePeer);const{stream:t}=e,r=Date.now(),s=Sc(t);let i=!1;Promise.resolve().then(async()=>{for(;;){const o=AbortSignal.timeout(this.timeout);o.addEventListener("abort",()=>{t?.abort(new Co("ping timeout"))});const a=await s.read({bytes:_i,signal:o});await s.write(a,{signal:o}),i=!0}}).catch(o=>{i&&o.name==="UnexpectedEOFError"&&t.readStatus!=="ready"||(this.log.error("incoming ping from %p failed with error - %e",e.connection.remotePeer,o),t?.abort(o))}).finally(()=>{const o=Date.now()-r;this.log("incoming ping from %p complete in %dms",e.connection.remotePeer,o);const a=AbortSignal.timeout(this.timeout);t.close({signal:a}).catch(c=>{this.log.error("error closing ping stream from %p - %e",e.connection.remotePeer,c),t?.abort(c)})})}async ping(e,t={}){this.log("pinging %p",e);const r=Date.now(),s=Vo(_i),i=await this.components.connectionManager.openConnection(e,t);let o;if(t.signal==null){const a=AbortSignal.timeout(this.timeout);t={...t,signal:a}}try{o=await i.newStream(this.protocol,{...t,runOnLimitedConnection:this.runOnLimitedConnection});const a=Sc(o),[,c]=await Promise.all([a.write(s,t),a.read({...t,bytes:_i})]),u=Date.now()-r;if(!Te(s,c.subarray()))throw new Mh(`Received wrong ping ack after ${u}ms`);return this.log("ping %p complete in %dms",i.remotePeer,u),u}catch(a){throw this.log.error("error while pinging %p",i.remotePeer,a),o?.abort(a),a}finally{o!=null&&await o.close(t)}}}function Y0(n={}){return e=>new Q0(e,n)}var Ne;(function(n){(function(r){r.FIN="FIN",r.STOP_SENDING="STOP_SENDING",r.RESET="RESET",r.FIN_ACK="FIN_ACK"})(n.Flag||(n.Flag={}));let e;(function(r){r[r.FIN=0]="FIN",r[r.STOP_SENDING=1]="STOP_SENDING",r[r.RESET=2]="RESET",r[r.FIN_ACK=3]="FIN_ACK"})(e||(e={})),function(r){r.codec=()=>Nn(e)}(n.Flag||(n.Flag={}));let t;n.codec=()=>(t==null&&(t=fe((r,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),r.flag!=null&&(s.uint32(8),n.Flag.codec().encode(r.flag,s)),r.message!=null&&(s.uint32(18),s.bytes(r.message)),i.lengthDelimited!==!1&&s.ldelim()},(r,s,i={})=>{const o={},a=s==null?r.len:r.pos+s;for(;r.pos<a;){const c=r.uint32();switch(c>>>3){case 1:{o.flag=n.Flag.codec().decode(r);break}case 2:{o.message=r.bytes();break}default:{r.skipType(c&7);break}}}return o})),t),n.encode=r=>he(r,n.codec()),n.decode=(r,s)=>de(r,n.codec(),s)})(Ne||(Ne={}));const X0=["stun:stun.l.google.com:19302","stun:global.stun.twilio.com:3478","stun:stun.cloudflare.com:3478","stun:stun.services.mozilla.com:3478"];Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890");const Z0=2*1024*1024,j0=30*1e3,Id=16*1024;function J0(n=Id){const e=Ie(n-Ie(n)),t=1+Ie(Object.keys(Ne.Flag).length-1),r=1,s=n-e-t-r,i=Ie(s);return e+t+r+i}const eE=J0(),tE=5e3,nE=5e3,rE=3e4,Td="/webrtc",mo="/webrtc-signaling/0.0.1";var xc=function(n,e,t){if(t||arguments.length===2)for(var r=0,s=e.length,i;r<s;r++)(i||!(r in e))&&(i||(i=Array.prototype.slice.call(e,0,r)),i[r]=e[r]);return n.concat(i||Array.prototype.slice.call(e))},sE=function(){function n(e,t,r){this.name=e,this.version=t,this.os=r,this.type="browser"}return n}(),iE=function(){function n(e){this.version=e,this.type="node",this.name="node",this.os=process.platform}return n}(),oE=function(){function n(e,t,r,s){this.name=e,this.version=t,this.os=r,this.bot=s,this.type="bot-device"}return n}(),aE=function(){function n(){this.type="bot",this.bot=!0,this.name="bot",this.version=null,this.os=null}return n}(),cE=function(){function n(){this.type="react-native",this.name="react-native",this.version=null,this.os=null}return n}(),lE=/alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,uE=/(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,Ac=3,dE=[["aol",/AOLShield\/([0-9\._]+)/],["edge",/Edge\/([0-9\._]+)/],["edge-ios",/EdgiOS\/([0-9\._]+)/],["yandexbrowser",/YaBrowser\/([0-9\._]+)/],["kakaotalk",/KAKAOTALK\s([0-9\.]+)/],["samsung",/SamsungBrowser\/([0-9\.]+)/],["silk",/\bSilk\/([0-9._-]+)\b/],["miui",/MiuiBrowser\/([0-9\.]+)$/],["beaker",/BeakerBrowser\/([0-9\.]+)/],["edge-chromium",/EdgA?\/([0-9\.]+)/],["chromium-webview",/(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["chrome",/(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["phantomjs",/PhantomJS\/([0-9\.]+)(:?\s|$)/],["crios",/CriOS\/([0-9\.]+)(:?\s|$)/],["firefox",/Firefox\/([0-9\.]+)(?:\s|$)/],["fxios",/FxiOS\/([0-9\.]+)/],["opera-mini",/Opera Mini.*Version\/([0-9\.]+)/],["opera",/Opera\/([0-9\.]+)(?:\s|$)/],["opera",/OPR\/([0-9\.]+)(:?\s|$)/],["pie",/^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],["pie",/^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],["netfront",/^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],["ie",/Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],["ie",/MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],["ie",/MSIE\s(7\.0)/],["bb10",/BB10;\sTouch.*Version\/([0-9\.]+)/],["android",/Android\s([0-9\.]+)/],["ios",/Version\/([0-9\._]+).*Mobile.*Safari.*/],["safari",/Version\/([0-9\._]+).*Safari/],["facebook",/FB[AS]V\/([0-9\.]+)/],["instagram",/Instagram\s([0-9\.]+)/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Mobile/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Gecko\)$/],["curl",/^curl\/([0-9\.]+)$/],["searchbot",lE]],_c=[["iOS",/iP(hone|od|ad)/],["Android OS",/Android/],["BlackBerry OS",/BlackBerry|BB10/],["Windows Mobile",/IEMobile/],["Amazon OS",/Kindle/],["Windows 3.11",/Win16/],["Windows 95",/(Windows 95)|(Win95)|(Windows_95)/],["Windows 98",/(Windows 98)|(Win98)/],["Windows 2000",/(Windows NT 5.0)|(Windows 2000)/],["Windows XP",/(Windows NT 5.1)|(Windows XP)/],["Windows Server 2003",/(Windows NT 5.2)/],["Windows Vista",/(Windows NT 6.0)/],["Windows 7",/(Windows NT 6.1)/],["Windows 8",/(Windows NT 6.2)/],["Windows 8.1",/(Windows NT 6.3)/],["Windows 10",/(Windows NT 10.0)/],["Windows ME",/Windows ME/],["Windows CE",/Windows CE|WinCE|Microsoft Pocket Internet Explorer/],["Open BSD",/OpenBSD/],["Sun OS",/SunOS/],["Chrome OS",/CrOS/],["Linux",/(Linux)|(X11)/],["Mac OS",/(Mac_PowerPC)|(Macintosh)/],["QNX",/QNX/],["BeOS",/BeOS/],["OS/2",/OS\/2/]];function hE(n){return typeof document>"u"&&typeof navigator<"u"&&navigator.product==="ReactNative"?new cE:typeof navigator<"u"?pE(navigator.userAgent):mE()}function fE(n){return n!==""&&dE.reduce(function(e,t){var r=t[0],s=t[1];if(e)return e;var i=s.exec(n);return!!i&&[r,i]},!1)}function pE(n){var e=fE(n);if(!e)return null;var t=e[0],r=e[1];if(t==="searchbot")return new aE;var s=r[1]&&r[1].split(".").join("_").split("_").slice(0,3);s?s.length<Ac&&(s=xc(xc([],s,!0),yE(Ac-s.length),!0)):s=[];var i=s.join("."),o=gE(n),a=uE.exec(n);return a&&a[1]?new oE(t,i,o,a[1]):new sE(t,i,o)}function gE(n){for(var e=0,t=_c.length;e<t;e++){var r=_c[e],s=r[0],i=r[1],o=i.exec(n);if(o)return s}return null}function mE(){var n=typeof process<"u"&&process.version;return n?new iE(process.version.slice(1)):null}function yE(n){for(var e=[],t=0;t<n;t++)e.push("0");return e}class Pd extends Error{constructor(e){super(e),this.name="TimeoutError"}}let wE=class extends Error{constructor(e){super(),this.name="AbortError",this.message=e}};const Cc=n=>globalThis.DOMException===void 0?new wE(n):new DOMException(n),Ic=n=>{const e=n.reason===void 0?Cc("This operation was aborted."):n.reason;return e instanceof Error?e:Cc(e)};function aa(n,e){const{milliseconds:t,fallback:r,message:s,customTimers:i={setTimeout,clearTimeout}}=e;let o,a;const u=new Promise((l,d)=>{if(typeof t!="number"||Math.sign(t)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${t}\``);if(e.signal){const{signal:p}=e;p.aborted&&d(Ic(p)),a=()=>{d(Ic(p))},p.addEventListener("abort",a,{once:!0})}if(t===Number.POSITIVE_INFINITY){n.then(l,d);return}const h=new Pd;o=i.setTimeout.call(void 0,()=>{if(r){try{l(r())}catch(p){d(p)}return}typeof n.cancel=="function"&&n.cancel(),s===!1?l():s instanceof Error?d(s):(h.message=s??`Promise timed out after ${t} milliseconds`,d(h))},t),(async()=>{try{l(await n)}catch(p){d(p)}})()}).finally(()=>{u.clear(),a&&e.signal&&e.signal.removeEventListener("abort",a)});return u.clear=()=>{i.clearTimeout.call(void 0,o),o=void 0},u}const Tc=hE(),Dd=Tc!=null&&Tc.name==="firefox",Ld=async function*(){},kd=async n=>{};function bE(n,e,t=rE,r){n.readyState==="open"&&Promise.resolve().then(async()=>{if(n.bufferedAmount>0){r.log("%s drain channel with %d buffered bytes",e,n.bufferedAmount);const s=z();let i=!1;n.bufferedAmountLowThreshold=0;const o=()=>{i||(r.log("%s drain channel closed before drain",e),s.resolve())};n.addEventListener("close",o,{once:!0}),n.addEventListener("bufferedamountlow",()=>{i=!0,n.removeEventListener("close",o),s.resolve()}),await aa(s.promise,{milliseconds:t})}}).then(async()=>{n.readyState==="open"&&n.close()}).catch(s=>{r.log.error("error closing outbound stream",s)})}async function Pc(n){return n=n??{},typeof n=="function"&&(n=await n()),n.iceServers=n.iceServers??X0.map(e=>({urls:[e]})),n}class Dc{log;peerConnection;remoteAddr;timeline;metrics;source=Ld();sink=kd;constructor(e,t){this.log=e.logger.forComponent("libp2p:webrtc:maconn"),this.remoteAddr=t.remoteAddr,this.timeline=t.timeline,this.peerConnection=t.peerConnection;const r=this.peerConnection,s=r.connectionState;this.peerConnection.onconnectionstatechange=()=>{this.log.trace("peer connection state change",r.connectionState,"initial state",s),(r.connectionState==="disconnected"||r.connectionState==="failed"||r.connectionState==="closed")&&(this.timeline.close=Date.now())}}async close(e){this.log.trace("closing connection"),this.peerConnection.close(),this.timeline.close=Date.now(),this.metrics?.increment({close:!0})}abort(e){this.log.error("closing connection due to error",e),this.peerConnection.close(),this.timeline.close=Date.now(),this.metrics?.increment({abort:!0})}}class EE extends qu{channel;incomingData;maxBufferedAmount;bufferedAmountLowEventTimeout;maxMessageSize;receiveFinAck;finAckTimeout;openTimeout;closeController;constructor(e){const t=e.onEnd;switch(e.onEnd=s=>{this.log.trace('readable and writeable ends closed with status "%s"',this.status),Promise.resolve(async()=>{if(!(this.timeline.abort!=null||this.timeline.reset!==null))try{await aa(this.receiveFinAck.promise,{milliseconds:this.finAckTimeout})}catch(i){this.log.error("error receiving FIN_ACK",i)}}).then(()=>{this.incomingData.end(),t?.(s)}).catch(i=>{this.log.error("error ending stream",i)}).finally(()=>{this.channel.close()})},super(e),this.channel=e.channel,this.channel.binaryType="arraybuffer",this.incomingData=On(),this.bufferedAmountLowEventTimeout=e.bufferedAmountLowEventTimeout??j0,this.maxBufferedAmount=e.maxBufferedAmount??Z0,this.maxMessageSize=(e.maxMessageSize??Id)-eE,this.receiveFinAck=z(),this.finAckTimeout=e.closeTimeout??tE,this.openTimeout=e.openTimeout??nE,this.closeController=new AbortController,this.channel.readyState){case"open":this.timeline.open=new Date().getTime();break;case"closed":case"closing":(this.timeline.close===void 0||this.timeline.close===0)&&(this.timeline.close=Date.now());break;case"connecting":break;default:throw this.log.error("unknown datachannel state %s",this.channel.readyState),new Wi("Unknown datachannel state")}this.channel.onopen=s=>{this.timeline.open=new Date().getTime()},this.channel.onclose=s=>{this.log.trace("received onclose event"),this.closeController.abort(),this.receiveFinAck.resolve(),this.close().catch(i=>{this.log.error("error closing stream after channel closed",i)})},this.channel.onerror=s=>{this.log.trace("received onerror event"),this.closeController.abort();const i=s.error;this.abort(i)},this.channel.onmessage=async s=>{const{data:i}=s;i===null||i.byteLength===0||this.incomingData.push(new Uint8Array(i,0,i.byteLength))};const r=this;Promise.resolve().then(async()=>{for await(const s of bs(this.incomingData)){const i=r.processIncomingProtobuf(s);i!=null&&r.sourcePush(new H(i))}}).catch(s=>{this.log.error("error processing incoming data channel messages",s)})}sendNewStream(){}async _sendMessage(e,t=!0){if(this.channel.readyState==="closed"||this.channel.readyState==="closing")throw new Wi(`Invalid datachannel state - ${this.channel.readyState}`);if(this.channel.readyState!=="open"){const r=AbortSignal.timeout(this.openTimeout),s=Dt([this.closeController.signal,r]);try{this.log('channel state is "%s" and not "open", waiting for "open" event before sending data',this.channel.readyState),await gt(this.channel,"open",s)}finally{s.clear()}this.log('channel state is now "%s", sending data',this.channel.readyState)}if(t&&this.channel.bufferedAmount>this.maxBufferedAmount){const r=AbortSignal.timeout(this.bufferedAmountLowEventTimeout),s=Dt([this.closeController.signal,r]);try{this.log('channel buffer is %d, wait for "bufferedamountlow" event',this.channel.bufferedAmount),await gt(this.channel,"bufferedamountlow",s)}catch(i){throw r.aborted?new Co(`Timed out waiting for DataChannel buffer to clear after ${this.bufferedAmountLowEventTimeout}ms`):i}finally{s.clear()}}try{this.log.trace('sending message, channel state "%s"',this.channel.readyState),this.channel.send(e.subarray())}catch(r){this.log.error("error while sending message",r)}}async sendData(e){const t=e.byteLength;for(e=e.sublist();e.byteLength>0;){const r=Math.min(e.byteLength,this.maxMessageSize),s=e.subarray(0,r),i=Ne.encode({message:s}),o=ws.single(i);this.log.trace("sending %d/%d bytes on channel",s.byteLength,t),await this._sendMessage(o),e.consume(r)}this.log.trace('finished sending data, channel state "%s"',this.channel.readyState)}async sendReset(){try{await this._sendFlag(Ne.Flag.RESET)}catch(e){this.log.error("failed to send reset - %e",e)}finally{this.channel.close()}}async sendCloseWrite(e){if(this.channel.readyState!=="open"){this.receiveFinAck.resolve();return}if(await this._sendFlag(Ne.Flag.FIN)){this.log.trace("awaiting FIN_ACK");try{await ie(this.receiveFinAck.promise,e?.signal,{errorMessage:"sending close-write was aborted before FIN_ACK was received",errorName:"FinAckNotReceivedError"})}catch(r){this.log.error("failed to await FIN_ACK",r)}}else this.log.trace("sending FIN failed, not awaiting FIN_ACK");this.receiveFinAck.resolve()}async sendCloseRead(){this.channel.readyState==="open"&&await this._sendFlag(Ne.Flag.STOP_SENDING)}processIncomingProtobuf(e){const t=Ne.decode(e);if(t.flag!==void 0&&(this.log.trace('incoming flag %s, write status "%s", read status "%s"',t.flag,this.writeStatus,this.readStatus),t.flag===Ne.Flag.FIN&&(this.remoteCloseWrite(),this.log.trace("sending FIN_ACK"),this._sendFlag(Ne.Flag.FIN_ACK).catch(r=>{this.log.error("error sending FIN_ACK immediately",r)})),t.flag===Ne.Flag.RESET&&this.reset(),t.flag===Ne.Flag.STOP_SENDING&&this.remoteCloseRead(),t.flag===Ne.Flag.FIN_ACK&&(this.log.trace("received FIN_ACK"),this.receiveFinAck.resolve())),this.readStatus==="ready")return t.message}async _sendFlag(e){if(this.channel.readyState!=="open")return this.log.trace('not sending flag %s because channel is "%s" and not "open"',e.toString(),this.channel.readyState),!1;this.log.trace("sending flag %s",e.toString());const t=Ne.encode({flag:e}),r=ws.single(t);try{return await this._sendMessage(r,!1),!0}catch(s){this.log.error("could not send flag %s - %e",e.toString(),s)}return!1}}function yo(n){const{channel:e,direction:t,handshake:r}=n;return new EE({id:`${e.id}`,log:n.logger.forComponent(`libp2p:webrtc:stream:${r===!0?"handshake":t}:${e.id}`),...n})}class Rd{protocol;peerConnection;bufferedStreams=[];metrics;dataChannelOptions;components;log;constructor(e,t){this.components=e,this.peerConnection=t.peerConnection,this.metrics=t.metrics,this.protocol=t.protocol??Td,this.dataChannelOptions=t.dataChannelOptions??{},this.log=e.logger.forComponent("libp2p:webrtc:muxerfactory"),this.peerConnection.ondatachannel=({channel:r})=>{if(this.log.trace('incoming early datachannel with channel id %d and label "%s"',r.id),r.label==="init"){this.log.trace("closing early init channel"),r.close();return}const s={},i=yo({channel:r,direction:"inbound",onEnd:o=>{s.onEnd(o)},logger:e.logger,...this.dataChannelOptions});s.stream=i,s.channel=r,s.onEnd=()=>{this.bufferedStreams=this.bufferedStreams.filter(o=>o.stream.id!==i.id)},this.bufferedStreams.push(s)}}createStreamMuxer(e){return new vE(this.components,{...e,peerConnection:this.peerConnection,dataChannelOptions:this.dataChannelOptions,metrics:this.metrics,streams:this.bufferedStreams,protocol:this.protocol})}}class vE{init;streams;protocol;log;peerConnection;dataChannelOptions;metrics;logger;constructor(e,t){this.init=t,this.log=e.logger.forComponent("libp2p:webrtc:muxer"),this.logger=e.logger,this.streams=t.streams.map(r=>r.stream),this.peerConnection=t.peerConnection,this.protocol=t.protocol??Td,this.metrics=t.metrics,this.dataChannelOptions=t.dataChannelOptions??{},this.peerConnection.ondatachannel=({channel:r})=>{if(this.log.trace("incoming datachannel with channel id %d",r.id),r.label==="init"){this.log.trace("closing init channel"),r.close();return}const s=r.id,i=yo({channel:r,direction:"inbound",onEnd:()=>{this.#e(i,r),this.log("incoming channel %s ended",s)},logger:this.logger,...this.dataChannelOptions});this.streams.push(i),this.metrics?.increment({incoming_stream:!0}),t?.onIncomingStream?.(i)},this.init.streams.length>0&&queueMicrotask(()=>{this.init.streams.forEach(r=>{r.onEnd=()=>{this.log("incoming early channel %s ended with state %s",r.channel.id,r.channel.readyState),this.#e(r.stream,r.channel)},this.metrics?.increment({incoming_stream:!0}),this.init?.onIncomingStream?.(r.stream)})})}#e(e,t){this.log.trace("stream %s %s %s onEnd",e.direction,e.id,e.protocol),bE(t,`${e.direction} ${e.id} ${e.protocol}`,this.dataChannelOptions.drainTimeout,{log:this.log}),this.streams=this.streams.filter(r=>r.id!==e.id),this.metrics?.increment({stream_end:!0}),this.init?.onStreamEnd?.(e)}async close(e){try{await Promise.all(this.streams.map(async t=>t.close(e)))}catch(t){this.abort(t)}}abort(e){for(const t of this.streams)t.abort(e)}source=Ld();sink=kd;newStream(){const e=this.peerConnection.createDataChannel(""),t=e.id;this.log.trace("opened outgoing datachannel with channel id %s",t);const r=yo({channel:e,direction:"outbound",onEnd:()=>{this.#e(r,e),this.log("outgoing channel %s ended",t)},logger:this.logger,...this.dataChannelOptions});return this.streams.push(r),this.metrics?.increment({outgoing_stream:!0}),r}}const Nd=globalThis.RTCPeerConnection,Od=globalThis.RTCSessionDescription,SE=globalThis.RTCIceCandidate;class xE extends Error{constructor(e){super(`WebRTC transport error: ${e}`),this.name="WebRTCTransportError"}}class Ct extends xE{constructor(e="SDP handshake failed"){super(e),this.name="SDPHandshakeFailedError"}}var Qe;(function(n){(function(r){r.SDP_OFFER="SDP_OFFER",r.SDP_ANSWER="SDP_ANSWER",r.ICE_CANDIDATE="ICE_CANDIDATE"})(n.Type||(n.Type={}));let e;(function(r){r[r.SDP_OFFER=0]="SDP_OFFER",r[r.SDP_ANSWER=1]="SDP_ANSWER",r[r.ICE_CANDIDATE=2]="ICE_CANDIDATE"})(e||(e={})),function(r){r.codec=()=>Nn(e)}(n.Type||(n.Type={}));let t;n.codec=()=>(t==null&&(t=fe((r,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),r.type!=null&&(s.uint32(8),n.Type.codec().encode(r.type,s)),r.data!=null&&(s.uint32(18),s.string(r.data)),i.lengthDelimited!==!1&&s.ldelim()},(r,s,i={})=>{const o={},a=s==null?r.len:r.pos+s;for(;r.pos<a;){const c=r.uint32();switch(c>>>3){case 1:{o.type=n.Type.codec().decode(r);break}case 2:{o.data=r.string();break}default:{r.skipType(c&7);break}}}return o})),t),n.encode=r=>he(r,n.codec()),n.decode=(r,s)=>de(r,n.codec(),s)})(Qe||(Qe={}));const Md=async(n,e,t)=>{try{const r=z();for(AE(n,r);;){const s=await Promise.race([r.promise,e.read({signal:t.signal}).catch(()=>{})]);if(s==null){t.signal?.throwIfAborted();break}if(s.type!==Qe.Type.ICE_CANDIDATE)throw new Je("ICE candidate message expected");const i=JSON.parse(s.data??"null");if(i===""||i===null){t.onProgress?.(new ee("webrtc:end-of-ice-candidates")),t.log.trace("end-of-candidates received");continue}const o=new SE(i);t.log.trace("%s received new ICE candidate %o",t.direction,i);try{t.onProgress?.(new ee("webrtc:add-ice-candidate",o.candidate)),await n.addIceCandidate(o)}catch(a){t.log.error("%s bad candidate received",t.direction,i,a)}}}catch(r){if(t.log.error("%s error parsing ICE candidate",t.direction,r),t.signal?.aborted===!0&&ca(n)!=="connected")throw r}};function ca(n){return Dd?n.iceConnectionState:n.connectionState}function AE(n,e){n[Dd?"oniceconnectionstatechange":"onconnectionstatechange"]=t=>{switch(ca(n)){case"connected":e.resolve();break;case"failed":case"disconnected":case"closed":e.reject(new yl("RTCPeerConnection was closed"));break}}}async function _E({rtcConfiguration:n,dataChannel:e,signal:t,metrics:r,multiaddr:s,connectionManager:i,transportManager:o,log:a,logger:c,onProgress:u}){const{circuitAddress:l,targetPeer:d}=TE(s);r?.dialerEvents.increment({open:!0}),a.trace("dialing circuit address: %a",l);const h=i.getConnections(d);let p;h.length===0?(u?.(new ee("webrtc:dial-relay")),p=await o.dial(l,{signal:t,onProgress:u})):(u?.(new ee("webrtc:reuse-relay-connection")),p=h[0]),u?.(new ee("webrtc:open-signaling-stream"));const g=await p.newStream(mo,{signal:t,runOnLimitedConnection:!0}),m=wt(g).pb(Qe),f=new Nd(n),w=new Rd({logger:c},{peerConnection:f,dataChannelOptions:e});try{const v=f.createDataChannel("init");f.onicecandidate=({candidate:T})=>{const k=JSON.stringify(T?.toJSON()??null);a.trace("initiator sending ICE candidate %o",T),m.write({type:Qe.Type.ICE_CANDIDATE,data:k},{signal:t}).catch(D=>{a.error("error sending ICE candidate",D)})},f.onicecandidateerror=T=>{a.error("initiator ICE candidate error",T)};const x=await f.createOffer().catch(T=>{throw a.error("could not execute createOffer",T),new Ct("Failed to set createOffer")});a.trace("initiator send SDP offer %s",x.sdp),u?.(new ee("webrtc:send-sdp-offer")),await m.write({type:Qe.Type.SDP_OFFER,data:x.sdp},{signal:t}),await f.setLocalDescription(x).catch(T=>{throw a.error("could not execute setLocalDescription",T),new Ct("Failed to set localDescription")}),u?.(new ee("webrtc:read-sdp-answer")),a.trace("initiator read SDP answer");const L=await m.read({signal:t});if(L.type!==Qe.Type.SDP_ANSWER)throw new Ct("Remote should send an SDP answer");a.trace("initiator received SDP answer %s",L.data);const E=new Od({type:"answer",sdp:L.data});return await f.setRemoteDescription(E).catch(T=>{throw a.error("could not execute setRemoteDescription",T),new Ct("Failed to set remoteDescription")}),a.trace("initiator read candidates until connected"),u?.(new ee("webrtc:read-ice-candidates")),await Md(f,m,{direction:"initiator",signal:t,log:a,onProgress:u}),a.trace("initiator connected, closing init channel"),v.close(),u?.(new ee("webrtc:close-signaling-stream")),a.trace("closing signaling channel"),await g.close({signal:t}),a.trace("initiator connected to remote address %s",s),{remoteAddress:s,peerConnection:f,muxerFactory:w}}catch(v){throw a.error("outgoing signaling error",v),f.close(),g.abort(v),v}finally{f.onicecandidate=null,f.onicecandidateerror=null}}const Lc=te(gd.matchers[0],se(Yt));class la extends nt{transportManager;shutdownController;events;constructor(e,t){super(),this.transportManager=e.transportManager,this.events=e.events,this.shutdownController=t.shutdownController,this.onTransportListening=this.onTransportListening.bind(this)}async listen(){this.events.addEventListener("transport:listening",this.onTransportListening)}onTransportListening(e){e.detail.getAddrs().filter(r=>Lc.exactMatch(r)).map(r=>r.encapsulate("/webrtc")).length>0&&this.safeDispatchEvent("listening")}getAddrs(){return this.transportManager.getListeners().filter(e=>!(e instanceof la)).map(e=>e.getAddrs().filter(t=>Lc.exactMatch(t)).map(t=>t.encapsulate("/webrtc"))).flat()}updateAnnounceAddrs(){}async close(){this.events.removeEventListener("transport:listening",this.onTransportListening),this.shutdownController.abort(),queueMicrotask(()=>{this.safeDispatchEvent("close")})}}async function CE({peerConnection:n,stream:e,signal:t,connection:r,log:s}){s.trace("new inbound signaling stream");const i=wt(e).pb(Qe);try{n.onicecandidate=({candidate:l})=>{const d=JSON.stringify(l?.toJSON()??null);s.trace("recipient sending ICE candidate %s",d),i.write({type:Qe.Type.ICE_CANDIDATE,data:d},{signal:t}).catch(h=>{s.error("error sending ICE candidate",h)})},s.trace("recipient read SDP offer");const a=await i.read({signal:t});if(a.type!==Qe.Type.SDP_OFFER)throw new Ct(`expected message type SDP_OFFER, received: ${a.type??"undefined"} `);s.trace("recipient received SDP offer %s",a.data);const c=new Od({type:"offer",sdp:a.data});await n.setRemoteDescription(c).catch(l=>{throw s.error("could not execute setRemoteDescription",l),new Ct("Failed to set remoteDescription")});const u=await n.createAnswer().catch(l=>{throw s.error("could not execute createAnswer",l),new Ct("Failed to create answer")});s.trace("recipient send SDP answer %s",u.sdp),await i.write({type:Qe.Type.SDP_ANSWER,data:u.sdp},{signal:t}),await n.setLocalDescription(u).catch(l=>{throw s.error("could not execute setLocalDescription",l),new Ct("Failed to set localDescription")}),s.trace("recipient read candidates until connected"),await Md(n,i,{direction:"recipient",signal:t,log:s})}catch(a){if(ca(n)!=="connected")throw s.error("error while handling signaling stream from peer %a",r.remoteAddr,a),n.close(),a;s("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected",r.remoteAddr,a)}const o=W(`/webrtc/p2p/${r.remoteAddr.getPeerId()}`);return s.trace("recipient connected to remote address %s",o),{remoteAddress:o}}class IE{components;init;log;_started=!1;metrics;shutdownController;constructor(e,t={}){this.components=e,this.init=t,this.log=e.logger.forComponent("libp2p:webrtc"),this.shutdownController=new AbortController,this.shutdownController.signal,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total",{label:"event",help:"Total count of WebRTC dialer events by type"}),listenerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total",{label:"event",help:"Total count of WebRTC listener events by type"})})}[xo]=!0;[Symbol.toStringTag]="@libp2p/webrtc";[Ye]=["@libp2p/transport"];[os]=["@libp2p/identify","@libp2p/circuit-relay-v2-transport"];isStarted(){return this._started}async start(){await this.components.registrar.handle(mo,e=>{const t=this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);this._onProtocol(e,t).catch(r=>{this.log.error("failed to handle incoming connect from %p",e.connection.remotePeer,r)}).finally(()=>{t.clear()})},{runOnLimitedConnection:!0}),this._started=!0}async stop(){await this.components.registrar.unhandle(mo),this._started=!1}createListener(e){return new la(this.components,{shutdownController:this.shutdownController})}listenFilter(e){return e.filter(po.exactMatch)}dialFilter(e){return this.listenFilter(e)}async dial(e,t){this.log.trace("dialing address: %a",e);const{remoteAddress:r,peerConnection:s,muxerFactory:i}=await _E({rtcConfiguration:await Pc(this.init.rtcConfiguration),dataChannel:this.init.dataChannel,multiaddr:e,dataChannelOptions:this.init.dataChannel,signal:t.signal,connectionManager:this.components.connectionManager,transportManager:this.components.transportManager,log:this.log,logger:this.components.logger,onProgress:t.onProgress}),o=new Dc(this.components,{peerConnection:s,timeline:{open:Date.now()},remoteAddr:r,metrics:this.metrics?.dialerEvents}),a=await t.upgrader.upgradeOutbound(o,{skipProtection:!0,skipEncryption:!0,muxerFactory:i,onProgress:t.onProgress,signal:t.signal});return this._closeOnShutdown(s,o),a}async _onProtocol({connection:e,stream:t},r){const s=new Nd(await Pc(this.init.rtcConfiguration)),i=new Rd(this.components,{peerConnection:s,dataChannelOptions:this.init.dataChannel});try{const{remoteAddress:o}=await CE({peerConnection:s,connection:e,stream:t,signal:r,log:this.log});await t.close({signal:r});const a=new Dc(this.components,{peerConnection:s,timeline:{open:new Date().getTime()},remoteAddr:o,metrics:this.metrics?.listenerEvents});await this.components.upgrader.upgradeInbound(a,{skipEncryption:!0,skipProtection:!0,muxerFactory:i,signal:r}),this._closeOnShutdown(s,a)}catch(o){throw this.log.error("incoming signaling error",o),s.close(),t.abort(o),o}}_closeOnShutdown(e,t){const r=()=>{t.close().catch(s=>{this.log.error("could not close WebRTCMultiaddrConnection",s)})};this.shutdownController.signal.addEventListener("abort",r),e.addEventListener("close",()=>{this.shutdownController.signal.removeEventListener("abort",r)})}}function TE(n){const e=n.getComponents().filter(({name:r})=>r==="p2p").map(({value:r})=>r).pop();if(e==null)throw new K("Destination peer id was missing");return{circuitAddress:W(n.getComponents().filter(({name:r})=>r!=="webrtc")),targetPeer:yt(e)}}const lt="/",Fd=new TextEncoder().encode(lt),Yr=Fd[0];class De{_buf;constructor(e,t){if(typeof e=="string")this._buf=$(e);else if(e instanceof Uint8Array)this._buf=e;else throw new Error("Invalid key, should be String of Uint8Array");if(t==null&&(t=!0),t&&this.clean(),this._buf.byteLength===0||this._buf[0]!==Yr)throw new Error("Invalid key")}toString(e="utf8"){return q(this._buf,e)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(e){return new De(e.join(lt))}static random(){return new De(Math.random().toString().substring(2))}static asKey(e){return e instanceof Uint8Array||typeof e=="string"?new De(e):typeof e.uint8Array=="function"?new De(e.uint8Array()):null}clean(){if((this._buf==null||this._buf.byteLength===0)&&(this._buf=Fd),this._buf[0]!==Yr){const e=new Uint8Array(this._buf.byteLength+1);e.fill(Yr,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===Yr;)this._buf=this._buf.subarray(0,-1)}less(e){const t=this.list(),r=e.list();for(let s=0;s<t.length;s++){if(r.length<s+1)return!1;const i=t[s],o=r[s];if(i<o)return!0;if(i>o)return!1}return t.length<r.length}reverse(){return De.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(lt).slice(1)}type(){return PE(this.baseNamespace())}name(){return DE(this.baseNamespace())}instance(e){return new De(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(lt)||(e+=lt),e+=this.type(),new De(e)}parent(){const e=this.list();return e.length===1?new De(lt):new De(e.slice(0,-1).join(lt))}child(e){return this.toString()===lt?e:e.toString()===lt?this:new De(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()===this.toString()?!1:e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()===this.toString()?!1:this.toString().startsWith(e.toString())}isTopLevel(){return this.list().length===1}concat(...e){return De.withNamespaces([...this.namespaces(),...LE(e.map(t=>t.namespaces()))])}}function PE(n){const e=n.split(":");return e.length<2?"":e.slice(0,-1).join(":")}function DE(n){const e=n.split(":");return e[e.length-1]}function LE(n){return[].concat(...n)}function kE(n){return e=>new IE(e,n)}const RE=[pt,Tr,Dr,Pr,Mn];function kc(n){return Ud("sni",n)?.value}function Rc(n){const e=Ud("tcp",n)?.value;return e==null?"":`:${e}`}function Ud(n,e){return e.find(t=>t.name===n)}function Nc(n){return n.some(({code:e})=>e===hn)}function Ve(n,e){const t=Bd[n.name];if(t==null)throw new Error(`Can't interpret protocol ${n.name}`);const r=t(n,e);return n.code===Ke?`[${r}]`:r}const Bd={ip4:(n,e)=>n.value,ip6:(n,e)=>e.length===0?n.value:`[${n.value}]`,tcp:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`tcp://${Ve(t,e)}:${n.value}`},udp:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`udp://${Ve(t,e)}:${n.value}`},dnsaddr:(n,e)=>n.value,dns4:(n,e)=>n.value,dns6:(n,e)=>n.value,dns:(n,e)=>n.value,ipfs:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`${Ve(t,e)}`},p2p:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`${Ve(t,e)}`},http:(n,e)=>{const t=Nc(e),r=kc(e),s=Rc(e);if(t&&r!=null)return`https://${r}${s}`;const i=t?"https://":"http://",o=e.pop();if(o==null)throw new Error("Unexpected end of multiaddr");let a=Ve(o,e);return a=a?.replace("tcp://",""),`${i}${a}`},"http-path":(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");const r=Ve(t,e),s=decodeURIComponent(n.value??"");return`${r}${s}`},tls:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return Ve(t,e)},sni:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return Ve(t,e)},https:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");let r=Ve(t,e);return r=r?.replace("tcp://",""),`https://${r}`},ws:(n,e)=>{const t=Nc(e),r=kc(e),s=Rc(e);if(t&&r!=null)return`wss://${r}${s}`;const i=t?"wss://":"ws://",o=e.pop();if(o==null)throw new Error("Unexpected end of multiaddr");let a=Ve(o,e);return a=a?.replace("tcp://",""),`${i}${a}`},wss:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");let r=Ve(t,e);return r=r?.replace("tcp://",""),`wss://${r}`}};function NE(n,e){const r=W(n).getComponents(),s=r.pop();if(s==null)throw new Error("Unexpected end of multiaddr");const i=Bd[s.name];if(i==null)throw new Error(`No interpreter found for ${s.name}`);let o=i(s,r)??"";return RE.includes(s.code)&&(o=o.replace(/^.*:\/\//,""),s.value==="443"?o=`https://${o}`:o=`http://${o}`),(o.startsWith("http://")||o.startsWith("https://")||o.startsWith("ws://")||o.startsWith("wss://"))&&(o=new URL(o).toString(),o.endsWith("/")&&(o=o.substring(0,o.length-1))),o}const OE=async n=>{if(n.readyState>=2)throw new Error("socket closed");n.readyState!==1&&await new Promise((e,t)=>{function r(){n.removeEventListener("open",s),n.removeEventListener("error",i)}function s(){r(),e()}function i(o){r(),t(o.error??new Error(`connect ECONNREFUSED ${n.url}`))}n.addEventListener("open",s),n.addEventListener("error",i)})},ME=(n,e)=>(e=e??{},e.closeOnEnd=e.closeOnEnd!==!1,async r=>{for await(const s of r){try{await OE(n)}catch(i){if(i.message==="socket closed")break;throw i}if(n.readyState===n.CLOSING||n.readyState===n.CLOSED)break;n.send(s)}e.closeOnEnd!=null&&n.readyState<=1&&await new Promise((s,i)=>{n.addEventListener("close",o=>{if(o.wasClean||o.code===1006)s();else{const a=Object.assign(new Error("ws error"),{event:o});i(a)}}),setTimeout(()=>{n.close()})})});var nn={},Wn={},Oc;function FE(){if(Oc)return Wn;Oc=1,Object.defineProperty(Wn,"__esModule",{value:!0});class n{constructor(){this.pullQueue=[],this.pushQueue=[],this.eventHandlers={},this.isPaused=!1,this.isStopped=!1}push(r){if(this.isStopped)return;const s={value:r,done:!1};if(this.pullQueue.length){const i=this.pullQueue.shift();i&&i.resolve(s)}else this.pushQueue.push(Promise.resolve(s)),this.highWaterMark!==void 0&&this.pushQueue.length>=this.highWaterMark&&!this.isPaused&&(this.isPaused=!0,this.eventHandlers.highWater?this.eventHandlers.highWater():console&&console.warn(`EventIterator queue reached ${this.pushQueue.length} items`))}stop(){if(!this.isStopped){this.isStopped=!0,this.remove();for(const r of this.pullQueue)r.resolve({value:void 0,done:!0});this.pullQueue.length=0}}fail(r){if(!this.isStopped)if(this.isStopped=!0,this.remove(),this.pullQueue.length){for(const s of this.pullQueue)s.reject(r);this.pullQueue.length=0}else{const s=Promise.reject(r);s.catch(()=>{}),this.pushQueue.push(s)}}remove(){Promise.resolve().then(()=>{this.removeCallback&&this.removeCallback()})}[Symbol.asyncIterator](){return{next:r=>{const s=this.pushQueue.shift();return s?(this.lowWaterMark!==void 0&&this.pushQueue.length<=this.lowWaterMark&&this.isPaused&&(this.isPaused=!1,this.eventHandlers.lowWater&&this.eventHandlers.lowWater()),s):this.isStopped?Promise.resolve({value:void 0,done:!0}):new Promise((i,o)=>{this.pullQueue.push({resolve:i,reject:o})})},return:()=>(this.isStopped=!0,this.pushQueue.length=0,this.remove(),Promise.resolve({value:void 0,done:!0}))}}}class e{constructor(r,{highWaterMark:s=100,lowWaterMark:i=1}={}){const o=new n;o.highWaterMark=s,o.lowWaterMark=i,o.removeCallback=r({push:a=>o.push(a),stop:()=>o.stop(),fail:a=>o.fail(a),on:(a,c)=>{o.eventHandlers[a]=c}})||(()=>{}),this[Symbol.asyncIterator]=()=>o[Symbol.asyncIterator](),Object.freeze(this)}}return Wn.EventIterator=e,Wn.default=e,Wn}var Mc;function UE(){if(Mc)return nn;Mc=1,Object.defineProperty(nn,"__esModule",{value:!0});const n=FE();nn.EventIterator=n.EventIterator;function e(t,r,s){return new n.EventIterator(({push:i})=>(this.addEventListener(t,i,r),()=>this.removeEventListener(t,i,r)),s)}return nn.subscribe=e,nn.default=n.EventIterator,nn}var BE=UE();function Fc(n){return n instanceof ArrayBuffer||n?.constructor?.name==="ArrayBuffer"&&typeof n?.byteLength=="number"}const $E=n=>{n.binaryType="arraybuffer";const e=async()=>{await new Promise((i,o)=>{if(r){i();return}if(s!=null){o(s);return}const a=l=>{n.removeEventListener("open",c),n.removeEventListener("error",u),l()},c=()=>{a(i)},u=l=>{a(()=>{o(l.error??new Error(`connect ECONNREFUSED ${n.url}`))})};n.addEventListener("open",c),n.addEventListener("error",u)})},t=async function*(){const i=new BE.EventIterator(({push:o,stop:a,fail:c})=>{const u=d=>{let h=null;typeof d.data=="string"&&(h=$(d.data)),Fc(d.data)&&(h=new Uint8Array(d.data)),d.data instanceof Uint8Array&&(h=d.data),h!=null&&o(h)},l=d=>{c(d.error??new Error("Socket error"))};return n.addEventListener("message",u),n.addEventListener("error",l),n.addEventListener("close",a),()=>{n.removeEventListener("message",u),n.removeEventListener("error",l),n.removeEventListener("close",a)}},{highWaterMark:1/0});await e();for await(const o of i)yield Fc(o)?new Uint8Array(o):o}();let r=n.readyState===1,s;return n.addEventListener("open",()=>{r=!0,s=null}),n.addEventListener("close",()=>{r=!1,s=null}),n.addEventListener("error",i=>{r||(s=i.error??new Error(`connect ECONNREFUSED ${n.url}`))}),Object.assign(t,{connected:e})},qE=(n,e)=>{e=e??{};const t=$E(n);let r=e.remoteAddress,s=e.remotePort;if(n.url!=null)try{const o=new URL(n.url);r=o.hostname,s=parseInt(o.port,10)}catch{}if(r==null||s==null)throw new Error("Remote connection did not have address and/or port");return{sink:ME(n,e),source:t,connected:async()=>{await t.connected()},close:async()=>{(n.readyState===n.CONNECTING||n.readyState===n.OPEN)&&await new Promise(o=>{n.addEventListener("close",()=>{o()}),n.close()})},destroy:()=>{n.terminate!=null?n.terminate():n.close()},remoteAddress:r,remotePort:s,socket:n}},zE=WebSocket,KE={"http:":"ws:","https:":"wss:"},Uc="ws:",WE=(n,e)=>{if(n.startsWith("//")&&(n=`${e?.protocol??Uc}${n}`),n.startsWith("/")&&e!=null){const r=e.protocol??Uc,s=e.host,i=e.port!=null&&s?.endsWith(`:${e.port}`)!==!0?`:${e.port}`:"";n=`${r}//${s}${i}${n}`}const t=new URL(n);for(const[r,s]of Object.entries(KE))t.protocol===r&&(t.protocol=s);return t};function VE(n,e){const t=typeof window>"u"?void 0:window.location;e=e??{};const r=WE(n,t),s=new zE(r.toString(),e.websocket);return qE(s,e)}function $d(n){return n.filter(e=>ks.exactMatch(e)||gr.exactMatch(e))}function HE(){throw new Error("WebSocket Servers can not be created in the browser!")}const GE=500;function QE(n,e,t){const r=t.logger.forComponent("libp2p:websockets:maconn"),s=t.metrics,i=t.metricPrefix??"",o={log:r,async sink(a){try{await n.sink(async function*(){for await(const c of a)c instanceof Uint8Array?yield c:yield c.subarray()}())}catch(c){c.type!=="aborted"&&r.error(c)}},source:n.source,remoteAddr:e,timeline:{open:Date.now()},async close(a={}){const c=Date.now();if(a.signal==null){const l=AbortSignal.timeout(GE);a={...a,signal:l}}const u=()=>{const{host:l,port:d}=o.remoteAddr.toOptions();r("timeout closing stream to %s:%s after %dms, destroying it manually",l,d,Date.now()-c),this.abort(new Bt("Socket close timeout"))};a.signal?.addEventListener("abort",u);try{await n.close()}catch(l){r.error("error closing WebSocket gracefully",l),this.abort(l)}finally{a.signal?.removeEventListener("abort",u),o.timeline.close=Date.now()}},abort(a){const{host:c,port:u}=o.remoteAddr.toOptions();r("timeout closing stream to %s:%s due to error",c,u,a),n.destroy(),o.timeline.close=Date.now(),s?.increment({[`${i}error`]:!0})}};return n.socket.addEventListener("close",()=>{s?.increment({[`${i}close`]:!0}),o.timeline.close==null&&(o.timeline.close=Date.now())},{once:!0}),o}class YE{log;init;logger;metrics;components;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:websockets"),this.logger=e.logger,this.components=e,this.init=t,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total",{label:"event",help:"Total count of WebSockets dialer events by type"})})}[xo]=!0;[Symbol.toStringTag]="@libp2p/websockets";[Ye]=["@libp2p/transport"];async dial(e,t){this.log("dialing %s",e),t=t??{};const r=await this._connect(e,t),s=QE(r,e,{logger:this.logger,metrics:this.metrics?.dialerEvents});this.log("new outbound connection %s",s.remoteAddr);const i=await t.upgrader.upgradeOutbound(s,t);return this.log("outbound connection %s upgraded",s.remoteAddr),i}async _connect(e,t){t?.signal?.throwIfAborted();const r=e.toOptions();this.log("dialing %s:%s",r.host,r.port);const s=z(),i=VE(NE(e),this.init);i.socket.addEventListener("error",()=>{const o=new yl(`Could not connect to ${e.toString()}`);this.log.error("connection error:",o),this.metrics?.dialerEvents.increment({error:!0}),s.reject(o)});try{t.onProgress?.(new ee("websockets:open-connection")),await ie(Promise.race([i.connected(),s.promise]),t.signal)}catch(o){throw t.signal?.aborted&&this.metrics?.dialerEvents.increment({abort:!0}),i.close().catch(a=>{this.log.error("error closing raw socket",a)}),o}return this.log("connected %s",e),this.metrics?.dialerEvents.increment({connect:!0}),i}createListener(e){return HE({logger:this.logger,events:this.components.events,metrics:this.components.metrics},{...this.init,...e})}listenFilter(e){return e=Array.isArray(e)?e:[e],this.init?.filter!=null?this.init?.filter(e):$d(e)}dialFilter(e){return this.listenFilter(e)}}function XE(n={}){return e=>new YE(e,n)}let ZE=class{readNext;haveNext;ended;nextResult;constructor(){this.ended=!1,this.readNext=z(),this.haveNext=z()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=z(),e}async throw(e){return this.ended=!0,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=z(),await ie(this.readNext.promise,t?.signal,t)}};function jE(){return new ZE}let JE=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};class ev extends Error{code;constructor(e,t){super(e),this.code=t}}let tv=class extends ev{type;constructor(e){super(e,"ABORT_ERR"),this.type="aborted",this.name="AbortError"}};function qd(n,e){const t=jE();n.sink(t).catch(async o=>{await t.end(o)}),n.sink=async o=>{for await(const a of o)await t.push(a);await t.end()};let r=n.source;n.source[Symbol.iterator]!=null?r=n.source[Symbol.iterator]():n.source[Symbol.asyncIterator]!=null&&(r=n.source[Symbol.asyncIterator]());const s=new H;return{read:async(o,a)=>{a?.signal?.throwIfAborted();let c;const u=new Promise((l,d)=>{c=()=>{d(new tv("Read aborted"))},a?.signal?.addEventListener("abort",c)});try{if(o==null){const{done:d,value:h}=await Promise.race([r.next(),u]);return d===!0?new H:h}for(;s.byteLength<o;){const{value:d,done:h}=await Promise.race([r.next(),u]);if(h===!0)throw new JE("unexpected end of input");s.append(d)}const l=s.sublist(0,o);return s.consume(o),l}finally{c!=null&&a?.signal?.removeEventListener("abort",c)}},write:async(o,a)=>{a?.signal?.throwIfAborted(),o instanceof Uint8Array?await t.push(o,a):await t.push(o.subarray(),a)},unwrap:()=>{if(s.byteLength>0){const o=n.source;n.source=async function*(){yield*s,yield*o}()}return n}}}function Ms(n){if(typeof n!="object"||n===null)return!1;const e=Object.getPrototypeOf(n);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(Symbol.toStringTag in n)&&!(Symbol.iterator in n)}const{hasOwnProperty:zd}=Object.prototype,{propertyIsEnumerable:nv}=Object,Tn=(n,e,t)=>{Object.defineProperty(n,e,{value:t,writable:!0,enumerable:!0,configurable:!0})},rv=void 0,Bc={concatArrays:!1,ignoreUndefined:!1},ni=n=>{const e=[];for(const t in n)zd.call(n,t)&&e.push(t);if(Object.getOwnPropertySymbols){const t=Object.getOwnPropertySymbols(n);for(const r of t)nv.call(n,r)&&e.push(r)}return e};function Un(n){return Array.isArray(n)?sv(n):Ms(n)?iv(n):n}function sv(n){const e=n.slice(0,0);return ni(n).forEach(t=>{Tn(e,t,Un(n[t]))}),e}function iv(n){const e=Object.getPrototypeOf(n)===null?Object.create(null):{};return ni(n).forEach(t=>{Tn(e,t,Un(n[t]))}),e}const Kd=(n,e,t,r)=>(t.forEach(s=>{typeof e[s]>"u"&&r.ignoreUndefined||(s in n&&n[s]!==Object.getPrototypeOf(n)?Tn(n,s,wo(n[s],e[s],r)):Tn(n,s,Un(e[s])))}),n),ov=(n,e,t)=>{let r=n.slice(0,0),s=0;return[n,e].forEach(i=>{const o=[];for(let a=0;a<i.length;a++)zd.call(i,a)&&(o.push(String(a)),i===n?Tn(r,s++,i[a]):Tn(r,s++,Un(i[a])));r=Kd(r,i,ni(i).filter(a=>!o.includes(a)),t)}),r};function wo(n,e,t){return t.concatArrays&&Array.isArray(n)&&Array.isArray(e)?ov(n,e,t):!Ms(e)||!Ms(n)?Un(e):Kd(n,e,ni(e),t)}function Wd(...n){const e=wo(Un(Bc),this!==rv&&this||{},Bc);let t={_:{}};for(const r of n)if(r!==void 0){if(!Ms(r))throw new TypeError("`"+r+"` is not an Option Object");t=wo(t,{_:r},e)}return t._}var Ci={exports:{}},$c;function av(){return $c||($c=1,function(n){var e=Object.prototype.hasOwnProperty,t="~";function r(){}Object.create&&(r.prototype=Object.create(null),new r().__proto__||(t=!1));function s(c,u,l){this.fn=c,this.context=u,this.once=l||!1}function i(c,u,l,d,h){if(typeof l!="function")throw new TypeError("The listener must be a function");var p=new s(l,d||c,h),g=t?t+u:u;return c._events[g]?c._events[g].fn?c._events[g]=[c._events[g],p]:c._events[g].push(p):(c._events[g]=p,c._eventsCount++),c}function o(c,u){--c._eventsCount===0?c._events=new r:delete c._events[u]}function a(){this._events=new r,this._eventsCount=0}a.prototype.eventNames=function(){var u=[],l,d;if(this._eventsCount===0)return u;for(d in l=this._events)e.call(l,d)&&u.push(t?d.slice(1):d);return Object.getOwnPropertySymbols?u.concat(Object.getOwnPropertySymbols(l)):u},a.prototype.listeners=function(u){var l=t?t+u:u,d=this._events[l];if(!d)return[];if(d.fn)return[d.fn];for(var h=0,p=d.length,g=new Array(p);h<p;h++)g[h]=d[h].fn;return g},a.prototype.listenerCount=function(u){var l=t?t+u:u,d=this._events[l];return d?d.fn?1:d.length:0},a.prototype.emit=function(u,l,d,h,p,g){var m=t?t+u:u;if(!this._events[m])return!1;var f=this._events[m],w=arguments.length,v,x;if(f.fn){switch(f.once&&this.removeListener(u,f.fn,void 0,!0),w){case 1:return f.fn.call(f.context),!0;case 2:return f.fn.call(f.context,l),!0;case 3:return f.fn.call(f.context,l,d),!0;case 4:return f.fn.call(f.context,l,d,h),!0;case 5:return f.fn.call(f.context,l,d,h,p),!0;case 6:return f.fn.call(f.context,l,d,h,p,g),!0}for(x=1,v=new Array(w-1);x<w;x++)v[x-1]=arguments[x];f.fn.apply(f.context,v)}else{var L=f.length,E;for(x=0;x<L;x++)switch(f[x].once&&this.removeListener(u,f[x].fn,void 0,!0),w){case 1:f[x].fn.call(f[x].context);break;case 2:f[x].fn.call(f[x].context,l);break;case 3:f[x].fn.call(f[x].context,l,d);break;case 4:f[x].fn.call(f[x].context,l,d,h);break;default:if(!v)for(E=1,v=new Array(w-1);E<w;E++)v[E-1]=arguments[E];f[x].fn.apply(f[x].context,v)}}return!0},a.prototype.on=function(u,l,d){return i(this,u,l,d,!1)},a.prototype.once=function(u,l,d){return i(this,u,l,d,!0)},a.prototype.removeListener=function(u,l,d,h){var p=t?t+u:u;if(!this._events[p])return this;if(!l)return o(this,p),this;var g=this._events[p];if(g.fn)g.fn===l&&(!h||g.once)&&(!d||g.context===d)&&o(this,p);else{for(var m=0,f=[],w=g.length;m<w;m++)(g[m].fn!==l||h&&!g[m].once||d&&g[m].context!==d)&&f.push(g[m]);f.length?this._events[p]=f.length===1?f[0]:f:o(this,p)}return this},a.prototype.removeAllListeners=function(u){var l;return u?(l=t?t+u:u,this._events[l]&&o(this,l)):(this._events=new r,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=t,a.EventEmitter=a,n.exports=a}(Ci)),Ci.exports}var cv=av();const lv=ia(cv);function uv(n,e,t){let r=0,s=n.length;for(;s>0;){const i=Math.trunc(s/2);let o=r+i;t(n[o],e)<=0?(r=++o,s-=i+1):s=i}return r}let dv=class{#e=[];enqueue(e,t){t={priority:0,...t};const r={priority:t.priority,id:t.id,run:e};if(this.size===0||this.#e[this.size-1].priority>=t.priority){this.#e.push(r);return}const s=uv(this.#e,r,(i,o)=>o.priority-i.priority);this.#e.splice(s,0,r)}setPriority(e,t){const r=this.#e.findIndex(i=>i.id===e);if(r===-1)throw new ReferenceError(`No promise function with the id "${e}" exists in the queue.`);const[s]=this.#e.splice(r,1);this.enqueue(s.run,{priority:t,id:e})}dequeue(){return this.#e.shift()?.run}filter(e){return this.#e.filter(t=>t.priority===e.priority).map(t=>t.run)}get size(){return this.#e.length}};class hv extends lv{#e;#n;#t=0;#f;#a;#p=0;#s;#c;#r;#g;#i=0;#l;#o;#m;#b=1n;timeout;constructor(e){if(super(),e={carryoverConcurrencyCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:dv,...e},!(typeof e.intervalCap=="number"&&e.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${e.intervalCap?.toString()??""}\` (${typeof e.intervalCap})`);if(e.interval===void 0||!(Number.isFinite(e.interval)&&e.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${e.interval?.toString()??""}\` (${typeof e.interval})`);this.#e=e.carryoverConcurrencyCount,this.#n=e.intervalCap===Number.POSITIVE_INFINITY||e.interval===0,this.#f=e.intervalCap,this.#a=e.interval,this.#r=new e.queueClass,this.#g=e.queueClass,this.concurrency=e.concurrency,this.timeout=e.timeout,this.#m=e.throwOnTimeout===!0,this.#o=e.autoStart===!1}get#E(){return this.#n||this.#t<this.#f}get#v(){return this.#i<this.#l}#S(){this.#i--,this.#u(),this.emit("next")}#x(){this.#w(),this.#y(),this.#c=void 0}get#A(){const e=Date.now();if(this.#s===void 0){const t=this.#p-e;if(t<0)this.#t=this.#e?this.#i:0;else return this.#c===void 0&&(this.#c=setTimeout(()=>{this.#x()},t)),!0}return!1}#u(){if(this.#r.size===0)return this.#s&&clearInterval(this.#s),this.#s=void 0,this.emit("empty"),this.#i===0&&this.emit("idle"),!1;if(!this.#o){const e=!this.#A;if(this.#E&&this.#v){const t=this.#r.dequeue();return t?(this.emit("active"),t(),e&&this.#y(),!0):!1}}return!1}#y(){this.#n||this.#s!==void 0||(this.#s=setInterval(()=>{this.#w()},this.#a),this.#p=Date.now()+this.#a)}#w(){this.#t===0&&this.#i===0&&this.#s&&(clearInterval(this.#s),this.#s=void 0),this.#t=this.#e?this.#i:0,this.#d()}#d(){for(;this.#u(););}get concurrency(){return this.#l}set concurrency(e){if(!(typeof e=="number"&&e>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);this.#l=e,this.#d()}async#_(e){return new Promise((t,r)=>{e.addEventListener("abort",()=>{r(e.reason)},{once:!0})})}setPriority(e,t){this.#r.setPriority(e,t)}async add(e,t={}){return t.id??=(this.#b++).toString(),t={timeout:this.timeout,throwOnTimeout:this.#m,...t},new Promise((r,s)=>{this.#r.enqueue(async()=>{this.#i++,this.#t++;try{t.signal?.throwIfAborted();let i=e({signal:t.signal});t.timeout&&(i=aa(Promise.resolve(i),{milliseconds:t.timeout})),t.signal&&(i=Promise.race([i,this.#_(t.signal)]));const o=await i;r(o),this.emit("completed",o)}catch(i){if(i instanceof Pd&&!t.throwOnTimeout){r();return}s(i),this.emit("error",i)}finally{this.#S()}},t),this.emit("add"),this.#u()})}async addAll(e,t){return Promise.all(e.map(async r=>this.add(r,t)))}start(){return this.#o?(this.#o=!1,this.#d(),this):this}pause(){this.#o=!0}clear(){this.#r=new this.#g}async onEmpty(){this.#r.size!==0&&await this.#h("empty")}async onSizeLessThan(e){this.#r.size<e||await this.#h("next",()=>this.#r.size<e)}async onIdle(){this.#i===0&&this.#r.size===0||await this.#h("idle")}async#h(e,t){return new Promise(r=>{const s=()=>{t&&!t()||(this.off(e,s),r())};this.on(e,s)})}get size(){return this.#r.size}sizeBy(e){return this.#r.filter(e).length}get pending(){return this.#i}get isPaused(){return this.#o}}function Vd(n){const e=[Lt.A];return n==null?e:Array.isArray(n)?n.length===0?e:n:[n]}const Hd=60;function Gd(n){return{Status:n.Status??0,TC:n.TC??n.flag_tc??!1,RD:n.RD??n.flag_rd??!1,RA:n.RA??n.flag_ra??!1,AD:n.AD??n.flag_ad??!1,CD:n.CD??n.flag_cd??!1,Question:(n.Question??n.questions??[]).map(e=>({name:e.name,type:Lt[e.type]})),Answer:(n.Answer??n.answers??[]).map(e=>({name:e.name,type:Lt[e.type],TTL:e.TTL??e.ttl??Hd,data:e.data instanceof Uint8Array?q(e.data):e.data}))}}const fv=4;function qc(n,e={}){const t=new hv({concurrency:e.queryConcurrency??fv});return async(r,s={})=>{const i=new URLSearchParams;i.set("name",r),Vd(s.types).forEach(a=>{i.append("type",Lt[a])}),s.onProgress?.(new ee("dns:query",{detail:r}));const o=await t.add(async()=>{const a=await fetch(`${n}?${i}`,{headers:{accept:"application/dns-json"},signal:s?.signal});if(a.status!==200)throw new Error(`Unexpected HTTP status: ${a.status} - ${a.statusText}`);const c=Gd(await a.json());return s.onProgress?.(new ee("dns:response",{detail:c})),c},{signal:s.signal});if(o==null)throw new Error("No DNS response received");return o}}function pv(){return[qc("https://cloudflare-dns.com/dns-query"),qc("https://dns.google/resolve")]}var Ii,zc;function gv(){return zc||(zc=1,Ii=function(n){if(!n)throw Error("hashlru must have a max value, of type number, greater than 0");var e=0,t=Object.create(null),r=Object.create(null);function s(i,o){t[i]=o,e++,e>=n&&(e=0,r=t,t=Object.create(null))}return{has:function(i){return t[i]!==void 0||r[i]!==void 0},remove:function(i){t[i]!==void 0&&(t[i]=void 0),r[i]!==void 0&&(r[i]=void 0)},get:function(i){var o=t[i];if(o!==void 0)return o;if((o=r[i])!==void 0)return s(i,o),o},set:function(i,o){t[i]!==void 0?t[i]=o:s(i,o)},clear:function(){t=Object.create(null),r=Object.create(null)}}}),Ii}var mv=gv();const yv=ia(mv);class wv{lru;constructor(e){this.lru=yv(e)}get(e,t){let r=!0;const s=[];for(const i of t){const o=this.getAnswers(e,i);if(o.length===0){r=!1;break}s.push(...o)}if(r)return Gd({answers:s})}getAnswers(e,t){const r=`${e.toLowerCase()}-${t}`,s=this.lru.get(r);if(s!=null){const i=s.filter(o=>o.expires>Date.now()).map(({expires:o,value:a})=>({...a,TTL:Math.round((o-Date.now())/1e3),type:Lt[a.type]}));return i.length===0&&this.lru.remove(r),i}return[]}add(e,t){const r=`${e.toLowerCase()}-${t.type}`,s=this.lru.get(r)??[];s.push({expires:Date.now()+(t.TTL??Hd)*1e3,value:t}),this.lru.set(r,s)}remove(e,t){const r=`${e.toLowerCase()}-${t}`;this.lru.remove(r)}clear(){this.lru.clear()}}function bv(n){return new wv(n)}const Ev=1e3;class vv{resolvers;cache;constructor(e){this.resolvers={},this.cache=bv(e.cacheSize??Ev),Object.entries(e.resolvers??{}).forEach(([t,r])=>{Array.isArray(r)||(r=[r]),t.endsWith(".")||(t=`${t}.`),this.resolvers[t]=r}),this.resolvers["."]==null&&(this.resolvers["."]=pv())}async query(e,t={}){const r=Vd(t.types),s=t.cached!==!1?this.cache.get(e,r):void 0;if(s!=null)return t.onProgress?.(new ee("dns:cache",{detail:s})),s;const i=`${e.split(".").pop()}.`,o=(this.resolvers[i]??this.resolvers["."]).sort(()=>Math.random()>.5?-1:1),a=[];for(const c of o){if(t.signal?.aborted===!0)break;try{const u=await c(e,{...t,types:r});for(const l of u.Answer)this.cache.add(e,l);return u}catch(u){a.push(u),t.onProgress?.(new ee("dns:error",{detail:u}))}}throw a.length===1?a[0]:new AggregateError(a,`DNS lookup of ${e} ${r} failed`)}}var Lt;(function(n){n[n.A=1]="A",n[n.CNAME=5]="CNAME",n[n.TXT=16]="TXT",n[n.AAAA=28]="AAAA"})(Lt||(Lt={}));function Sv(n={}){return new vv(n)}class xv{dns;canResolve(e){return e.getComponents().some(({name:t})=>t==="dnsaddr")}async resolve(e,t){const r=e.getComponents().find(c=>c.name==="dnsaddr")?.value;if(r==null)return[e];const i=await this.getDNS(t).query(`_dnsaddr.${r}`,{signal:t?.signal,types:[Lt.TXT]}),o=e.getComponents().find(c=>c.name==="p2p")?.value,a=[];for(const c of i.Answer){const u=c.data.replace(/["']/g,"").trim().split("=")[1];u!=null&&(o!=null&&!u.includes(o)||a.push(W(u)))}return a}getDNS(e){return e.dns!=null?e.dns:(this.dns==null&&(this.dns=Sv()),this.dns)}}const ua=new xv,Av={addresses:{listen:[],announce:[],noAnnounce:[],announceFilter:n=>n},connectionManager:{resolvers:{dnsaddr:ua}},transportManager:{faultTolerance:or.FATAL_ALL}};async function _v(n){const e=Wd(Av,n);if(e.connectionProtector===null&&globalThis.process?.env?.LIBP2P_FORCE_PNET!=null)throw new K("Private network is enforced, but no protector was provided");return e}const Pn=1e3,Dn=Pn*60,Ln=Dn*60,Gt=Ln*24,Cv=Gt*7,Iv=Gt*365.25;function Qd(n,e){try{if(typeof n=="string"&&n.length>0)return Tv(n);if(typeof n=="number"&&isFinite(n))return e?.long?Dv(n):Pv(n);throw new Error("Value is not a string or number.")}catch(t){const r=Lv(t)?`${t.message}. value=${JSON.stringify(n)}`:"An unknown error has occured.";throw new Error(r)}}function Tv(n){if(n=String(n),n.length>100)throw new Error("Value exceeds the maximum length of 100 characters.");const e=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(n);if(!e)return NaN;const t=parseFloat(e[1]),r=(e[2]||"ms").toLowerCase();switch(r){case"years":case"year":case"yrs":case"yr":case"y":return t*Iv;case"weeks":case"week":case"w":return t*Cv;case"days":case"day":case"d":return t*Gt;case"hours":case"hour":case"hrs":case"hr":case"h":return t*Ln;case"minutes":case"minute":case"mins":case"min":case"m":return t*Dn;case"seconds":case"second":case"secs":case"sec":case"s":return t*Pn;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:throw new Error(`The unit ${r} was matched, but no matching case exists.`)}}function Pv(n){const e=Math.abs(n);return e>=Gt?`${Math.round(n/Gt)}d`:e>=Ln?`${Math.round(n/Ln)}h`:e>=Dn?`${Math.round(n/Dn)}m`:e>=Pn?`${Math.round(n/Pn)}s`:`${n}ms`}function Dv(n){const e=Math.abs(n);return e>=Gt?Xr(n,e,Gt,"day"):e>=Ln?Xr(n,e,Ln,"hour"):e>=Dn?Xr(n,e,Dn,"minute"):e>=Pn?Xr(n,e,Pn,"second"):`${n} ms`}function Xr(n,e,t,r){const s=e>=t*1.5;return`${Math.round(n/t)} ${r}${s?"s":""}`}function Lv(n){return typeof n=="object"&&n!==null&&"message"in n}function kv(n){t.debug=t,t.default=t,t.coerce=c,t.disable=i,t.enable=s,t.enabled=o,t.humanize=Qd,t.destroy=u,Object.keys(n).forEach(l=>{t[l]=n[l]}),t.names=[],t.skips=[],t.formatters={};function e(l){let d=0;for(let h=0;h<l.length;h++)d=(d<<5)-d+l.charCodeAt(h),d|=0;return t.colors[Math.abs(d)%t.colors.length]}t.selectColor=e;function t(l){let d,h=null,p,g;function m(...f){if(!m.enabled)return;const w=m,v=Number(new Date),x=v-(d||v);w.diff=x,w.prev=d,w.curr=v,d=v,f[0]=t.coerce(f[0]),typeof f[0]!="string"&&f.unshift("%O");let L=0;f[0]=f[0].replace(/%([a-zA-Z%])/g,(T,k)=>{if(T==="%%")return"%";L++;const D=t.formatters[k];if(typeof D=="function"){const y=f[L];T=D.call(w,y),f.splice(L,1),L--}return T}),t.formatArgs.call(w,f),(w.log||t.log).apply(w,f)}return m.namespace=l,m.useColors=t.useColors(),m.color=t.selectColor(l),m.extend=r,m.destroy=t.destroy,Object.defineProperty(m,"enabled",{enumerable:!0,configurable:!1,get:()=>h!==null?h:(p!==t.namespaces&&(p=t.namespaces,g=t.enabled(l)),g),set:f=>{h=f}}),typeof t.init=="function"&&t.init(m),m}function r(l,d){const h=t(this.namespace+(typeof d>"u"?":":d)+l);return h.log=this.log,h}function s(l){t.save(l),t.namespaces=l,t.names=[],t.skips=[];let d;const h=(typeof l=="string"?l:"").split(/[\s,]+/),p=h.length;for(d=0;d<p;d++)h[d]&&(l=h[d].replace(/\*/g,".*?"),l[0]==="-"?t.skips.push(new RegExp("^"+l.substr(1)+"$")):t.names.push(new RegExp("^"+l+"$")))}function i(){const l=[...t.names.map(a),...t.skips.map(a).map(d=>"-"+d)].join(",");return t.enable(""),l}function o(l){if(l[l.length-1]==="*")return!0;let d,h;for(d=0,h=t.skips.length;d<h;d++)if(t.skips[d].test(l))return!1;for(d=0,h=t.names.length;d<h;d++)if(t.names[d].test(l))return!0;return!1}function a(l){return l.toString().substring(2,l.toString().length-2).replace(/\.\*\?$/,"*")}function c(l){return l instanceof Error?l.stack??l.message:l}function u(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return t.setupFormatters(t.formatters),t.enable(t.load()),t}var Rv={};const Fs=$v(),Nv=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function Ov(){return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/(edge|trident)\/(\d+)/)!=null?!1:typeof document<"u"&&document.documentElement?.style?.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/firefox\/(\d+)/)!=null&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/applewebkit\/(\d+)/)}function Mv(n){if(n[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+n[0]+(this.useColors?"%c ":" ")+"+"+Qd(this.diff),!this.useColors)return;const e="color: "+this.color;n.splice(1,0,e,"color: inherit");let t=0,r=0;n[0].replace(/%[a-zA-Z%]/g,s=>{s!=="%%"&&(t++,s==="%c"&&(r=t))}),n.splice(r,0,e)}const Fv=console.debug??console.log??(()=>{});function Uv(n){try{n?Fs?.setItem("debug",n):Fs?.removeItem("debug")}catch{}}function Bv(){let n;try{n=Fs?.getItem("debug")}catch{}return!n&&typeof globalThis.process<"u"&&"env"in globalThis.process&&(n=Rv.DEBUG),n}function $v(){try{return localStorage}catch{}}function qv(n){n.j=function(e){try{return JSON.stringify(e)}catch(t){return"[UnexpectedJSONParseError]: "+t.message}}}const Be=kv({formatArgs:Mv,save:Uv,load:Bv,useColors:Ov,setupFormatters:qv,colors:Nv,storage:Fs,log:Fv});Be.formatters.b=n=>n==null?"undefined":ge.baseEncode(n);Be.formatters.t=n=>n==null?"undefined":It.baseEncode(n);Be.formatters.m=n=>n==null?"undefined":Pl.baseEncode(n);Be.formatters.p=n=>n==null?"undefined":n.toString();Be.formatters.c=n=>n==null?"undefined":n.toString();Be.formatters.k=n=>n==null?"undefined":n.toString();Be.formatters.a=n=>n==null?"undefined":n.toString();Be.formatters.e=n=>n==null?"undefined":Kc(n.stack)??Kc(n.message)??n.toString();function zv(n){const e=()=>{};return e.enabled=!1,e.color="",e.diff=0,e.log=()=>{},e.namespace=n,e.destroy=()=>!0,e.extend=()=>e,e}function Yd(){return{forComponent(n){return Kv(n)}}}function Kv(n){let e=zv(`${n}:trace`);return Be.enabled(`${n}:trace`)&&Be.names.map(t=>t.toString()).find(t=>t.includes(":trace"))!=null&&(e=Be(`${n}:trace`)),Object.assign(Be(n),{error:Be(`${n}:error`),trace:e})}function Kc(n){if(n!=null&&(n=n.trim(),n.length!==0))return n}function Wv(n){return n[Symbol.asyncIterator]!=null}function bo(n){if(Wv(n))return(async()=>{const t=[];for await(const r of n)t.push(r);return t})();const e=[];for(const t of n)e.push(t);return e}class Vv extends Error{static name="QueueFullError";constructor(e="The queue was full"){super(e),this.name="QueueFullError"}}class Hv{deferred;signal;constructor(e){this.signal=e,this.deferred=Promise.withResolvers(),this.onAbort=this.onAbort.bind(this),this.signal?.addEventListener("abort",this.onAbort)}onAbort(){this.deferred.reject(this.signal?.reason??new Cn)}cleanup(){this.signal?.removeEventListener("abort",this.onAbort)}}function Gv(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}class Qv{id;fn;options;recipients;status;timeline;controller;constructor(e,t){this.id=Gv(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,r)=>t&&r.signal?.aborted===!0,!0)&&(this.controller.abort(new Cn),this.cleanup())}async join(e={}){const t=new Hv(e.signal);return this.recipients.push(t),e.signal?.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await ie(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{e.cleanup(),e.signal?.removeEventListener("abort",this.onAbort)})}}function Wc(n,e){let t;const r=function(){const s=function(){t=void 0,n()};clearTimeout(t),t=setTimeout(s,e)};return r.start=()=>{},r.stop=()=>{clearTimeout(t)},r}class Vc extends nt{concurrency;maxSize;queue;pending;sort;autoStart;constructor(e={}){super(),this.concurrency=e.concurrency??Number.POSITIVE_INFINITY,this.maxSize=e.maxSize??Number.POSITIVE_INFINITY,this.pending=0,this.autoStart=e.autoStart??!0,this.sort=e.sort,this.queue=[],this.emitEmpty=Wc(this.emitEmpty.bind(this),1),this.emitIdle=Wc(this.emitIdle.bind(this),1)}[Symbol.asyncIterator](){return this.toGenerator()}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(const t of this.queue)if(t.status==="queued"){e=t;break}return e==null?!1:(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let t=0;t<this.queue.length;t++)if(this.queue[t]===e){this.queue.splice(t,1);break}this.pending--,this.safeDispatchEvent("next"),this.autoStart&&this.tryToStartAnother()}),!0)}return!1}enqueue(e){this.queue.push(e),this.sort!=null&&this.queue.sort(this.sort)}start(){this.autoStart===!1&&(this.autoStart=!0,this.tryToStartAnother())}pause(){this.autoStart=!1}async add(e,t){if(t?.signal?.throwIfAborted(),this.size===this.maxSize)throw new Vv;const r=new Qv(e,t);return this.enqueue(r),this.safeDispatchEvent("add"),this.autoStart&&this.tryToStartAnother(),r.join(t).then(s=>(this.safeDispatchEvent("success",{detail:{job:r,result:s}}),s)).catch(s=>{if(r.status==="queued"){for(let i=0;i<this.queue.length;i++)if(this.queue[i]===r){this.queue.splice(i,1);break}}throw this.safeDispatchEvent("failure",{detail:{job:r,error:s}}),s})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new Cn)}),this.clear()}async onEmpty(e){this.size!==0&&await gt(this,"empty",e?.signal)}async onSizeLessThan(e,t){this.size<e||await gt(this,"next",t?.signal,{filter:()=>this.size<e})}async onIdle(e){this.pending===0&&this.size===0||await gt(this,"idle",e?.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){e?.signal?.throwIfAborted();const t=On({objectMode:!0}),r=c=>{c!=null?this.abort():this.clear(),t.end(c)},s=c=>{c.detail!=null&&t.push(c.detail.result)},i=c=>{r(c.detail.error)},o=()=>{r()},a=()=>{r(new Cn("Queue aborted"))};this.addEventListener("success",s),this.addEventListener("failure",i),this.addEventListener("idle",o),e?.signal?.addEventListener("abort",a);try{yield*t}finally{this.removeEventListener("success",s),this.removeEventListener("failure",i),this.removeEventListener("idle",o),e?.signal?.removeEventListener("abort",a),r()}}}const Xd="lock:worker:request-read",Zd="lock:worker:abort-read-request",jd="lock:worker:release-read",Jd="lock:master:grant-read",eh="lock:master:error-read",th="lock:worker:request-write",nh="lock:worker:abort-write-request",rh="lock:worker:release-write",sh="lock:master:grant-write",ih="lock:master:error-write",oh="lock:worker:finalize",ah="mortice",Yv={singleProcess:!1},Hc=(n,e,t,r,s,i,o,a,c)=>u=>{if(u.data==null)return;const l={type:u.data.type,name:u.data.name,identifier:u.data.identifier};l.type===s&&n.safeDispatchEvent(t,{detail:{name:l.name,identifier:l.identifier,handler:async()=>{e.postMessage({type:c,name:l.name,identifier:l.identifier}),await new Promise(d=>{const h=p=>{if(p?.data==null)return;const g={type:p.data.type,name:p.data.name,identifier:p.data.identifier};g.type===a&&g.identifier===l.identifier&&(e.removeEventListener("message",h),d())};e.addEventListener("message",h)})},onError:d=>{e.postMessage({type:o,name:l.name,identifier:l.identifier,error:{message:d.message,name:d.name,stack:d.stack}})}}}),l.type===i&&n.safeDispatchEvent(r,{detail:{name:l.name,identifier:l.identifier}}),l.type===oh&&n.safeDispatchEvent("finalizeRequest",{detail:{name:l.name}})},Xv=(n=10)=>Math.random().toString().substring(2,n+2);class Zv{name;channel;constructor(e){this.name=e,this.channel=new BroadcastChannel(ah)}readLock(e){return this.sendRequest(Xd,Zd,Jd,eh,jd,e)}writeLock(e){return this.sendRequest(th,nh,sh,ih,rh,e)}finalize(){this.channel.postMessage({type:oh,name:this.name}),this.channel.close()}async sendRequest(e,t,r,s,i,o){o?.signal?.throwIfAborted();const a=Xv();return this.channel.postMessage({type:e,identifier:a,name:this.name}),new Promise((c,u)=>{const l=()=>{this.channel.postMessage({type:t,identifier:a,name:this.name})};o?.signal?.addEventListener("abort",l,{once:!0});const d=h=>{if(h.data?.identifier===a&&(h.data?.type===r&&(this.channel.removeEventListener("message",d),o?.signal?.removeEventListener("abort",l),c(()=>{this.channel.postMessage({type:i,identifier:a,name:this.name})})),h.data.type===s)){this.channel.removeEventListener("message",d),o?.signal?.removeEventListener("abort",l);const p=new Error;h.data.error!=null&&(p.message=h.data.error.message,p.name=h.data.error.name,p.stack=h.data.error.stack),u(p)}};this.channel.addEventListener("message",d)})}}const jv=n=>{if(n=Object.assign({},Yv,n),!!globalThis.document||n.singleProcess){const t=new BroadcastChannel(ah),r=new nt;return t.addEventListener("message",Hc(r,t,"requestReadLock","abortReadLockRequest",Xd,Zd,eh,jd,Jd)),t.addEventListener("message",Hc(r,t,"requestWriteLock","abortWriteLockRequest",th,nh,ih,rh,sh)),r}return new Zv(n.name)},Mt=new Map;let Vn;function ch(n){return typeof n?.readLock=="function"&&typeof n?.writeLock=="function"}function Jv(n){if(Vn==null&&(Vn=jv(n),!ch(Vn))){const e=Vn;e.addEventListener("requestReadLock",t=>{const r=t.detail.name,s=t.detail.identifier,i=Mt.get(r);if(i==null)return;const o=new AbortController,a=c=>{c.detail.name!==r||c.detail.identifier!==s||o.abort()};e.addEventListener("abortReadLockRequest",a),i.readLock({signal:o.signal}).then(async c=>{await t.detail.handler().finally(()=>{c()})}).catch(c=>{t.detail.onError(c)}).finally(()=>{e.removeEventListener("abortReadLockRequest",a)})}),e.addEventListener("requestWriteLock",t=>{const r=t.detail.name,s=t.detail.identifier,i=Mt.get(r);if(i==null)return;const o=new AbortController,a=c=>{c.detail.name!==r||c.detail.identifier!==s||o.abort()};e.addEventListener("abortWriteLockRequest",a),i.writeLock({signal:o.signal}).then(async c=>{await t.detail.handler().finally(()=>{c()})}).catch(c=>{t.detail.onError(c)}).finally(()=>{e.removeEventListener("abortWriteLockRequest",a)})}),e.addEventListener("finalizeRequest",t=>{const r=t.detail.name,s=Mt.get(r);s?.finalize()})}return Vn}async function Ti(n,e){let t,r;const s=new Promise((o,a)=>{t=o,r=a}),i=()=>{r(new Cn)};return e?.signal?.addEventListener("abort",i,{once:!0}),n.add(async()=>{await new Promise(o=>{t(()=>{e?.signal?.removeEventListener("abort",i),o()})})},{signal:e?.signal}).catch(o=>{r(o)}),s}const e1=(n,e)=>{let t=Mt.get(n);if(t!=null)return t;const r=Jv(e);if(ch(r))return t=r,Mt.set(n,t),t;const s=new Vc({concurrency:1});let i;return t={async readLock(o){if(i!=null)return Ti(i,o);i=new Vc({concurrency:e.concurrency,autoStart:!1});const a=i,c=Ti(i,o);return s.add(async()=>{a.start(),await a.onIdle().then(()=>{i===a&&(i=null)})}),c},async writeLock(o){return i=null,Ti(s,o)},finalize:()=>{Mt.delete(n)},queue:s},Mt.set(n,t),e.autoFinalize===!0&&s.addEventListener("idle",()=>{t.finalize()},{once:!0}),t},t1={name:"lock",concurrency:1/0,singleProcess:!1,autoFinalize:!1};function n1(n){const e=Object.assign({},t1,n);return e1(e.name,e)}const r1=36e5,s1=216e5;var Ft;(function(n){(function(t){let r;t.codec=()=>(r==null&&(r=fe((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&s.value.byteLength>0&&(i.uint32(18),i.bytes(s.value)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={key:"",value:j(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const u=s.uint32();switch(u>>>3){case 1:{a.key=s.string();break}case 2:{a.value=s.bytes();break}default:{s.skipType(u&7);break}}}return a})),r),t.encode=s=>he(s,t.codec()),t.decode=(s,i)=>de(s,t.codec(),i)})(n.Peer$metadataEntry||(n.Peer$metadataEntry={})),function(t){let r;t.codec=()=>(r==null&&(r=fe((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&(i.uint32(18),Bs.codec().encode(s.value,i)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={key:""},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const u=s.uint32();switch(u>>>3){case 1:{a.key=s.string();break}case 2:{a.value=Bs.codec().decode(s,s.uint32(),{limits:o.limits?.value});break}default:{s.skipType(u&7);break}}}return a})),r),t.encode=s=>he(s,t.codec()),t.decode=(s,i)=>de(s,t.codec(),i)}(n.Peer$tagsEntry||(n.Peer$tagsEntry={}));let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.addresses!=null)for(const i of t.addresses)r.uint32(10),Us.codec().encode(i,r);if(t.protocols!=null)for(const i of t.protocols)r.uint32(18),r.string(i);if(t.publicKey!=null&&(r.uint32(34),r.bytes(t.publicKey)),t.peerRecordEnvelope!=null&&(r.uint32(42),r.bytes(t.peerRecordEnvelope)),t.metadata!=null&&t.metadata.size!==0)for(const[i,o]of t.metadata.entries())r.uint32(50),n.Peer$metadataEntry.codec().encode({key:i,value:o},r);if(t.tags!=null&&t.tags.size!==0)for(const[i,o]of t.tags.entries())r.uint32(58),n.Peer$tagsEntry.codec().encode({key:i,value:o},r);t.updated!=null&&(r.uint32(64),r.uint64Number(t.updated)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={addresses:[],protocols:[],metadata:new Map,tags:new Map},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{if(s.limits?.addresses!=null&&i.addresses.length===s.limits.addresses)throw new mt('Decode error - map field "addresses" had too many elements');i.addresses.push(Us.codec().decode(t,t.uint32(),{limits:s.limits?.addresses$}));break}case 2:{if(s.limits?.protocols!=null&&i.protocols.length===s.limits.protocols)throw new mt('Decode error - map field "protocols" had too many elements');i.protocols.push(t.string());break}case 4:{i.publicKey=t.bytes();break}case 5:{i.peerRecordEnvelope=t.bytes();break}case 6:{if(s.limits?.metadata!=null&&i.metadata.size===s.limits.metadata)throw new Ma('Decode error - map field "metadata" had too many elements');const c=n.Peer$metadataEntry.codec().decode(t,t.uint32());i.metadata.set(c.key,c.value);break}case 7:{if(s.limits?.tags!=null&&i.tags.size===s.limits.tags)throw new Ma('Decode error - map field "tags" had too many elements');const c=n.Peer$tagsEntry.codec().decode(t,t.uint32(),{limits:{value:s.limits?.tags$value}});i.tags.set(c.key,c.value);break}case 8:{i.updated=t.uint64Number();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(Ft||(Ft={}));var Us;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.multiaddr!=null&&t.multiaddr.byteLength>0&&(r.uint32(10),r.bytes(t.multiaddr)),t.isCertified!=null&&(r.uint32(16),r.bool(t.isCertified)),t.observed!=null&&(r.uint32(24),r.uint64Number(t.observed)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={multiaddr:j(0)},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.multiaddr=t.bytes();break}case 2:{i.isCertified=t.bool();break}case 3:{i.observed=t.uint64Number();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(Us||(Us={}));var Bs;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.value!=null&&t.value!==0&&(r.uint32(8),r.uint32(t.value)),t.expiry!=null&&(r.uint32(16),r.uint64(t.expiry)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={value:0},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.value=t.uint32();break}case 2:{i.expiry=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(Bs||(Bs={}));function i1(n,e){if(n.publicKey!=null||e.publicKey==null)return n;let t;n.type==="RSA"&&(t=n.toMultihash());const r=Pt(e.publicKey,t);return lr(r)}function o1(n,e,t){const r=Ft.decode(e);return Yn(n,r,t)}function Yn(n,e,t){const r=new Map,s=BigInt(Date.now());for(const[i,o]of e.tags.entries())o.expiry!=null&&o.expiry<s||r.set(i,o);return{...e,id:i1(n,e),addresses:e.addresses.filter(({observed:i})=>i!=null&&i>Date.now()-t).map(({multiaddr:i,isCertified:o})=>({multiaddr:W(i),isCertified:o??!1})),metadata:e.metadata,peerRecordEnvelope:e.peerRecordEnvelope??void 0,tags:r}}function a1(n,e){return c1(n.addresses,e.addresses)&&l1(n.protocols,e.protocols)&&u1(n.publicKey,e.publicKey)&&d1(n.peerRecordEnvelope,e.peerRecordEnvelope)&&h1(n.metadata,e.metadata)&&f1(n.tags,e.tags)}function c1(n,e){return uh(n,e,(t,r)=>!(t.isCertified!==r.isCertified||!Te(t.multiaddr,r.multiaddr)))}function l1(n,e){return uh(n,e,(t,r)=>t===r)}function u1(n,e){return lh(n,e)}function d1(n,e){return lh(n,e)}function h1(n,e){return dh(n,e,(t,r)=>Te(t,r))}function f1(n,e){return dh(n,e,(t,r)=>t.value===r.value&&t.expiry===r.expiry)}function lh(n,e){return n==null&&e==null?!0:n!=null&&e!=null?Te(n,e):!1}function uh(n,e,t){if(n.length!==e.length)return!1;for(let r=0;r<n.length;r++)if(!t(n[r],e[r]))return!1;return!0}function dh(n,e,t){if(n.size!==e.size)return!1;for(const[r,s]of n.entries()){const i=e.get(r);if(i==null||!t(s,i))return!1}return!0}const hh="/peers/";function Zr(n){if(!Zn(n)||n.type==null)throw new K("Invalid PeerId");const e=n.toCID().toString();return new De(`${hh}${e}`)}async function p1(n,e,t,r,s){const i=new Map;for(const o of t){if(o==null)continue;if(o.multiaddr instanceof Uint8Array&&(o.multiaddr=W(o.multiaddr)),!Xs(o.multiaddr))throw new K("Multiaddr was invalid");if(!await e(n,o.multiaddr,s))continue;const a=o.isCertified??!1,c=o.multiaddr.toString(),u=i.get(c);u!=null?o.isCertified=u.isCertified||a:i.set(c,{multiaddr:o.multiaddr,isCertified:a})}return[...i.values()].sort((o,a)=>o.multiaddr.toString().localeCompare(a.multiaddr.toString())).map(({isCertified:o,multiaddr:a})=>{const c=a.getPeerId();return n.equals(c)&&(a=a.decapsulate(W(`/p2p/${n}`))),{isCertified:o,multiaddr:a.bytes}})}async function Pi(n,e,t,r){if(e==null)throw new K("Invalid PeerData");if(e.publicKey!=null&&n.publicKey!=null&&!e.publicKey.equals(n.publicKey))throw new K("publicKey bytes do not match peer id publicKey bytes");const s=r.existingPeer?.peer;if(s!=null&&!n.equals(s.id))throw new K("peer id did not match existing peer id");let i=s?.addresses??[],o=new Set(s?.protocols??[]),a=s?.metadata??new Map,c=s?.tags??new Map,u=s?.peerRecordEnvelope;if(t==="patch"){if((e.multiaddrs!=null||e.addresses!=null)&&(i=[],e.multiaddrs!=null&&i.push(...e.multiaddrs.map(h=>({isCertified:!1,multiaddr:h}))),e.addresses!=null&&i.push(...e.addresses)),e.protocols!=null&&(o=new Set(e.protocols)),e.metadata!=null){const h=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);a=jr(h,{validate:Gc})}if(e.tags!=null){const h=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags);c=jr(h,{validate:Qc,map:Yc})}e.peerRecordEnvelope!=null&&(u=e.peerRecordEnvelope)}if(t==="merge"){if(e.multiaddrs!=null&&i.push(...e.multiaddrs.map(h=>({isCertified:!1,multiaddr:h}))),e.addresses!=null&&i.push(...e.addresses),e.protocols!=null&&(o=new Set([...o,...e.protocols])),e.metadata!=null){const h=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);for(const[p,g]of h)g==null?a.delete(p):a.set(p,g);a=jr([...a.entries()],{validate:Gc})}if(e.tags!=null){const h=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags),p=new Map(c);for(const[g,m]of h)m==null?p.delete(g):p.set(g,m);c=jr([...p.entries()],{validate:Qc,map:Yc})}e.peerRecordEnvelope!=null&&(u=e.peerRecordEnvelope)}let l;s?.id.publicKey!=null?l=ft(s.id.publicKey):e.publicKey!=null?l=ft(e.publicKey):n.publicKey!=null&&(l=ft(n.publicKey));const d={addresses:await p1(n,r.addressFilter??(async()=>!0),i,r.existingPeer?.peerPB.addresses,r),protocols:[...o.values()].sort((h,p)=>h.localeCompare(p)),metadata:a,tags:c,publicKey:l,peerRecordEnvelope:u};return d.addresses.forEach(h=>{h.observed=r.existingPeer?.peerPB.addresses?.find(p=>Te(p.multiaddr,p.multiaddr))?.observed??Date.now()}),n.type!=="RSA"&&delete d.publicKey,d}function jr(n,e){const t=new Map;for(const[r,s]of n)s!=null&&e.validate(r,s);for(const[r,s]of n.sort(([i],[o])=>i.localeCompare(o)))s!=null&&t.set(r,e.map?.(r,s)??s);return t}function Gc(n,e){if(typeof n!="string")throw new K("Metadata key must be a string");if(!(e instanceof Uint8Array))throw new K("Metadata value must be a Uint8Array")}function Qc(n,e){if(typeof n!="string")throw new K("Tag name must be a string");if(e.value!=null){if(parseInt(`${e.value}`,10)!==e.value)throw new K("Tag value must be an integer");if(e.value<0||e.value>100)throw new K("Tag value must be between 0-100")}if(e.ttl!=null){if(parseInt(`${e.ttl}`,10)!==e.ttl)throw new K("Tag ttl must be an integer");if(e.ttl<0)throw new K("Tag ttl must be between greater than 0")}}function Yc(n,e){let t;e.expiry!=null&&(t=e.expiry),e.ttl!=null&&(t=BigInt(Date.now()+Number(e.ttl)));const r={value:e.value??0};return t!=null&&(r.expiry=t),r}function fh(n){const e=n.toString().split("/")[2],t=re.parse(e,It);return Cr(t)}function Di(n,e,t){const r=fh(n);return o1(r,e,t)}function g1(n,e){return{prefix:hh,filters:(n.filters??[]).map(t=>({key:r,value:s})=>t(Di(r,s,e))),orders:(n.orders??[]).map(t=>(r,s)=>t(Di(r.key,r.value,e),Di(s.key,s.value,e)))}}class m1{peerId;datastore;locks;addressFilter;log;maxAddressAge;maxPeerAge;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.peerId=e.peerId,this.datastore=e.datastore,this.addressFilter=t.addressFilter,this.locks=Xb({name:"libp2p_peer_store_locks",metrics:e.metrics}),this.maxAddressAge=t.maxAddressAge??r1,this.maxPeerAge=t.maxPeerAge??s1}getLock(e){let t=this.locks.get(e);return t==null&&(t={refs:0,lock:n1({name:e.toString(),singleProcess:!0})},this.locks.set(e,t)),t.refs++,t}maybeRemoveLock(e,t){t.refs--,t.refs===0&&(t.lock.finalize(),this.locks.delete(e))}async getReadLock(e,t){const r=this.getLock(e);try{const s=await r.lock.readLock(t);return()=>{s(),this.maybeRemoveLock(e,r)}}catch(s){throw this.maybeRemoveLock(e,r),s}}async getWriteLock(e,t){const r=this.getLock(e);try{const s=await r.lock.writeLock(t);return()=>{s(),this.maybeRemoveLock(e,r)}}catch(s){throw this.maybeRemoveLock(e,r),s}}async has(e,t){try{return await this.load(e,t),!0}catch(r){if(r.name!=="NotFoundError")throw r}return!1}async delete(e,t){this.peerId.equals(e)||await this.datastore.delete(Zr(e),t)}async load(e,t){const r=Zr(e),s=await this.datastore.get(r,t),i=Ft.decode(s);if(this.#t(e,i))throw await this.datastore.delete(r,t),new Vi;return Yn(e,i,this.peerId.equals(e)?1/0:this.maxAddressAge)}async save(e,t,r){const s=await this.#e(e,r),i=await Pi(e,t,"patch",{...r,addressFilter:this.addressFilter});return this.#n(e,i,s)}async patch(e,t,r){const s=await this.#e(e,r),i=await Pi(e,t,"patch",{...r,addressFilter:this.addressFilter,existingPeer:s});return this.#n(e,i,s)}async merge(e,t,r){const s=await this.#e(e,r),i=await Pi(e,t,"merge",{addressFilter:this.addressFilter,existingPeer:s});return this.#n(e,i,s)}async*all(e){for await(const{key:t,value:r}of this.datastore.query(g1(e??{},this.maxAddressAge),e)){const s=fh(t);if(s.equals(this.peerId))continue;const i=Ft.decode(r);if(this.#t(s,i)){await this.datastore.delete(t,e);continue}yield Yn(s,i,this.peerId.equals(s)?1/0:this.maxAddressAge)}}async#e(e,t){try{const r=Zr(e),s=await this.datastore.get(r,t),i=Ft.decode(s);if(this.#t(e,i))throw await this.datastore.delete(r,t),new Vi;return{peerPB:i,peer:Yn(e,i,this.maxAddressAge)}}catch(r){r.name!=="NotFoundError"&&this.log.error("invalid peer data found in peer store - %e",r)}}async#n(e,t,r,s){t.updated=Date.now();const i=Ft.encode(t);return await this.datastore.put(Zr(e),i,s),{peer:Yn(e,t,this.maxAddressAge),previous:r?.peer,updated:r==null||!a1(t,r.peerPB)}}#t(e,t){if(t.updated==null)return!0;if(this.peerId.equals(e))return!1;const r=t.updated<Date.now()-this.maxPeerAge,s=Date.now()-this.maxAddressAge,i=t.addresses.filter(o=>o.observed!=null&&o.observed>s);return r&&i.length===0}}class y1{store;events;peerId;log;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.events=e.events,this.peerId=e.peerId,this.store=new m1(e,t)}[Symbol.toStringTag]="@libp2p/peer-store";async forEach(e,t){for await(const r of this.store.all(t))e(r)}async all(e){return bo(this.store.all(e))}async delete(e,t){const r=await this.store.getReadLock(e,t);try{await this.store.delete(e,t)}finally{r()}}async has(e,t){const r=await this.store.getReadLock(e,t);try{return await this.store.has(e,t)}finally{this.log.trace("has release read lock"),r?.()}}async get(e,t){const r=await this.store.getReadLock(e,t);try{return await this.store.load(e,t)}finally{r?.()}}async getInfo(e,t){const r=await this.get(e,t);return{id:r.id,multiaddrs:r.addresses.map(({multiaddr:s})=>s)}}async save(e,t,r){const s=await this.store.getWriteLock(e,r);try{const i=await this.store.save(e,t,r);return this.#e(e,i),i.peer}finally{s?.()}}async patch(e,t,r){const s=await this.store.getWriteLock(e,r);try{const i=await this.store.patch(e,t,r);return this.#e(e,i),i.peer}finally{s?.()}}async merge(e,t,r){const s=await this.store.getWriteLock(e,r);try{const i=await this.store.merge(e,t,r);return this.#e(e,i),i.peer}finally{s?.()}}async consumePeerRecord(e,t,r){const s=Zn(t)?t:Zn(t?.expectedPeer)?t.expectedPeer:void 0,i=Zn(t)||t===void 0?r:t,o=await et.openAndCertify(e,$e.DOMAIN,i),a=Cr(o.publicKey.toCID());if(s?.equals(a)===!1)return this.log("envelope peer id was not the expected peer id - expected: %p received: %p",s,a),!1;const c=$e.createFromProtobuf(o.payload);let u;try{u=await this.get(a,i)}catch(l){if(l.name!=="NotFoundError")throw l}if(u?.peerRecordEnvelope!=null){const l=et.createFromProtobuf(u.peerRecordEnvelope),d=$e.createFromProtobuf(l.payload);if(d.seqNumber>=c.seqNumber)return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",d.seqNumber,c.seqNumber),!1}return await this.patch(c.peerId,{peerRecordEnvelope:e,addresses:c.multiaddrs.map(l=>({isCertified:!0,multiaddr:l}))},i),!0}#e(e,t){t.updated&&(this.peerId.equals(e)?this.events.safeDispatchEvent("self:peer:update",{detail:t}):this.events.safeDispatchEvent("peer:update",{detail:t}))}}function w1(n,e={}){return new y1(n,e)}class $s extends Error{static name="NotFoundError";static code="ERR_NOT_FOUND";name=$s.name;code=$s.code;constructor(e="Not Found"){super(e)}}function b1(n){return n[Symbol.asyncIterator]!=null}function rn(n,e){let t=0;if(b1(n))return async function*(){for await(const c of n)await e(c,t++)&&(yield c)}();const r=zu(n),{value:s,done:i}=r.next();if(i===!0)return function*(){}();const o=e(s,t++);if(typeof o.then=="function")return async function*(){await o&&(yield s);for(const c of r)await e(c,t++)&&(yield c)}();const a=e;return function*(){o===!0&&(yield s);for(const c of r)a(c,t++)&&(yield c)}()}function E1(n){return n[Symbol.asyncIterator]!=null}function Xc(n,e){return E1(n)?async function*(){yield*(await bo(n)).sort(e)}():function*(){yield*bo(n).sort(e)}()}function v1(n){return n[Symbol.asyncIterator]!=null}function Zc(n,e){return v1(n)?async function*(){let t=0;if(!(e<1)){for await(const r of n)if(yield r,t++,t===e)return}}():function*(){let t=0;if(!(e<1)){for(const r of n)if(yield r,t++,t===e)return}}()}class S1{put(e,t,r){return Promise.reject(new Error(".put is not implemented"))}get(e,t){return Promise.reject(new Error(".get is not implemented"))}has(e,t){return Promise.reject(new Error(".has is not implemented"))}delete(e,t){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(e,t={}){for await(const{key:r,value:s}of e)await this.put(r,s,t),yield r}async*getMany(e,t={}){for await(const r of e)yield{key:r,value:await this.get(r,t)}}async*deleteMany(e,t={}){for await(const r of e)await this.delete(r,t),yield r}batch(){let e=[],t=[];return{put(r,s){e.push({key:r,value:s})},delete(r){t.push(r)},commit:async r=>{await go(this.putMany(e,r)),e=[],await go(this.deleteMany(t,r)),t=[]}}}async*_all(e,t){throw new Error("._all is not implemented")}async*_allKeys(e,t){throw new Error("._allKeys is not implemented")}query(e,t){let r=this._all(e,t);if(e.prefix!=null){const s=e.prefix;r=rn(r,i=>i.key.toString().startsWith(s))}if(Array.isArray(e.filters)&&(r=e.filters.reduce((s,i)=>rn(s,i),r)),Array.isArray(e.orders)&&(r=e.orders.reduce((s,i)=>Xc(s,i),r)),e.offset!=null){let s=0;const i=e.offset;r=rn(r,()=>s++>=i)}return e.limit!=null&&(r=Zc(r,e.limit)),r}queryKeys(e,t){let r=this._allKeys(e,t);if(e.prefix!=null){const s=e.prefix;r=rn(r,i=>i.toString().startsWith(s))}if(Array.isArray(e.filters)&&(r=e.filters.reduce((s,i)=>rn(s,i),r)),Array.isArray(e.orders)&&(r=e.orders.reduce((s,i)=>Xc(s,i),r)),e.offset!=null){const s=e.offset;let i=0;r=rn(r,()=>i++>=s)}return e.limit!=null&&(r=Zc(r,e.limit)),r}}class x1 extends S1{data;constructor(){super(),this.data=new Map}put(e,t,r){return r?.signal?.throwIfAborted(),this.data.set(e.toString(),t),e}get(e,t){t?.signal?.throwIfAborted();const r=this.data.get(e.toString());if(r==null)throw new $s;return r}has(e,t){return t?.signal?.throwIfAborted(),this.data.has(e.toString())}delete(e,t){t?.signal?.throwIfAborted(),this.data.delete(e.toString())}*_all(e,t){t?.signal?.throwIfAborted();for(const[r,s]of this.data.entries())yield{key:new De(r),value:s},t?.signal?.throwIfAborted()}*_allKeys(e,t){t?.signal?.throwIfAborted();for(const r of this.data.keys())yield new De(r),t?.signal?.throwIfAborted()}}class A1 extends Map{metric;constructor(e){super();const{name:t,metrics:r}=e;this.metric=r.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){const t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function bt(n){const{name:e,metrics:t}=n;let r;return t!=null?r=new A1({name:e,metrics:t}):r=new Map,r}const jc=864e13,_1=448,Li=449,C1=53,I1=54,T1=55,P1=56;class D1{log;mappings;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:dns-mappings"),this.mappings=bt({name:"libp2p_address_manager_dns_mappings",metrics:e.metrics})}has(e){const t=this.findHost(e);for(const r of this.mappings.values())if(r.domain===t)return!0;return!1}add(e,t){t.forEach(r=>{this.log("add DNS mapping %s to %s",r,e);const s=ti(r)===!0;this.mappings.set(r,{domain:e,verified:s,expires:s?jc-Date.now():0,lastVerified:s?jc-Date.now():void 0})})}remove(e){const t=this.findHost(e);let r=!1;for(const[s,i]of this.mappings.entries())i.domain===t&&(this.log("removing %s to %s DNS mapping %e",s,i.domain,new Error("where")),this.mappings.delete(s),r=r||i.verified);return r}getAll(e){const t=[];for(let r=0;r<e.length;r++){const i=e[r].multiaddr.stringTuples(),o=i[0][1];if(o!=null)for(const[a,c]of this.mappings.entries()){if(o!==a)continue;this.maybeAddSNITuple(i,c.domain)&&(e.splice(r,1),r--,t.push({multiaddr:W(`/${i.map(l=>[Lr(l[0]).name,l[1]].join("/")).join("/")}`),verified:c.verified,type:"dns-mapping",expires:c.expires,lastVerified:c.lastVerified}))}}return t}maybeAddSNITuple(e,t){for(let r=0;r<e.length;r++)if(e[r][0]===_1&&e[r+1]?.[0]!==Li)return e.splice(r+1,0,[Li,t]),!0;return!1}confirm(e,t){const r=this.findHost(e);let s=!1;for(const[i,o]of this.mappings.entries())o.domain===r&&(this.log("marking %s to %s DNS mapping as verified",i,o.domain),s=o.verified,o.verified=!0,o.expires=Date.now()+t,o.lastVerified=Date.now());return s}unconfirm(e,t){const r=this.findHost(e);let s=!1;for(const[i,o]of this.mappings.entries())o.domain===r&&(this.log("removing verification of %s to %s DNS mapping",i,o.domain),s=s||o.verified,o.verified=!1,o.expires=Date.now()+t);return s}findHost(e){for(const t of e.stringTuples())if(t[0]===Li||t[0]===C1||t[0]===I1||t[0]===T1||t[0]===P1)return t[1]}}const ki=4,Ri=41,Ni=6,L1=273;class k1{log;mappings;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:ip-mappings"),this.mappings=bt({name:"libp2p_address_manager_ip_mappings",metrics:e.metrics})}has(e){const t=e.stringTuples();for(const r of this.mappings.values())for(const s of r)if(s.externalIp===t[0][1])return!0;return!1}add(e,t,r,s=t,i="tcp"){const o=`${e}-${t}-${i}`,a=this.mappings.get(o)??[],c={internalIp:e,internalPort:t,externalIp:r,externalPort:s,externalFamily:Sn(r)?4:6,protocol:i,verified:!1,expires:0};a.push(c),this.mappings.set(o,a)}remove(e){const t=e.stringTuples(),r=t[0][1]??"",s=t[1][0]===Ni?"tcp":"udp",i=parseInt(t[1][1]??"0");let o=!1;for(const[a,c]of this.mappings.entries()){for(let u=0;u<c.length;u++){const l=c[u];l.externalIp===r&&l.externalPort===i&&l.protocol===s&&(this.log("removing %s:%s to %s:%s %s IP mapping",l.externalIp,l.externalPort,r,i,s),o=o||l.verified,c.splice(u,1),u--)}c.length===0&&this.mappings.delete(a)}return o}getAll(e){const t=[];for(const{multiaddr:r}of e){const s=r.stringTuples();let i;if((s[0][0]===ki||s[0][0]===Ri)&&s[1][0]===Ni?i=`${s[0][1]}-${s[1][1]}-tcp`:(s[0][0]===ki||s[0][0]===Ri)&&s[1][0]===L1&&(i=`${s[0][1]}-${s[1][1]}-udp`),i==null)continue;const o=this.mappings.get(i);if(o!=null)for(const a of o)s[0][0]=a.externalFamily===4?ki:Ri,s[0][1]=a.externalIp,s[1][1]=`${a.externalPort}`,t.push({multiaddr:W(`/${s.map(c=>[Lr(c[0]).name,c[1]].join("/")).join("/")}`),verified:a.verified,type:"ip-mapping",expires:a.expires,lastVerified:a.lastVerified})}return t}confirm(e,t){const s=e.stringTuples()[0][1];let i=!1;for(const o of this.mappings.values())for(const a of o)a.externalIp===s&&(this.log("marking %s to %s IP mapping as verified",a.internalIp,a.externalIp),i=a.verified,a.verified=!0,a.expires=Date.now()+t,a.lastVerified=Date.now());return i}unconfirm(e,t){const r=e.stringTuples(),s=r[0][1]??"",i=r[1][0]===Ni?"tcp":"udp",o=parseInt(r[1][1]??"0");let a=!1;for(const c of this.mappings.values())for(let u=0;u<c.length;u++){const l=c[u];l.externalIp===s&&l.externalPort===o&&l.protocol===i&&(this.log("removing verification of %s:%s to %s:%s %s IP mapping",l.externalIp,l.externalPort,s,o,i),a=a||l.verified,l.verified=!1,l.expires=Date.now()+t)}return a}}function R1(n){try{for(const{code:e,value:t}of n.getComponents())if(e!==Qt&&t!=null){if(e===Vt)return t.startsWith("169.254.");if(e===Ke)return t.toLowerCase().startsWith("fe80")}}catch{}return!1}const N1={maxObservedAddresses:10};class O1{log;addresses;maxObservedAddresses;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=bt({name:"libp2p_address_manager_observed_addresses",metrics:e.metrics}),this.maxObservedAddresses=t.maxObservedAddresses??N1.maxObservedAddresses}has(e){return this.addresses.has(e.toString())}removePrefixed(e){for(const t of this.addresses.keys())t.toString().startsWith(e)&&this.addresses.delete(t)}add(e){this.addresses.size!==this.maxObservedAddresses&&(wr(e)||R1(e)||(this.log("adding observed address %a",e),this.addresses.set(e.toString(),{verified:!1,expires:0})))}getAll(){return Array.from(this.addresses).map(([e,t])=>({multiaddr:W(e),verified:t.verified,type:"observed",expires:t.expires,lastVerified:t.lastVerified}))}remove(e){const t=this.addresses.get(e.toString())?.verified??!1;return this.log("removing observed address %a",e),this.addresses.delete(e.toString()),t}confirm(e,t){const r=e.toString(),s=this.addresses.get(r)??{verified:!1,expires:Date.now()+t,lastVerified:Date.now()},i=s.verified;return s.verified=!0,s.expires=Date.now()+t,s.lastVerified=Date.now(),this.log("marking observed address %a as verified",r),this.addresses.set(r,s),i}}const M1=[Vt,Ke,Tr,Pr,Mn,Dr];function Jc(n){try{for(const{code:e}of n.getComponents())if(e!==Qt)return M1.includes(e)}catch{}return!1}const F1={maxObservedAddresses:10};class U1{log;addresses;maxObservedAddresses;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=bt({name:"libp2p_address_manager_transport_addresses",metrics:e.metrics}),this.maxObservedAddresses=t.maxObservedAddresses??F1.maxObservedAddresses}get(e,t){if(wr(e))return{multiaddr:e,verified:!0,type:"transport",expires:Date.now()+t,lastVerified:Date.now()};const r=this.toKey(e);let s=this.addresses.get(r);return s==null&&(s={verified:!Jc(e),expires:0},this.addresses.set(r,s)),{multiaddr:e,verified:s.verified,type:"transport",expires:s.expires,lastVerified:s.lastVerified}}has(e){const t=this.toKey(e);return this.addresses.has(t)}remove(e){const t=this.toKey(e),r=this.addresses.get(t)?.verified??!1;return this.log("removing observed address %a",e),this.addresses.delete(t),r}confirm(e,t){const r=this.toKey(e),s=this.addresses.get(r)??{verified:!1,expires:0,lastVerified:0},i=s.verified;return s.verified=!0,s.expires=Date.now()+t,s.lastVerified=Date.now(),this.addresses.set(r,s),i}unconfirm(e,t){const r=this.toKey(e),s=this.addresses.get(r)??{verified:!1,expires:0},i=s.verified;return s.verified=!1,s.expires=Date.now()+t,this.addresses.set(r,s),i}toKey(e){if(Jc(e)){const t=e.toOptions();return`${t.host}-${t.port}-${t.transport}`}return e.toString()}}const el=6e4,tl={addressVerificationTTL:el*10,addressVerificationRetry:el*5},B1=n=>n;function Oi(n,e){const t=n.getPeerId();return t!=null&&yt(t).equals(e)&&(n=n.decapsulate(W(`/p2p/${e.toString()}`))),n}class $1{log;components;listen;announce;appendAnnounce;announceFilter;observed;dnsMappings;ipMappings;transportAddresses;observedAddressFilter;addressVerificationTTL;addressVerificationRetry;constructor(e,t={}){const{listen:r=[],announce:s=[],appendAnnounce:i=[]}=t;this.components=e,this.log=e.logger.forComponent("libp2p:address-manager"),this.listen=r.map(o=>o.toString()),this.announce=new Set(s.map(o=>o.toString())),this.appendAnnounce=new Set(i.map(o=>o.toString())),this.observed=new O1(e,t),this.dnsMappings=new D1(e,t),this.ipMappings=new k1(e,t),this.transportAddresses=new U1(e,t),this.announceFilter=t.announceFilter??B1,this.observedAddressFilter=yr(1024),this.addressVerificationTTL=t.addressVerificationTTL??tl.addressVerificationTTL,this.addressVerificationRetry=t.addressVerificationRetry??tl.addressVerificationRetry,this._updatePeerStoreAddresses=Os(this._updatePeerStoreAddresses.bind(this),1e3),e.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),e.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}[Symbol.toStringTag]="@libp2p/address-manager";_updatePeerStoreAddresses(){const e=this.getAddresses().map(t=>t.getPeerId()===this.components.peerId.toString()?t.decapsulate(`/p2p/${this.components.peerId.toString()}`):t);this.components.peerStore.patch(this.components.peerId,{multiaddrs:e}).catch(t=>{this.log.error("error updating addresses",t)})}getListenAddrs(){return Array.from(this.listen).map(e=>W(e))}getAnnounceAddrs(){return Array.from(this.announce).map(e=>W(e))}getAppendAnnounceAddrs(){return Array.from(this.appendAnnounce).map(e=>W(e))}getObservedAddrs(){return this.observed.getAll().map(e=>e.multiaddr)}addObservedAddr(e){const t=e.stringTuples(),r=`${t[0][1]}:${t[1][1]}`;this.observedAddressFilter.has(r)||(this.observedAddressFilter.add(r),e=Oi(e,this.components.peerId),!this.ipMappings.has(e)&&(this.dnsMappings.has(e)||this.observed.add(e)))}confirmObservedAddr(e,t){e=Oi(e,this.components.peerId);let r=!0;(t?.type==="transport"||this.transportAddresses.has(e))&&!this.transportAddresses.confirm(e,t?.ttl??this.addressVerificationTTL)&&r&&(r=!1),(t?.type==="dns-mapping"||this.dnsMappings.has(e))&&!this.dnsMappings.confirm(e,t?.ttl??this.addressVerificationTTL)&&r&&(r=!1),(t?.type==="ip-mapping"||this.ipMappings.has(e))&&!this.ipMappings.confirm(e,t?.ttl??this.addressVerificationTTL)&&r&&(r=!1),(t?.type==="observed"||this.observed.has(e))&&(this.maybeUpgradeToIPMapping(e)?(this.ipMappings.confirm(e,t?.ttl??this.addressVerificationTTL),r=!1):!this.observed.confirm(e,t?.ttl??this.addressVerificationTTL)&&r&&(r=!1)),r||this._updatePeerStoreAddresses()}removeObservedAddr(e,t){e=Oi(e,this.components.peerId),this.observed.has(e)&&this.observed.remove(e),this.transportAddresses.has(e)&&this.transportAddresses.unconfirm(e,t?.ttl??this.addressVerificationRetry),this.dnsMappings.has(e)&&this.dnsMappings.unconfirm(e,t?.ttl??this.addressVerificationRetry),this.ipMappings.has(e)&&this.ipMappings.unconfirm(e,t?.ttl??this.addressVerificationRetry)}getAddresses(){const e=new Set,t=this.getAddressesWithMetadata().filter(r=>{if(!r.verified)return!1;const s=r.multiaddr.toString();return e.has(s)?!1:(e.add(s),!0)}).map(r=>r.multiaddr);return this.announceFilter(t.map(r=>{const s=W(r);return s.getComponents().pop()?.value===this.components.peerId.toString()?s:s.encapsulate(`/p2p/${this.components.peerId.toString()}`)}))}getAddressesWithMetadata(){const e=this.getAnnounceAddrs();if(e.length>0)return this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(e)}),e.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()}));let t=[];t=t.concat(this.components.transportManager.getAddrs().map(s=>this.transportAddresses.get(s,this.addressVerificationTTL)));const r=this.getAppendAnnounceAddrs();return r.length>0&&(this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(r)}),t=t.concat(r.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()})))),t=t.concat(this.observed.getAll()),t=t.concat(this.ipMappings.getAll(t)),t=t.concat(this.dnsMappings.getAll(t)),t}addDNSMapping(e,t){this.dnsMappings.add(e,t)}removeDNSMapping(e){this.dnsMappings.remove(W(`/dns/${e}`))&&this._updatePeerStoreAddresses()}addPublicAddressMapping(e,t,r,s=t,i="tcp"){this.ipMappings.add(e,t,r,s,i),this.observed.removePrefixed(`/ip${Sn(r)?4:6}/${r}/${i}/${s}`)}removePublicAddressMapping(e,t,r,s=t,i="tcp"){this.ipMappings.remove(W(`/ip${Sn(r)?4:6}/${r}/${i}/${s}`))&&this._updatePeerStoreAddresses()}maybeUpgradeToIPMapping(e){if(this.ipMappings.has(e))return!1;const t=e.toOptions();if(t.family===6||t.host==="127.0.0.1"||ti(t.host)===!0)return!1;const r=this.components.transportManager.getListeners(),s=[i=>gr.exactMatch(i)||ks.exactMatch(i),i=>Ls.exactMatch(i),i=>Pb.exactMatch(i)];for(const i of s){if(!i(e))continue;const o=r.filter(u=>u.getAddrs().filter(l=>l.toOptions().family===4&&i(l)).length>0);if(o.length!==1)continue;const a=o[0].getAddrs().filter(u=>u.toOptions().host!=="127.0.0.1").pop();if(a==null)continue;const c=a.toOptions();return this.observed.remove(e),this.ipMappings.add(c.host,c.port,t.host,t.port,t.transport),!0}return!1}}var nl;(function(n){n.NOT_STARTED_YET="The libp2p node is not started yet",n.NOT_FOUND="Not found"})(nl||(nl={}));class q1 extends Error{constructor(e="Missing service"){super(e),this.name="MissingServiceError"}}class z1 extends Error{constructor(e="Unmet service dependencies"){super(e),this.name="UnmetServiceDependenciesError"}}class Mi extends Error{constructor(e="No content routers available"){super(e),this.name="NoContentRoutersError"}}class rl extends Error{constructor(e="No peer routers available"){super(e),this.name="NoPeerRoutersError"}}class K1 extends Error{constructor(e="Should not try to find self"){super(e),this.name="QueriedForSelfError"}}class W1 extends Error{constructor(e="Unhandled protocol error"){super(e),this.name="UnhandledProtocolError"}}class V1 extends Error{constructor(e="Duplicate protocol handler error"){super(e),this.name="DuplicateProtocolHandlerError"}}class sl extends Error{constructor(e="Dial denied error"){super(e),this.name="DialDeniedError"}}class H1 extends Error{constructor(e="No transport was configured to listen on this address"){super(e),this.name="UnsupportedListenAddressError"}}class G1 extends Error{constructor(e="Configured listen addresses could not be listened on"){super(e),this.name="UnsupportedListenAddressesError"}}class Q1 extends Error{constructor(e="No valid addresses"){super(e),this.name="NoValidAddressesError"}}class Y1 extends Error{constructor(e="Connection intercepted"){super(e),this.name="ConnectionInterceptedError"}}class X1 extends Error{constructor(e="Connection denied"){super(e),this.name="ConnectionDeniedError"}}class Jr extends Error{constructor(e="Stream is not multiplexed"){super(e),this.name="MuxerUnavailableError"}}class es extends Error{constructor(e="Encryption failed"){super(e),this.name="EncryptionFailedError"}}class Z1 extends Error{constructor(e="Transport unavailable"){super(e),this.name="TransportUnavailableError"}}class j1 extends Error{constructor(e="Max recursive depth reached"){super(e),this.name="RecursionLimitError"}}class J1{components={};_started=!1;constructor(e={}){this.components={};for(const[t,r]of Object.entries(e))this.components[t]=r;this.components.logger==null&&(this.components.logger=Yd())}isStarted(){return this._started}async _invokeStartableMethod(e){await Promise.all(Object.values(this.components).filter(t=>To(t)).map(async t=>{await t[e]?.()}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const eS=["metrics","connectionProtector","dns"],tS=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function nS(n={}){const e=new J1(n);return new Proxy(e,{get(r,s,i){if(typeof s=="string"&&!tS.includes(s)){const o=e.components[s];if(o==null&&!eS.includes(s))throw new q1(`${s} not set`);return o}return Reflect.get(r,s,i)},set(r,s,i){return typeof s=="string"?e.components[s]=i:Reflect.set(r,s,i),!0}})}function rS(n){const e={};for(const t of Object.values(n.components))for(const r of sS(t))e[r]=!0;for(const t of Object.values(n.components))for(const r of iS(t))if(e[r]!==!0)throw new z1(`Service "${oS(t)}" required capability "${r}" but it was not provided by any component, you may need to add additional configuration when creating your node.`)}function sS(n){return Array.isArray(n?.[Ye])?n[Ye]:[]}function iS(n){return Array.isArray(n?.[os])?n[os]:[]}function oS(n){return n?.[Symbol.toStringTag]??n?.toString()??"unknown"}const aS=4,cS=41;function lS(n={}){return{denyDialPeer:async()=>!1,denyDialMultiaddr:async e=>{if(gr.matches(e))return!1;const t=e.stringTuples();return t[0][0]===aS||t[0][0]===cS?!!ti(`${t[0][1]}`):!1},denyInboundConnection:async()=>!1,denyOutboundConnection:async()=>!1,denyInboundEncryptedConnection:async()=>!1,denyOutboundEncryptedConnection:async()=>!1,denyInboundUpgradedConnection:async()=>!1,denyOutboundUpgradedConnection:async()=>!1,filterMultiaddrForPeer:async()=>!0,...n}}const il=()=>{const n=new Error("Delay aborted");return n.name="AbortError",n},uS=new WeakMap;function dS({clearTimeout:n,setTimeout:e}={}){return(t,{value:r,signal:s}={})=>{if(s?.aborted)return Promise.reject(il());let i,o,a;const c=n??clearTimeout,u=()=>{c(i),a(il())},l=()=>{s&&s.removeEventListener("abort",u)},d=new Promise((h,p)=>{o=()=>{l(),h(r)},a=p,i=(e??setTimeout)(o,t)});return s&&s.addEventListener("abort",u,{once:!0}),uS.set(d,()=>{c(i),i=null,o()}),d}}const hS=dS();class fS{memoryStorage;points;duration;blockDuration;execEvenly;execEvenlyMinDelayMs;keyPrefix;constructor(e={}){this.points=e.points??4,this.duration=e.duration??1,this.blockDuration=e.blockDuration??0,this.execEvenly=e.execEvenly??!1,this.execEvenlyMinDelayMs=e.execEvenlyMinDelayMs??this.duration*1e3/this.points,this.keyPrefix=e.keyPrefix??"rlflx",this.memoryStorage=new pS}async consume(e,t=1,r={}){const s=this.getKey(e),i=this._getKeySecDuration(r);let o=this.memoryStorage.incrby(s,t,i);if(o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o.consumedPoints>this.points)throw this.blockDuration>0&&o.consumedPoints<=this.points+t&&(o=this.memoryStorage.set(s,o.consumedPoints,this.blockDuration)),new Zb("Rate limit exceeded",o);if(this.execEvenly&&o.msBeforeNext>0&&!o.isFirstInDuration){let a=Math.ceil(o.msBeforeNext/(o.remainingPoints+2));a<this.execEvenlyMinDelayMs&&(a=o.consumedPoints*this.execEvenlyMinDelayMs),await hS(a)}return o}penalty(e,t=1,r={}){const s=this.getKey(e),i=this._getKeySecDuration(r),o=this.memoryStorage.incrby(s,t,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}reward(e,t=1,r={}){const s=this.getKey(e),i=this._getKeySecDuration(r),o=this.memoryStorage.incrby(s,-t,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}block(e,t){const r=t*1e3,s=this.points+1;return this.memoryStorage.set(this.getKey(e),s,t),{remainingPoints:0,msBeforeNext:r===0?-1:r,consumedPoints:s,isFirstInDuration:!1}}set(e,t,r=0){const s=(r>=0?r:this.duration)*1e3;return this.memoryStorage.set(this.getKey(e),t,r),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:t,isFirstInDuration:!1}}get(e){const t=this.memoryStorage.get(this.getKey(e));return t!=null&&(t.remainingPoints=Math.max(this.points-t.consumedPoints,0)),t}delete(e){this.memoryStorage.delete(this.getKey(e))}_getKeySecDuration(e){return e?.customDuration!=null&&e.customDuration>=0?e.customDuration:this.duration}getKey(e){return this.keyPrefix.length>0?`${this.keyPrefix}:${e}`:e}parseKey(e){return e.substring(this.keyPrefix.length)}}class pS{storage;constructor(){this.storage=new Map}incrby(e,t,r){const s=this.storage.get(e);if(s!=null){const i=s.expiresAt!=null?s.expiresAt.getTime()-new Date().getTime():-1;return s.expiresAt==null||i>0?(s.value+=t,{remainingPoints:0,msBeforeNext:i,consumedPoints:s.value,isFirstInDuration:!1}):this.set(e,t,r)}return this.set(e,t,r)}set(e,t,r){const s=r*1e3,i=this.storage.get(e);i!=null&&clearTimeout(i.timeoutId);const o={value:t,expiresAt:s>0?new Date(Date.now()+s):void 0};return this.storage.set(e,o),s>0&&(o.timeoutId=setTimeout(()=>{this.storage.delete(e)},s),o.timeoutId.unref!=null&&o.timeoutId.unref()),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:o.value,isFirstInDuration:!0}}get(e){const t=this.storage.get(e);if(t!=null)return{remainingPoints:0,msBeforeNext:t.expiresAt!=null?t.expiresAt.getTime()-new Date().getTime():-1,consumedPoints:t.value,isFirstInDuration:!1}}delete(e){const t=this.storage.get(e);return t!=null?(t.timeoutId!=null&&clearTimeout(t.timeoutId),this.storage.delete(e),!0):!1}}function ph(n){if(Zn(n))return{peerId:n,multiaddrs:[]};let e=Array.isArray(n)?n:[n],t;if(e.length>0){const r=e[0].getPeerId();t=r==null?void 0:yt(r),e.forEach(s=>{if(!Xs(s))throw new Ao("Invalid multiaddr");const i=s.getPeerId();if(i==null){if(t!=null)throw new K("Multiaddrs must all have the same peer id or have no peer id")}else{const o=yt(i);if(t?.equals(o)!==!0)throw new K("Multiaddrs must all have the same peer id or have no peer id")}})}return e=e.filter(r=>!Cb.exactMatch(r)),{peerId:t,multiaddrs:e}}const gS=["/ipfs/id/1.0.0","/ipfs/id/push/1.0.0","/libp2p/autonat/1.0.0","/libp2p/dcutr"];async function mS(n,e){const t=n?.streams?.map(s=>s.protocol)??[],r=e?.closableProtocols??gS;if(!(t.filter(s=>s!=null&&!r.includes(s)).length>0))try{await n?.close(e)}catch(s){n?.abort(s)}}function Eo(n){try{let e;typeof n=="string"?e=W(n):e=n;const t=new Set([...e.getComponents().map(r=>r.name)]);if(!t.has("ipcidr")){const s=t.has("ip6")?"/ipcidr/128":"/ipcidr/32";e=e.encapsulate(s)}return mb(e)}catch{throw new Error(`Can't convert to IpNet, Invalid multiaddr format: ${n}`)}}class yS{connectionManager;peerStore;allow;events;log;constructor(e,t={}){this.allow=(t.allow??[]).map(r=>Eo(r)),this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager:connection-pruner"),this.maybePruneConnections=this.maybePruneConnections.bind(this)}start(){this.events.addEventListener("connection:open",this.maybePruneConnections)}stop(){this.events.removeEventListener("connection:open",this.maybePruneConnections)}maybePruneConnections(){this._maybePruneConnections().catch(e=>{this.log.error("error while pruning connections %e",e)})}async _maybePruneConnections(){const e=this.connectionManager.getConnections(),t=e.length,r=this.connectionManager.getMaxConnections();if(this.log("checking max connections limit %d/%d",t,r),t<=r)return;const s=new Fn;for(const c of e){const u=c.remotePeer;if(!s.has(u)){s.set(u,0);try{const l=await this.peerStore.get(u);s.set(u,[...l.tags.values()].reduce((d,h)=>d+h.value,0))}catch(l){l.name!=="NotFoundError"&&this.log.error("error loading peer tags",l)}}}const i=this.sortConnections(e,s),o=Math.max(t-r,0),a=[];for(const c of i)if(this.log("too many connections open - closing a connection to %p",c.remotePeer),this.allow.some(l=>l.contains(c.remoteAddr.nodeAddress().address))||a.push(c),a.length===o)break;await Promise.all(a.map(async c=>{await mS(c,{signal:AbortSignal.timeout(1e3)})})),this.events.safeDispatchEvent("connection:prune",{detail:a})}sortConnections(e,t){return e.sort((r,s)=>{const i=r.timeline.open,o=s.timeline.open;return i<o?1:i>o?-1:0}).sort((r,s)=>r.direction==="outbound"&&s.direction==="inbound"?1:r.direction==="inbound"&&s.direction==="outbound"?-1:0).sort((r,s)=>r.streams.length>s.streams.length?1:r.streams.length<s.streams.length?-1:0).sort((r,s)=>{const i=t.get(r.remotePeer)??0,o=t.get(s.remotePeer)??0;return i>o?1:i<o?-1:0})}}const gh=1e4,wS=1e4,ol=1e4,mh=25,bS=5,ES=10,vS=5,SS="last-dial-failure",xS="last-dial-success",yh=500,AS=32,_S=100,wh=50;class CS extends Sd{constructor(e={}){super({...e,sort:(t,r)=>t.options.priority>r.options.priority?-1:t.options.priority<r.options.priority?1:0})}}function IS(n){return/^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(n)||/^::1$/.test(n)}function al(n){if(!Cd(n))return!1;const{address:e}=n.nodeAddress();return IS(e)}function TS(n,e){const t=Ls.exactMatch(n.multiaddr),r=Ls.exactMatch(e.multiaddr);if(t&&!r)return-1;if(!t&&r)return 1;const s=ks.exactMatch(n.multiaddr),i=ks.exactMatch(e.multiaddr);if(s&&!i)return-1;if(!s&&i)return 1;const o=gr.exactMatch(n.multiaddr),a=gr.exactMatch(e.multiaddr);if(o&&!a)return-1;if(!o&&a)return 1;const c=po.exactMatch(n.multiaddr),u=po.exactMatch(e.multiaddr);if(c&&!u)return-1;if(!c&&u)return 1;const l=hc.exactMatch(n.multiaddr),d=hc.exactMatch(e.multiaddr);if(l&&!d)return-1;if(!l&&d)return 1;const h=fc.exactMatch(n.multiaddr),p=fc.exactMatch(e.multiaddr);return h&&!p?-1:!h&&p?1:0}function PS(n,e){const t=al(n.multiaddr),r=al(e.multiaddr);return t&&!r?1:!t&&r?-1:0}function DS(n,e){const t=wr(n.multiaddr),r=wr(e.multiaddr);return t&&!r?1:!t&&r?-1:0}function LS(n,e){return n.isCertified&&!e.isCertified?-1:!n.isCertified&&e.isCertified?1:0}function kS(n,e){const t=mr.exactMatch(n.multiaddr),r=mr.exactMatch(e.multiaddr);return t&&!r?1:!t&&r?-1:0}function RS(n){return n.sort(TS).sort(LS).sort(kS).sort(DS).sort(PS)}async function bh(n,e,t){const r=t.depth??0;if(r>(t.maxRecursiveDepth??AS))throw new j1("Max recursive depth reached");let s=!1;const i=[];for(const o of Object.values(e))if(o.canResolve(n)){s=!0;const a=await o.resolve(n,t);for(const c of a)i.push(...await bh(c,e,{...t,depth:r+1}))}return s===!1&&i.push(n),i}const Hn={maxParallelDials:wh,maxDialQueueLength:yh,maxPeerAddrsToDial:mh,dialTimeout:gh,resolvers:{dnsaddr:ua}};class NS{queue;components;addressSorter;maxPeerAddrsToDial;maxDialQueueLength;dialTimeout;shutDownController;connections;log;resolvers;constructor(e,t={}){this.addressSorter=t.addressSorter,this.maxPeerAddrsToDial=t.maxPeerAddrsToDial??Hn.maxPeerAddrsToDial,this.maxDialQueueLength=t.maxDialQueueLength??Hn.maxDialQueueLength,this.dialTimeout=t.dialTimeout??Hn.dialTimeout,this.connections=t.connections??new Fn,this.log=e.logger.forComponent("libp2p:connection-manager:dial-queue"),this.components=e,this.resolvers=t.resolvers??Hn.resolvers,this.shutDownController=new AbortController,this.shutDownController.signal,this.queue=new CS({concurrency:t.maxParallelDials??Hn.maxParallelDials,metricName:"libp2p_dial_queue",metrics:e.metrics}),this.queue.addEventListener("error",r=>{r.detail?.name!==Bt.name&&this.log.error("error in dial queue - %e",r.detail)})}start(){this.shutDownController=new AbortController,this.shutDownController.signal}stop(){this.shutDownController.abort(),this.queue.abort()}async dial(e,t={}){const{peerId:r,multiaddrs:s}=ph(e),i=Array.from(this.connections.values()).flat().find(a=>t.force===!0||a.limits!=null?!1:a.remotePeer.equals(r)?!0:s.find(c=>c.equals(a.remoteAddr)));if(i?.status==="open")return this.log("already connected to %a",i.remoteAddr),t.onProgress?.(new ee("dial-queue:already-connected")),i;const o=this.queue.queue.find(a=>{if(r?.equals(a.options.peerId)===!0)return!0;const c=a.options.multiaddrs;if(c==null)return!1;for(const u of s)if(c.has(u.toString()))return!0;return!1});if(o!=null){this.log("joining existing dial target for %p",r);for(const a of s)o.options.multiaddrs.add(a.toString());return t.onProgress?.(new ee("dial-queue:already-in-dial-queue")),o.join(t)}if(this.queue.size>=this.maxDialQueueLength)throw new jn("Dial queue is full");return this.log("creating dial target for %p",r,s.map(a=>a.toString())),t.onProgress?.(new ee("dial-queue:add-to-dial-queue")),this.queue.add(async a=>{a.onProgress?.(new ee("dial-queue:start-dial"));const c=Dt([this.shutDownController.signal,a.signal]);try{return await this.dialPeer(a,c)}finally{c.clear()}},{peerId:r,priority:t.priority??Eh,multiaddrs:new Set(s.map(a=>a.toString())),signal:t.signal??AbortSignal.timeout(this.dialTimeout),onProgress:t.onProgress})}async dialPeer(e,t){const r=e.peerId,s=e.multiaddrs,i=new Set;let o=e.multiaddrs.size===0,a=0,c=0;const u=[];for(this.log("starting dial to %p",r);o||s.size>0;){c++,o=!1;const l=[],d=new Set(e.multiaddrs);s.clear(),this.log("calculating addrs to dial %p from %s",r,[...d]);const h=await this.calculateMultiaddrs(r,d,{...e,signal:t});for(const p of h){if(i.has(p.multiaddr.toString())){this.log.trace("skipping previously failed multiaddr %a while dialing %p",p.multiaddr,r);continue}l.push(p)}this.log("%s dial to %p with %s",c===1?"starting":"continuing",r,l.map(p=>p.multiaddr.toString())),e?.onProgress?.(new ee("dial-queue:calculated-addresses",l));for(const p of l){if(a===this.maxPeerAddrsToDial)throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others",a,e.peerId),new jn("Peer had more than maxPeerAddrsToDial");a++;try{const g=await this.components.transportManager.dial(p.multiaddr,{...e,signal:t});this.log("dial to %a succeeded",p.multiaddr);try{await this.components.peerStore.merge(g.remotePeer,{multiaddrs:[g.remoteAddr],metadata:{[xS]:$(Date.now().toString())}})}catch(m){this.log.error("could not update last dial failure key for %p",r,m)}return g}catch(g){if(this.log.error("dial failed to %a",p.multiaddr,g),i.add(p.multiaddr.toString()),r!=null)try{await this.components.peerStore.merge(r,{metadata:{[SS]:$(Date.now().toString())}})}catch(m){this.log.error("could not update last dial failure key for %p",r,m)}if(t.aborted)throw new Co(g.message);u.push(g)}}}throw u.length===1?u[0]:new AggregateError(u,"All multiaddr dials failed")}async calculateMultiaddrs(e,t=new Set,r={}){const s=[...t].map(d=>({multiaddr:W(d),isCertified:!1}));if(e!=null){if(this.components.peerId.equals(e))throw new jn("Tried to dial self");if(await this.components.connectionGater.denyDialPeer?.(e)===!0)throw new sl("The dial request is blocked by gater.allowDialPeer");if(s.length===0){this.log("loading multiaddrs for %p",e);try{const d=await this.components.peerStore.get(e);s.push(...d.addresses),this.log("loaded multiaddrs for %p",e,s.map(({multiaddr:h})=>h.toString()))}catch(d){if(d.name!=="NotFoundError")throw d}}if(s.length===0){this.log("looking up multiaddrs for %p in the peer routing",e);try{const d=await this.components.peerRouting.findPeer(e,r);this.log("found multiaddrs for %p in the peer routing",e,s.map(({multiaddr:h})=>h.toString())),s.push(...d.multiaddrs.map(h=>({multiaddr:h,isCertified:!1})))}catch(d){d.name==="NoPeerRoutersError"?this.log("no peer routers configured",e):this.log.error("looking up multiaddrs for %p in the peer routing failed - %e",e,d)}}}let i=(await Promise.all(s.map(async d=>{const h=await bh(d.multiaddr,this.resolvers,{dns:this.components.dns,log:this.log,...r});return h.length===1&&h[0].equals(d.multiaddr)?d:h.map(p=>({multiaddr:p,isCertified:!1}))}))).flat();if(e!=null){const d=`/p2p/${e.toString()}`;i=i.map(h=>h.multiaddr.getComponents().pop()?.name!=="p2p"?{multiaddr:h.multiaddr.encapsulate(d),isCertified:h.isCertified}:h)}const o=i.filter(d=>{if(this.components.transportManager.dialTransportForMultiaddr(d.multiaddr)==null)return!1;const h=d.multiaddr.getPeerId();return e!=null&&h!=null?e.equals(h):!0}),a=new Map;for(const d of o){const h=d.multiaddr.toString(),p=a.get(h);if(p!=null){p.isCertified=p.isCertified||d.isCertified||!1;continue}a.set(h,d)}const c=[...a.values()];if(c.length===0)throw new Q1("The dial request has no valid addresses");const u=[];for(const d of c)this.components.connectionGater.denyDialMultiaddr!=null&&await this.components.connectionGater.denyDialMultiaddr(d.multiaddr)||u.push(d);const l=this.addressSorter==null?RS(u):u.sort(this.addressSorter);if(l.length===0)throw new sl("The connection gater denied all addresses in the dial request");return this.log.trace("addresses for %p before filtering",e??"unknown peer",i.map(({multiaddr:d})=>d.toString())),this.log.trace("addresses for %p after filtering",e??"unknown peer",l.map(({multiaddr:d})=>d.toString())),l}async isDialable(e,t={}){Array.isArray(e)||(e=[e]);try{const r=await this.calculateMultiaddrs(void 0,new Set(e.map(s=>s.toString())),t);return t.runOnLimitedConnection===!1?r.find(s=>!mr.matches(s.multiaddr))!=null:!0}catch(r){this.log.trace("error calculating if multiaddr(s) were dialable",r)}return!1}}var Fi={},Ui,cl;function OS(){if(cl)return Ui;cl=1;function n(e,t){typeof t=="boolean"&&(t={forever:t}),this._originalTimeouts=JSON.parse(JSON.stringify(e)),this._timeouts=e,this._options=t||{},this._maxRetryTime=t&&t.maxRetryTime||1/0,this._fn=null,this._errors=[],this._attempts=1,this._operationTimeout=null,this._operationTimeoutCb=null,this._timeout=null,this._operationStart=null,this._timer=null,this._options.forever&&(this._cachedTimeouts=this._timeouts.slice(0))}return Ui=n,n.prototype.reset=function(){this._attempts=1,this._timeouts=this._originalTimeouts.slice(0)},n.prototype.stop=function(){this._timeout&&clearTimeout(this._timeout),this._timer&&clearTimeout(this._timer),this._timeouts=[],this._cachedTimeouts=null},n.prototype.retry=function(e){if(this._timeout&&clearTimeout(this._timeout),!e)return!1;var t=new Date().getTime();if(e&&t-this._operationStart>=this._maxRetryTime)return this._errors.push(e),this._errors.unshift(new Error("RetryOperation timeout occurred")),!1;this._errors.push(e);var r=this._timeouts.shift();if(r===void 0)if(this._cachedTimeouts)this._errors.splice(0,this._errors.length-1),r=this._cachedTimeouts.slice(-1);else return!1;var s=this;return this._timer=setTimeout(function(){s._attempts++,s._operationTimeoutCb&&(s._timeout=setTimeout(function(){s._operationTimeoutCb(s._attempts)},s._operationTimeout),s._options.unref&&s._timeout.unref()),s._fn(s._attempts)},r),this._options.unref&&this._timer.unref(),!0},n.prototype.attempt=function(e,t){this._fn=e,t&&(t.timeout&&(this._operationTimeout=t.timeout),t.cb&&(this._operationTimeoutCb=t.cb));var r=this;this._operationTimeoutCb&&(this._timeout=setTimeout(function(){r._operationTimeoutCb()},r._operationTimeout)),this._operationStart=new Date().getTime(),this._fn(this._attempts)},n.prototype.try=function(e){console.log("Using RetryOperation.try() is deprecated"),this.attempt(e)},n.prototype.start=function(e){console.log("Using RetryOperation.start() is deprecated"),this.attempt(e)},n.prototype.start=n.prototype.try,n.prototype.errors=function(){return this._errors},n.prototype.attempts=function(){return this._attempts},n.prototype.mainError=function(){if(this._errors.length===0)return null;for(var e={},t=null,r=0,s=0;s<this._errors.length;s++){var i=this._errors[s],o=i.message,a=(e[o]||0)+1;e[o]=a,a>=r&&(t=i,r=a)}return t},Ui}var ll;function MS(){return ll||(ll=1,function(n){var e=OS();n.operation=function(t){var r=n.timeouts(t);return new e(r,{forever:t&&(t.forever||t.retries===1/0),unref:t&&t.unref,maxRetryTime:t&&t.maxRetryTime})},n.timeouts=function(t){if(t instanceof Array)return[].concat(t);var r={retries:10,factor:2,minTimeout:1*1e3,maxTimeout:1/0,randomize:!1};for(var s in t)r[s]=t[s];if(r.minTimeout>r.maxTimeout)throw new Error("minTimeout is greater than maxTimeout");for(var i=[],o=0;o<r.retries;o++)i.push(this.createTimeout(o,r));return t&&t.forever&&!i.length&&i.push(this.createTimeout(o,r)),i.sort(function(a,c){return a-c}),i},n.createTimeout=function(t,r){var s=r.randomize?Math.random()+1:1,i=Math.round(s*Math.max(r.minTimeout,1)*Math.pow(r.factor,t));return i=Math.min(i,r.maxTimeout),i},n.wrap=function(t,r,s){if(r instanceof Array&&(s=r,r=null),!s){s=[];for(var i in t)typeof t[i]=="function"&&s.push(i)}for(var o=0;o<s.length;o++){var a=s[o],c=t[a];t[a]=function(l){var d=n.operation(r),h=Array.prototype.slice.call(arguments,1),p=h.pop();h.push(function(g){d.retry(g)||(g&&(arguments[0]=d.mainError()),p.apply(this,arguments))}),d.attempt(function(){l.apply(t,h)})}.bind(t,c),t[a].options=r}}}(Fi)),Fi}var Bi,ul;function FS(){return ul||(ul=1,Bi=MS()),Bi}var US=FS();const BS=ia(US),$S=Object.prototype.toString,qS=n=>$S.call(n)==="[object Error]",zS=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Load failed","Network request failed","fetch failed","terminated"]);function KS(n){return n&&qS(n)&&n.name==="TypeError"&&typeof n.message=="string"?n.message==="Load failed"?n.stack===void 0:zS.has(n.message):!1}class WS extends Error{constructor(e){super(),e instanceof Error?(this.originalError=e,{message:e}=e):(this.originalError=new Error(e),this.originalError.stack=this.stack),this.name="AbortError",this.message=e}}const dl=(n,e,t)=>{const r=t.retries-(e-1);return n.attemptNumber=e,n.retriesLeft=r,n};async function VS(n,e){return new Promise((t,r)=>{e={...e},e.onFailedAttempt??=()=>{},e.shouldRetry??=()=>!0,e.retries??=10;const s=BS.operation(e),i=()=>{s.stop(),r(e.signal?.reason)};e.signal&&!e.signal.aborted&&e.signal.addEventListener("abort",i,{once:!0});const o=()=>{e.signal?.removeEventListener("abort",i),s.stop()};s.attempt(async a=>{try{const c=await n(a);o(),t(c)}catch(c){try{if(!(c instanceof Error))throw new TypeError(`Non-error was thrown: "${c}". You should only throw errors.`);if(c instanceof WS)throw c.originalError;if(c instanceof TypeError&&!KS(c))throw c;if(dl(c,a,e),await e.shouldRetry(c)||(s.stop(),r(c)),await e.onFailedAttempt(c),!s.retry(c))throw s.mainError()}catch(u){dl(u,a,e),o(),r(u)}}})})}class HS{log;queue;started;peerStore;retries;retryInterval;backoffFactor;connectionManager;events;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:reconnect-queue"),this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.queue=new sa({concurrency:t.maxParallelReconnects??vS,metricName:"libp2p_reconnect_queue",metrics:e.metrics}),this.started=!1,this.retries=t.retries??5,this.backoffFactor=t.backoffFactor,this.retryInterval=t.retryInterval,this.events=e.events,e.events.addEventListener("peer:disconnect",r=>{this.maybeReconnect(r.detail).catch(s=>{this.log.error("failed to maybe reconnect to %p - %e",r.detail,s)})})}async maybeReconnect(e){if(!this.started)return;const t=await this.peerStore.get(e);hl(t)&&(this.queue.has(e)||this.queue.add(async r=>{await VS(async s=>{if(this.started)try{await this.connectionManager.openConnection(e,{signal:r?.signal})}catch(i){throw this.log("reconnecting to %p attempt %d of %d failed - %e",e,s,this.retries,i),i}},{signal:r?.signal,retries:this.retries,factor:this.backoffFactor,minTimeout:this.retryInterval})},{peerId:e}).catch(async r=>{this.log.error("failed to reconnect to %p - %e",e,r);const s={};[...t.tags.keys()].forEach(i=>{i.startsWith(So)&&(s[i]=void 0)}),await this.peerStore.merge(e,{tags:s}),this.events.safeDispatchEvent("peer:reconnect-failure",{detail:e})}).catch(async r=>{this.log.error("failed to remove keep-alive tag from %p - %e",e,r)}))}start(){this.started=!0}async afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[t=>hl(t)]});await Promise.all(e.map(async t=>{await this.connectionManager.openConnection(t.id).catch(r=>{this.log.error(r)})}))}).catch(e=>{this.log.error(e)})}stop(){this.started=!1,this.queue.abort()}}function hl(n){for(const e of n.tags.keys())if(e.startsWith(So))return!0;return!1}const Eh=50,$i={maxConnections:_S,inboundConnectionThreshold:bS,maxIncomingPendingConnections:ES};class GS{started;connections;allow;deny;maxIncomingPendingConnections;incomingPendingConnections;outboundPendingConnections;maxConnections;dialQueue;reconnectQueue;connectionPruner;inboundConnectionRateLimiter;peerStore;metrics;events;log;peerId;constructor(e,t={}){if(this.maxConnections=t.maxConnections??$i.maxConnections,this.maxConnections<1)throw new K("Connection Manager maxConnections must be greater than 0");this.connections=new Fn,this.started=!1,this.peerId=e.peerId,this.peerStore=e.peerStore,this.metrics=e.metrics,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.allow=(t.allow??[]).map(r=>Eo(r)),this.deny=(t.deny??[]).map(r=>Eo(r)),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=t.maxIncomingPendingConnections??$i.maxIncomingPendingConnections,this.outboundPendingConnections=0,this.inboundConnectionRateLimiter=new fS({points:t.inboundConnectionThreshold??$i.inboundConnectionThreshold,duration:1}),this.connectionPruner=new yS({connectionManager:this,peerStore:e.peerStore,events:e.events,logger:e.logger},{allow:t.allow?.map(r=>W(r))}),this.dialQueue=new NS(e,{addressSorter:t.addressSorter,maxParallelDials:t.maxParallelDials??wh,maxDialQueueLength:t.maxDialQueueLength??yh,maxPeerAddrsToDial:t.maxPeerAddrsToDial??mh,dialTimeout:t.dialTimeout??gh,resolvers:t.resolvers??{dnsaddr:ua},connections:this.connections}),this.reconnectQueue=new HS({events:e.events,peerStore:e.peerStore,logger:e.logger,connectionManager:this},{retries:t.reconnectRetries,retryInterval:t.reconnectRetryInterval,backoffFactor:t.reconnectBackoffFactor,maxParallelReconnects:t.maxParallelReconnects})}[Symbol.toStringTag]="@libp2p/connection-manager";async start(){this.metrics?.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const e={inbound:0,"inbound pending":this.incomingPendingConnections,outbound:0,"outbound pending":this.outboundPendingConnections};for(const t of this.connections.values())for(const r of t)e[r.direction]++;return e}}),this.metrics?.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const e={};for(const t of this.connections.values())for(const r of t)for(const s of r.streams){const i=`${s.direction} ${s.protocol??"unnegotiated"}`;e[i]=(e[i]??0)+1}return e}}),this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const e={};for(const r of this.connections.values())for(const s of r){const i={};for(const o of s.streams){const a=`${o.direction} ${o.protocol??"unnegotiated"}`;i[a]=(i[a]??0)+1}for(const[o,a]of Object.entries(i))e[o]=e[o]??[],e[o].push(a)}const t={};for(let[r,s]of Object.entries(e)){s=s.sort((o,a)=>o-a);const i=Math.floor(s.length*.9);t[r]=s[i]}return t}}),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),await vl(this.dialQueue,this.reconnectQueue,this.connectionPruner),this.started=!0,this.log("started")}async stop(){this.events.removeEventListener("connection:open",this.onConnect),this.events.removeEventListener("connection:close",this.onDisconnect),await Sl(this.reconnectQueue,this.dialQueue,this.connectionPruner);const e=[];for(const t of this.connections.values())for(const r of t)e.push((async()=>{try{await r.close()}catch(s){this.log.error(s)}})());this.log("closing %d connections",e.length),await Promise.all(e),this.connections.clear(),this.log("stopped")}getMaxConnections(){return this.maxConnections}setMaxConnections(e){if(this.maxConnections<1)throw new K("Connection Manager maxConnections must be greater than 0");let t=!1;e<this.maxConnections&&(t=!0),this.maxConnections=e,t&&this.connectionPruner.maybePruneConnections()}onConnect(e){this._onConnect(e).catch(t=>{this.log.error(t)})}async _onConnect(e){const{detail:t}=e;if(!this.started){await t.close();return}if(t.status!=="open")return;const r=t.remotePeer,s=!this.connections.has(r),i=this.connections.get(r)??[];i.push(t),this.connections.set(r,i),r.publicKey!=null&&r.type==="RSA"&&await this.peerStore.patch(r,{publicKey:r.publicKey}),s&&this.events.safeDispatchEvent("peer:connect",{detail:t.remotePeer})}onDisconnect(e){const{detail:t}=e,r=t.remotePeer,i=(this.connections.get(r)??[]).filter(o=>o.id!==t.id);this.connections.set(r,i),i.length===0&&(this.log("onDisconnect remove all connections for peer %p",r),this.connections.delete(r),this.events.safeDispatchEvent("peer:disconnect",{detail:t.remotePeer}))}getConnections(e){if(e!=null)return this.connections.get(e)??[];let t=[];for(const r of this.connections.values())t=t.concat(r);return t}getConnectionsMap(){return this.connections}async openConnection(e,t={}){if(!this.started)throw new is("Not started");this.outboundPendingConnections++;try{t.signal?.throwIfAborted();const{peerId:r}=ph(e);if(this.peerId.equals(r))throw new wl("Can not dial self");if(r!=null&&t.force!==!0){this.log("dial %p",r);const a=this.getConnections(r).find(c=>c.limits==null);if(a!=null)return this.log("had an existing non-limited connection to %p",r),t.onProgress?.(new ee("dial-queue:already-connected")),a}const s=await this.dialQueue.dial(e,{...t,priority:t.priority??Eh});if(s.status!=="open")throw new ml("Remote closed connection during opening");let i=this.connections.get(s.remotePeer);i==null&&(i=[],this.connections.set(s.remotePeer,i));let o=!1;for(const a of i)if(a.id===s.id&&(o=!0),t.force!==!0&&a.id!==s.id&&a.remoteAddr.equals(s.remoteAddr))return s.abort(new Ao("Duplicate multiaddr connection")),a;return o||i.push(s),s}finally{this.outboundPendingConnections--}}async closeConnections(e,t={}){const r=this.connections.get(e)??[];await Promise.all(r.map(async s=>{try{await s.close(t)}catch(i){s.abort(i)}}))}async acceptIncomingConnection(e){if(this.deny.some(s=>s.contains(e.remoteAddr.nodeAddress().address)))return this.log("connection from %a refused - connection remote address was in deny list",e.remoteAddr),!1;if(this.allow.some(s=>s.contains(e.remoteAddr.nodeAddress().address)))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",e.remoteAddr),!1;if(e.remoteAddr.isThinWaistAddress()){const s=e.remoteAddr.nodeAddress().address;try{await this.inboundConnectionRateLimiter.consume(s,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",e.remoteAddr,s),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",e.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){const e={queued:"queued",running:"active",errored:"error",complete:"success"};return this.dialQueue.queue.queue.map(t=>({id:t.id,status:e[t.status],peerId:t.options.peerId,multiaddrs:[...t.options.multiaddrs].map(r=>W(r))}))}async isDialable(e,t={}){return this.dialQueue.isDialable(e,t)}}class qi{movingAverage;variance;deviation;forecast;timeSpan;previousTime;constructor(e){this.timeSpan=e,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(e,t){return 1-Math.exp(-(e-t)/this.timeSpan)}push(e,t=Date.now()){if(this.previousTime!=null){const r=this.alpha(t,this.previousTime),s=e-this.movingAverage,i=r*s;this.movingAverage=r*e+(1-r)*this.movingAverage,this.variance=(1-r)*(this.variance+s*i),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+r*s}else this.movingAverage=e;this.previousTime=t}}const QS=1.2,YS=2,XS=5e3,ZS=6e4,jS=5e3;class JS{success;failure;next;metric;timeoutMultiplier;failureMultiplier;minTimeout;maxTimeout;constructor(e={}){const t=e.interval??jS;this.success=new qi(t),this.failure=new qi(t),this.next=new qi(t),this.failureMultiplier=e.failureMultiplier??YS,this.timeoutMultiplier=e.timeoutMultiplier??QS,this.minTimeout=e.minTimeout??XS,this.maxTimeout=e.maxTimeout??ZS,e.metricName!=null&&(this.metric=e.metrics?.registerMetricGroup(e.metricName))}getTimeoutSignal(e={}){let t=Math.round(this.next.movingAverage*(e.timeoutFactor??this.timeoutMultiplier));t<this.minTimeout&&(t=this.minTimeout),t>this.maxTimeout&&(t=this.maxTimeout);const r=AbortSignal.timeout(t),s=Dt([e.signal,r]);return s.start=Date.now(),s.timeout=t,s}cleanUp(e){const t=Date.now()-e.start;e.aborted?(this.failure.push(t),this.next.push(t*this.failureMultiplier),this.metric?.update({failureMovingAverage:this.failure.movingAverage,failureDeviation:this.failure.deviation,failureForecast:this.failure.forecast,failureVariance:this.failure.variance,failure:t})):(this.success.push(t),this.next.push(t),this.metric?.update({successMovingAverage:this.success.movingAverage,successDeviation:this.success.deviation,successForecast:this.success.forecast,successVariance:this.success.variance,success:t}))}}class ex{readNext;haveNext;ended;nextResult;error;constructor(){this.ended=!1,this.readNext=z(),this.haveNext=z()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=z(),e}async throw(e){return this.ended=!0,this.error=e,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=z(),await ie(this.readNext.promise,t?.signal,t)}}function tx(){return new ex}class nx extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"}function rx(n,e){const t=tx();n.sink(t).catch(async o=>{await t.end(o)}),n.sink=async o=>{for await(const a of o)await t.push(a);await t.end()};let r=n.source;n.source[Symbol.iterator]!=null?r=n.source[Symbol.iterator]():n.source[Symbol.asyncIterator]!=null&&(r=n.source[Symbol.asyncIterator]());const s=new H;return{read:async o=>{if(o?.signal?.throwIfAborted(),o?.bytes==null){const{done:c,value:u}=await ie(r.next(),o?.signal);return c===!0?null:u}for(;s.byteLength<o.bytes;){const{value:c,done:u}=await ie(r.next(),o?.signal);if(u===!0)throw new nx("unexpected end of input");s.append(c)}const a=s.sublist(0,o.bytes);return s.consume(o.bytes),a},write:async(o,a)=>{a?.signal?.throwIfAborted(),o instanceof Uint8Array?await t.push(o,a):await t.push(o.subarray(),a)},unwrap:()=>{if(s.byteLength>0){const o=n.source;n.source=async function*(){yield*s,yield*o}()}return n}}}const sx=1e4,ix="1.0.0",ox="ping",ax="ipfs",fl=32,cx=!0;class lx{protocol;components;log;heartbeatInterval;pingIntervalMs;abortController;timeout;abortConnectionOnPingFailure;constructor(e,t={}){this.components=e,this.protocol=`/${t.protocolPrefix??ax}/${ox}/${ix}`,this.log=e.logger.forComponent("libp2p:connection-monitor"),this.pingIntervalMs=t.pingInterval??sx,this.abortConnectionOnPingFailure=t.abortConnectionOnPingFailure??cx,this.timeout=new JS({...t.pingTimeout??{},metrics:e.metrics,metricName:"libp2p_connection_monitor_ping_time_milliseconds"})}[Symbol.toStringTag]="@libp2p/connection-monitor";[Ye]=["@libp2p/connection-monitor"];start(){this.abortController=new AbortController,this.abortController.signal,this.heartbeatInterval=setInterval(()=>{this.components.connectionManager.getConnections().forEach(e=>{Promise.resolve().then(async()=>{let t=Date.now();try{const r=this.timeout.getTimeoutSignal({signal:this.abortController?.signal}),s=await e.newStream(this.protocol,{signal:r,runOnLimitedConnection:!0}),i=rx(s);t=Date.now(),await Promise.all([i.write(Vo(fl),{signal:r}),i.read({bytes:fl,signal:r})]),e.rtt=Date.now()-t,await i.unwrap().close({signal:r})}catch(r){if(r.name!=="UnsupportedProtocolError")throw r;e.rtt=(Date.now()-t)/2}}).catch(t=>{this.log.error("error during heartbeat",t),this.abortConnectionOnPingFailure?(this.log.error("aborting connection due to ping failure"),e.abort(t)):this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag")})})},this.pingIntervalMs)}stop(){this.abortController?.abort(),this.heartbeatInterval!=null&&clearInterval(this.heartbeatInterval)}}class ux{routers;started;components;constructor(e,t){this.routers=t.routers??[],this.started=!1,this.components=e,this.findProviders=e.metrics?.traceFunction("libp2p.contentRouting.findProviders",this.findProviders.bind(this),{optionsIndex:1,getAttributesFromArgs:([r],s)=>({...s,cid:r.toString()}),getAttributesFromYieldedValue:(r,s)=>({...s,providers:[...Array.isArray(s.providers)?s.providers:[],r.id.toString()]})})??this.findProviders,this.provide=e.metrics?.traceFunction("libp2p.contentRouting.provide",this.provide.bind(this),{optionsIndex:1,getAttributesFromArgs:([r],s)=>({...s,cid:r.toString()})})??this.provide,this.cancelReprovide=e.metrics?.traceFunction("libp2p.contentRouting.cancelReprovide",this.cancelReprovide.bind(this),{optionsIndex:1,getAttributesFromArgs:([r],s)=>({...s,cid:r.toString()})})??this.cancelReprovide,this.put=e.metrics?.traceFunction("libp2p.contentRouting.put",this.put.bind(this),{optionsIndex:2,getAttributesFromArgs:([r])=>({key:q(r,"base36")})})??this.put,this.get=e.metrics?.traceFunction("libp2p.contentRouting.get",this.get.bind(this),{optionsIndex:1,getAttributesFromArgs:([r])=>({key:q(r,"base36")})})??this.get}[Symbol.toStringTag]="@libp2p/content-routing";isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(e,t={}){if(this.routers.length===0)throw new Mi("No content routers available");const r=this,s=new pn;for await(const i of Es(...r.routers.filter(o=>o.findProviders instanceof Function).map(o=>o.findProviders(e,t))))i!=null&&(i.multiaddrs.length>0&&await this.components.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},t),!s.has(i.id)&&(s.add(i.id),yield i))}async provide(e,t={}){if(this.routers.length===0)throw new Mi("No content routers available");await Promise.all(this.routers.filter(r=>r.provide instanceof Function).map(async r=>{await r.provide(e,t)}))}async cancelReprovide(e,t={}){if(this.routers.length===0)throw new Mi("No content routers available");await Promise.all(this.routers.filter(r=>r.cancelReprovide instanceof Function).map(async r=>{await r.cancelReprovide(e,t)}))}async put(e,t,r){if(!this.isStarted())throw new is;await Promise.all(this.routers.filter(s=>s.put instanceof Function).map(async s=>{await s.put(e,t,r)}))}async get(e,t){if(!this.isStarted())throw new is;return Promise.any(this.routers.filter(r=>r.get instanceof Function).map(async r=>r.get(e,t)))}}class dx{log;peerId;peerStore;routers;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-routing"),this.peerId=e.peerId,this.peerStore=e.peerStore,this.routers=t.routers??[],this.findPeer=e.metrics?.traceFunction("libp2p.peerRouting.findPeer",this.findPeer.bind(this),{optionsIndex:1,getAttributesFromArgs:([r],s)=>({...s,peer:r.toString()})})??this.findPeer,this.getClosestPeers=e.metrics?.traceFunction("libp2p.peerRouting.getClosestPeers",this.getClosestPeers.bind(this),{optionsIndex:1,getAttributesFromArgs:([r],s)=>({...s,key:q(r,"base36")}),getAttributesFromYieldedValue:(r,s)=>({...s,peers:[...Array.isArray(s.peers)?s.peers:[],r.id.toString()]})})??this.getClosestPeers}[Symbol.toStringTag]="@libp2p/peer-routing";async findPeer(e,t){if(this.routers.length===0)throw new rl("No peer routers available");if(e.toString()===this.peerId.toString())throw new K1("Should not try to find self");const r=this,s=Es(...this.routers.filter(i=>i.findPeer instanceof Function).map(i=>async function*(){try{yield await i.findPeer(e,t)}catch(o){r.log.error(o)}}()));for await(const i of s)if(i!=null)return i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},t),i;throw new Vi}async*getClosestPeers(e,t={}){if(this.routers.length===0)throw new rl("No peer routers available");const r=this,s=yr(1024);for await(const i of xd(async function*(){const o=Es(...r.routers.filter(a=>a.getClosestPeers instanceof Function).map(a=>a.getClosestPeers(e,t)));for await(let a of o)yield async()=>{if(a.multiaddrs.length===0)try{a=await r.findPeer(a.id,{...t,useCache:!1})}catch(c){r.log.error("could not find peer multiaddrs",c);return}return a}}()))i!=null&&(i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},t),!s.has(i.id.toMultihash().bytes)&&(s.add(i.id.toMultihash().bytes),yield i))}}class hx extends nt{peerRouting;log;walking;walkers;shutdownController;walkController;needNext;constructor(e){super(),this.log=e.logger.forComponent("libp2p:random-walk"),this.peerRouting=e.peerRouting,this.walkers=0,this.walking=!1,this.shutdownController=new AbortController,this.shutdownController.signal}[Symbol.toStringTag]="@libp2p/random-walk";start(){this.shutdownController=new AbortController,this.shutdownController.signal}stop(){this.shutdownController.abort()}async*walk(e){this.walking||this.startWalk(),this.walkers++;const t=Dt([this.shutdownController.signal,e?.signal]);try{for(;;)this.needNext?.resolve(),this.needNext=z(),yield(await gt(this,"walk:peer",t,{errorEvent:"walk:error"})).detail}finally{t.clear(),this.walkers--,this.walkers===0&&(this.walkController?.abort(),this.walkController=void 0)}}startWalk(){this.walking=!0,this.walkController=new AbortController,this.walkController.signal;const e=Dt([this.walkController.signal,this.shutdownController.signal]),t=Date.now();let r=0;Promise.resolve().then(async()=>{for(this.log("start walk");this.walkers>0;)try{const s=Vo(32);let i=Date.now();for await(const o of this.peerRouting.getClosestPeers(s,{signal:e}))e.aborted&&this.log("aborting walk"),e.throwIfAborted(),this.log("found peer %p after %dms for %d walkers",o.id,Date.now()-i,this.walkers),r++,this.safeDispatchEvent("walk:peer",{detail:o}),this.walkers===1&&this.needNext!=null&&(this.log("wait for need next"),await ie(this.needNext.promise,e)),i=Date.now();this.log("walk iteration for %b and %d walkers finished, found %d peers",s,this.walkers,r)}catch(s){this.log.error("random walk errored",s),this.safeDispatchEvent("walk:error",{detail:s})}this.log("no walkers left, ended walk")}).catch(s=>{this.log.error("random walk errored",s)}).finally(()=>{this.log("finished walk, found %d peers after %dms",r,Date.now()-t),this.walking=!1})}}const vh=32,Sh=64;class fx{log;topologies;handlers;components;constructor(e){this.components=e,this.log=e.logger.forComponent("libp2p:registrar"),this.topologies=new Map,e.metrics?.registerMetricGroup("libp2p_registrar_topologies",{calculate:()=>{const t={};for(const[r,s]of this.topologies)t[r]=s.size;return t}}),this.handlers=bt({name:"libp2p_registrar_protocol_handlers",metrics:e.metrics}),this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}[Symbol.toStringTag]="@libp2p/registrar";getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(e){const t=this.handlers.get(e);if(t==null)throw new W1(`No handler registered for protocol ${e}`);return t}getTopologies(e){const t=this.topologies.get(e);return t==null?[]:[...t.values()]}async handle(e,t,r){if(this.handlers.has(e)&&r?.force!==!0)throw new V1(`Handler already registered for protocol ${e}`);const s=Wd.bind({ignoreUndefined:!0})({maxInboundStreams:vh,maxOutboundStreams:Sh},r);this.handlers.set(e,{handler:t,options:s}),await this.components.peerStore.merge(this.components.peerId,{protocols:[e]},r)}async unhandle(e,t){(Array.isArray(e)?e:[e]).forEach(s=>{this.handlers.delete(s)}),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()},t)}async register(e,t){if(t==null)throw new K("invalid topology");const r=`${(Math.random()*1e9).toString(36)}${Date.now()}`;let s=this.topologies.get(e);return s==null&&(s=new Map,this.topologies.set(e,s)),s.set(r,t),r}unregister(e){for(const[t,r]of this.topologies.entries())r.has(e)&&(r.delete(e),r.size===0&&this.topologies.delete(t))}_onDisconnect(e){const t=e.detail,r={signal:AbortSignal.timeout(5e3)};this.components.peerStore.get(t,r).then(s=>{for(const i of s.protocols){const o=this.topologies.get(i);if(o!=null)for(const a of o.values())a.filter?.has(t)!==!1&&(a.filter?.remove(t),a.onDisconnect?.(t))}}).catch(s=>{s.name!=="NotFoundError"&&this.log.error("could not inform topologies of disconnecting peer %p",t,s)})}_onPeerUpdate(e){const{peer:t,previous:r}=e.detail,s=(r?.protocols??[]).filter(i=>!t.protocols.includes(i));for(const i of s){const o=this.topologies.get(i);if(o!=null)for(const a of o.values())a.filter?.has(t.id)!==!1&&(a.filter?.remove(t.id),a.onDisconnect?.(t.id))}}_onPeerIdentify(e){const t=e.detail.protocols,r=e.detail.connection,s=e.detail.peerId;for(const i of t){const o=this.topologies.get(i);if(o!=null)for(const a of o.values())r.limits!=null&&a.notifyOnLimitedConnection!==!0||a.filter?.has(s)!==!0&&(a.filter?.add(s),a.onConnect?.(s,r))}}}class px{log;components;transports;listeners;faultTolerance;started;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:transports"),this.components=e,this.started=!1,this.transports=bt({name:"libp2p_transport_manager_transports",metrics:this.components.metrics}),this.listeners=bt({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=t.faultTolerance??or.FATAL_ALL}[Symbol.toStringTag]="@libp2p/transport-manager";add(e){const t=e[Symbol.toStringTag];if(t==null)throw new K("Transport must have a valid tag");if(this.transports.has(t))throw new K(`There is already a transport with the tag ${t}`);this.log("adding transport %s",t),this.transports.set(t,e),this.listeners.has(t)||this.listeners.set(t,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const e=this.components.addressManager.getListenAddrs();await this.listen(e)}async stop(){const e=[];for(const[t,r]of this.listeners)for(this.log("closing listeners for %s",t);r.length>0;){const s=r.pop();s!=null&&e.push(s.close())}await Promise.all(e),this.log("all listeners closed");for(const t of this.listeners.keys())this.listeners.set(t,[]);this.started=!1}async dial(e,t){const r=this.dialTransportForMultiaddr(e);if(r==null)throw new Z1(`No transport available for address ${String(e)}`);return t?.onProgress?.(new ee("transport-manager:selected-transport",r[Symbol.toStringTag])),r.dial(e,{...t,upgrader:this.components.upgrader})}getAddrs(){let e=[];for(const t of this.listeners.values())for(const r of t)e=[...e,...r.getAddrs()];return e}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}dialTransportForMultiaddr(e){for(const t of this.transports.values())if(t.dialFilter([e]).length>0)return t}listenTransportForMultiaddr(e){for(const t of this.transports.values())if(t.listenFilter([e]).length>0)return t}async listen(e){if(!this.isStarted())throw new is("Not started");if(e==null||e.length===0){this.log("no addresses were provided for listening, this node is dial only");return}const t={errors:new Map,ipv4:{success:0,attempts:0},ipv6:{success:0,attempts:0}};e.forEach(i=>{t.errors.set(i.toString(),new H1)});const r=[];for(const[i,o]of this.transports.entries()){const a=o.listenFilter(e);for(const c of a){this.log("creating listener for %s on %a",i,c);const u=o.createListener({upgrader:this.components.upgrader});let l=this.listeners.get(i)??[];l==null&&(l=[],this.listeners.set(i,l)),l.push(u),u.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:u})}),u.addEventListener("close",()=>{const d=l.findIndex(h=>h===u);l.splice(d,1),this.components.events.safeDispatchEvent("transport:close",{detail:u})}),uc.matches(c)?t.ipv4.attempts++:dc.matches(c)&&t.ipv6.attempts++,r.push(u.listen(c).then(()=>{t.errors.delete(c.toString()),uc.matches(c)&&t.ipv4.success++,dc.matches(c)&&t.ipv6.success++},d=>{throw this.log.error("transport %s could not listen on address %a - %e",i,c,d),t.errors.set(c.toString(),d),d}))}}const s=await Promise.allSettled(r);if(!(s.length>0&&s.every(i=>i.status==="fulfilled"))){if(this.ipv6Unsupported(t)){this.log("all IPv4 addresses succeed but all IPv6 failed");return}if(this.faultTolerance===or.NO_FATAL){this.log("failed to listen on any address but fault tolerance allows this");return}throw new G1(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...t.errors.entries()].map(([i,o])=>`
  ${i}: ${`${o.stack??o}`.split(`
`).join(`
  `)}
`).join("")}`)}}ipv6Unsupported(e){if(e.ipv4.attempts===0||e.ipv6.attempts===0)return!1;const t=e.ipv4.attempts===e.ipv4.success,r=e.ipv6.success===0;return t&&r}async remove(e){const t=this.listeners.get(e)??[];this.log.trace("removing transport %s",e);const r=[];for(this.log.trace("closing listeners for %s",e);t.length>0;){const s=t.pop();s!=null&&r.push(s.close())}await Promise.all(r),this.transports.delete(e),this.listeners.delete(e)}async removeAll(){const e=[];for(const t of this.transports.keys())e.push(this.remove(t));await Promise.all(e)}}const Me="/multistream/1.0.0",da=1024,gx=$(`
`);async function Xn(n,e,t){await n.write(e,t)}async function mx(n,e,t){await n.writeV(e,t)}async function yx(n,e){const t=await n.read(e);if(t.byteLength===0||t.get(t.byteLength-1)!==gx[0])throw e.log.error("Invalid mss message - missing newline",t),new Je("Missing newline");return t.sublist(0,-1)}async function gn(n,e){const t=await yx(n,e);return q(t.subarray())}async function zi(n,e,t){if(e=Array.isArray(e)?[...e]:[e],e.length===1&&t.negotiateFully===!1)return wx(n,e[0],t);const r=bn(n,{...t,maxDataLength:da}),s=e.shift();if(s==null)throw new Error("At least one protocol must be specified");t.log.trace('select: write ["%s", "%s"]',Me,s);const i=$(`${Me}
`),o=$(`${s}
`);await mx(r,[i,o],t),t.log.trace("select: reading multistream-select header");let a=await gn(r,t);if(t.log.trace('select: read "%s"',a),a===Me&&(t.log.trace("select: reading protocol response"),a=await gn(r,t),t.log.trace('select: read "%s"',a)),a===s)return{stream:r.unwrap(),protocol:s};for(const c of e){t.log.trace('select: write "%s"',c),await Xn(r,$(`${c}
`),t),t.log.trace("select: reading protocol response");const u=await gn(r,t);if(t.log.trace('select: read "%s" for "%s"',u,c),u===c)return{stream:r.unwrap(),protocol:c}}throw new _o("protocol selection failed")}function wx(n,e,t){const r=n.sink.bind(n),s=n.source;let i=!1,o=!1;const a=z();let c=!1,u=!1;const l=z();let d=!1,h=!1;const p=z(),g=bn({sink:r,source:s},{...t,maxDataLength:da});n.sink=async v=>{const{sink:x}=g.unwrap();await x(async function*(){let L=!1;for await(const E of v){if(u&&await l.promise,c)yield E;else{u=!0,t.log.trace('optimistic: write ["%s", "%s", data(%d)] in sink',Me,e,E.byteLength);const T=`${e}
`;yield new H(Uint8Array.from([19]),$(`${Me}
`),un(T.length),$(T),E).subarray(),t.log.trace('optimistic: wrote ["%s", "%s", data(%d)] in sink',Me,e,E.byteLength),c=!0,u=!1,l.resolve(),m().catch(k=>{t.log.error("could not finish optimistic protocol negotiation of %s",e,k)})}L=!0}L||await m()}())};async function m(){if(o){t.log.trace("optimistic: already negotiating %s stream",e),await a.promise;return}o=!0;try{c||(t.log.trace("optimistic: doing send protocol for %s stream",e),await f()),d||(t.log.trace("optimistic: doing read protocol for %s stream",e),await w())}finally{o=!1,i=!0,a.resolve()}}async function f(){if(u){await l.promise;return}u=!0;try{t.log.trace('optimistic: write ["%s", "%s", data] in source',Me,e),await g.writeV([$(`${Me}
`),$(`${e}
`)]),t.log.trace('optimistic: wrote ["%s", "%s", data] in source',Me,e)}finally{c=!0,u=!1,l.resolve()}}async function w(){if(h){await p.promise;return}h=!0;try{t.log.trace("optimistic: reading multistream select header");let v=await gn(g,t);if(t.log.trace('optimistic: read multistream select header "%s"',v),v===Me&&(v=await gn(g,t)),t.log.trace('optimistic: read protocol "%s", expecting "%s"',v,e),v!==e)throw new _o("protocol selection failed")}finally{d=!0,h=!1,p.resolve()}}if(n.source=async function*(){await m(),t.log.trace('optimistic: reading data from "%s" stream',e),yield*g.unwrap().source}(),n.closeRead!=null){const v=n.closeRead.bind(n);n.closeRead=async x=>{i||await m().catch(L=>{t.log.error("could not negotiate protocol before close read",L)}),await v(x)}}if(n.closeWrite!=null){const v=n.closeWrite.bind(n);n.closeWrite=async x=>{i||await m().catch(L=>{t.log.error("could not negotiate protocol before close write",L)}),await v(x)}}if(n.close!=null){const v=n.close.bind(n);n.close=async x=>{const L=[];u&&L.push(l.promise),h&&L.push(p.promise),L.length>0?await ie(Promise.all(L),x?.signal):(i=!0,o=!1,a.resolve()),await v(x)}}return{stream:n,protocol:e}}async function Ki(n,e,t){e=Array.isArray(e)?e:[e],t.log.trace("handle: available protocols %s",e);const r=bn(n,{...t,maxDataLength:da,maxLengthLength:2});for(;;){t.log.trace("handle: reading incoming string");const s=await gn(r,t);if(t.log.trace('handle: read "%s"',s),s===Me){t.log.trace('handle: respond with "%s" for "%s"',Me,s),await Xn(r,$(`${Me}
`),t),t.log.trace('handle: responded with "%s" for "%s"',Me,s);continue}if(e.includes(s))return t.log.trace('handle: respond with "%s" for "%s"',s,s),await Xn(r,$(`${s}
`),t),t.log.trace('handle: responded with "%s" for "%s"',s,s),{stream:r.unwrap(),protocol:s};if(s==="ls"){const i=new H(...e.map(o=>ws.single($(`${o}
`))),$(`
`));t.log.trace('handle: respond with "%s" for %s',e,s),await Xn(r,i,t),t.log.trace('handle: responded with "%s" for %s',e,s);continue}t.log.trace('handle: respond with "na" for "%s"',s),await Xn(r,$(`na
`),t),t.log('handle: responded with "na" for "%s"',s)}}const bx=500;class Ex{id;remoteAddr;remotePeer;direction;timeline;multiplexer;encryption;status;limits;log;tags;_newStream;_close;_abort;_getStreams;constructor(e){const{remoteAddr:t,remotePeer:r,newStream:s,close:i,abort:o,getStreams:a}=e;this.id=`${parseInt(String(Math.random()*1e9)).toString(36)}${Date.now()}`,this.remoteAddr=t,this.remotePeer=r,this.direction=e.direction,this.status="open",this.timeline=e.timeline,this.multiplexer=e.multiplexer,this.encryption=e.encryption,this.limits=e.limits,this.log=e.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`),this.remoteAddr.getPeerId()==null&&(this.remoteAddr=this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)),this._newStream=s,this._close=i,this._abort=o,this._getStreams=a,this.tags=[]}[Symbol.toStringTag]="Connection";[Ph]=!0;get streams(){return this._getStreams()}async newStream(e,t){if(this.status==="closing")throw new kh("the connection is being closed");if(this.status==="closed")throw new ml("the connection is closed");if(Array.isArray(e)||(e=[e]),this.limits!=null&&t?.runOnLimitedConnection!==!0)throw new bl("Cannot open protocol stream on limited connection");const r=await this._newStream(e,t);return r.direction="outbound",r}async close(e={}){if(!(this.status==="closed"||this.status==="closing")){if(this.log("closing connection to %a",this.remoteAddr),this.status="closing",e.signal==null){const t=AbortSignal.timeout(bx);e={...e,signal:t}}try{this.log.trace("closing underlying transport"),await this._close(e),this.log.trace("updating timeline with close time"),this.status="closed",this.timeline.close=Date.now()}catch(t){this.log.error("error encountered during graceful close of connection to %a",this.remoteAddr,t),this.abort(t)}}}abort(e){this.status!=="closed"&&(this.log.error("aborting connection to %a due to error",this.remoteAddr,e),this.status="closing",this._abort(e),this.status="closed",this.timeline.close=Date.now())}}function vx(n){return new Ex(n)}function Sx(n,e){try{const{options:t}=e.getHandler(n);return t.maxInboundStreams}catch(t){if(t.name!=="UnhandledProtocolError")throw t}return vh}function xx(n,e,t={}){try{const{options:r}=e.getHandler(n);if(r.maxOutboundStreams!=null)return r.maxOutboundStreams}catch(r){if(r.name!=="UnhandledProtocolError")throw r}return t.maxOutboundStreams??Sh}function pl(n,e,t){let r=0;return t.streams.forEach(s=>{s.direction===e&&s.protocol===n&&r++}),r}class Ax{components;connectionEncrypters;streamMuxers;inboundUpgradeTimeout;inboundStreamProtocolNegotiationTimeout;outboundStreamProtocolNegotiationTimeout;events;metrics;constructor(e,t){this.components=e,this.connectionEncrypters=bt({name:"libp2p_upgrader_connection_encrypters",metrics:this.components.metrics}),t.connectionEncrypters.forEach(r=>{this.connectionEncrypters.set(r.protocol,r)}),this.streamMuxers=bt({name:"libp2p_upgrader_stream_multiplexers",metrics:this.components.metrics}),t.streamMuxers.forEach(r=>{this.streamMuxers.set(r.protocol,r)}),this.inboundUpgradeTimeout=t.inboundUpgradeTimeout??wS,this.inboundStreamProtocolNegotiationTimeout=t.inboundStreamProtocolNegotiationTimeout??ol,this.outboundStreamProtocolNegotiationTimeout=t.outboundStreamProtocolNegotiationTimeout??ol,this.events=e.events,this.metrics={dials:e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_total"),errors:e.metrics?.registerCounterGroup("libp2p_connection_manager_dial_errors_total"),inboundErrors:e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_inbound_errors_total"),outboundErrors:e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_outbound_errors_total")}}[Symbol.toStringTag]="@libp2p/upgrader";async shouldBlockConnection(e,...t){const r=this.components.connectionGater[e];if(r==null)return;if(await r.apply(this.components.connectionGater,t)===!0)throw new Y1(`The multiaddr connection is blocked by gater.${e}`)}createInboundAbortSignal(e){return Dt([AbortSignal.timeout(this.inboundUpgradeTimeout),e])}async upgradeInbound(e,t){let r=!1;const s=this.createInboundAbortSignal(t.signal);try{if(this.metrics.dials?.increment({inbound:!0}),r=await ie(this.components.connectionManager.acceptIncomingConnection(e),s),!r)throw new X1("Connection denied");await ie(this.shouldBlockConnection("denyInboundConnection",e),s),await this._performUpgrade(e,"inbound",{...t,signal:s})}catch(i){throw this.metrics.errors?.increment({inbound:!0}),this.metrics.inboundErrors?.increment({[i.name??"Error"]:!0}),i}finally{s.clear(),r&&this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(e,t){try{this.metrics.dials?.increment({outbound:!0});const r=e.remoteAddr.getPeerId();let s;r!=null&&(s=yt(r),await ie(this.shouldBlockConnection("denyOutboundConnection",s,e),t.signal));let i="outbound";return t.initiator===!1&&(i="inbound"),await this._performUpgrade(e,i,t)}catch(r){throw this.metrics.errors?.increment({outbound:!0}),this.metrics.outboundErrors?.increment({[r.name??"Error"]:!0}),r}}async _performUpgrade(e,t,r){let s,i,o,a,c;this.components.metrics?.trackMultiaddrConnection(e),e.log.trace("starting the %s connection upgrade",t);let u=e;if(r?.skipProtection!==!0){const l=this.components.connectionProtector;l!=null&&(e.log("protecting the %s connection",t),u=await l.protect(e,r))}try{if(s=u,r?.skipEncryption!==!0){r?.onProgress?.(new ee(`upgrader:encrypt-${t}-connection`)),{conn:s,remotePeer:i,protocol:c,streamMuxer:a}=await(t==="inbound"?this._encryptInbound(u,r):this._encryptOutbound(u,r));const l={...u,...s};await this.shouldBlockConnection(t==="inbound"?"denyInboundEncryptedConnection":"denyOutboundEncryptedConnection",i,l)}else{const l=e.remoteAddr.getPeerId();if(l==null)throw new Ao(`${t} connection that skipped encryption must have a peer id`);const d=yt(l);c="native",i=d}if(i.equals(this.components.peerId)){const l=new wl("Can not dial self");throw e.abort(l),l}if(o=s,r?.muxerFactory!=null)a=r.muxerFactory;else if(a==null&&this.streamMuxers.size>0){r?.onProgress?.(new ee(`upgrader:multiplex-${t}-connection`));const l=await(t==="inbound"?this._multiplexInbound({...u,...s},this.streamMuxers,r):this._multiplexOutbound({...u,...s},this.streamMuxers,r));a=l.muxerFactory,o=l.stream}}catch(l){throw e.log.error("failed to upgrade inbound connection %s %a - %e",t==="inbound"?"from":"to",e.remoteAddr,l),l}return await this.shouldBlockConnection(t==="inbound"?"denyInboundUpgradedConnection":"denyOutboundUpgradedConnection",i,e),e.log("successfully upgraded %s connection",t),this._createConnection({cryptoProtocol:c,direction:t,maConn:e,upgradedConn:o,muxerFactory:a,remotePeer:i,limits:r?.limits})}_createConnection(e){const{cryptoProtocol:t,direction:r,maConn:s,upgradedConn:i,remotePeer:o,muxerFactory:a,limits:c}=e;let u,l,d;a!=null&&(u=a.createStreamMuxer({direction:r,onIncomingStream:g=>{if(d==null)return;const m=AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout);Promise.resolve().then(async()=>{const f=this.components.registrar.getProtocols(),{stream:w,protocol:v}=await Ki(g,f,{signal:m,log:g.log,yieldBytes:!1});if(d==null)return;d.log("incoming stream opened on %s",v);const x=Sx(v,this.components.registrar);if(pl(v,"inbound",d)===x){const E=new Fh(`Too many inbound protocol streams for protocol "${v}" - limit ${x}`);throw g.abort(E),E}g.source=w.source,g.sink=w.sink,g.protocol=v,w.closeWrite!=null&&(g.closeWrite=w.closeWrite),w.closeRead!=null&&(g.closeRead=w.closeRead),w.close!=null&&(g.close=w.close),await this.components.peerStore.merge(o,{protocols:[v]},{signal:m}),this.components.metrics?.trackProtocolStream(g,d),this._onStream({connection:d,stream:g,protocol:v})}).catch(async f=>{d.log.error("error handling incoming stream id %s - %e",g.id,f),g.timeline.close==null&&await g.close({signal:m}).catch(w=>g.abort(w))})}}),l=async(g,m={})=>{if(u==null)throw new Jr("Connection is not multiplexed");d.log.trace("starting new stream for protocols %s",g);const f=await u.newStream();d.log.trace("started new stream %s for protocols %s",f.id,g);try{if(m.signal==null){f.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout",g);const E=AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);m={...m,signal:E}}f.log.trace("selecting protocol from protocols %s",g);const{stream:w,protocol:v}=await zi(f,g,{...m,log:f.log,yieldBytes:!0});f.log.trace("selected protocol %s",v);const x=xx(v,this.components.registrar,m),L=pl(v,"outbound",d);if(L>=x){const E=new El(`Too many outbound protocol streams for protocol "${v}" - ${L}/${x}`);throw f.abort(E),E}return await this.components.peerStore.merge(o,{protocols:[v]}),f.source=w.source,f.sink=w.sink,f.protocol=v,w.closeWrite!=null&&(f.closeWrite=w.closeWrite),w.closeRead!=null&&(f.closeRead=w.closeRead),w.close!=null&&(f.close=w.close),this.components.metrics?.trackProtocolStream(f,d),f}catch(w){throw d.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e",r==="inbound"?"from":"to",e.maConn.remoteAddr,g,w),f.timeline.close==null&&f.abort(w),w}},Promise.all([u.sink(i.source),i.sink(u.source)]).catch(g=>{d.log.error("error piping data through muxer - %e",g)}));const h=s.timeline;s.timeline=new Proxy(h,{set:(...g)=>(g[1]==="close"&&g[2]!=null&&h.close==null&&(async()=>{try{d.status==="open"&&await d.close()}catch(m){d.log.error("error closing connection after timeline close %e",m)}finally{this.events.safeDispatchEvent("connection:close",{detail:d})}})().catch(m=>{d.log.error("error thrown while dispatching connection:close event %e",m)}),Reflect.set(...g))}),s.timeline.upgraded=Date.now();const p=()=>{throw new Jr("Connection is not multiplexed")};return d=vx({remoteAddr:s.remoteAddr,remotePeer:o,status:"open",direction:r,timeline:s.timeline,multiplexer:u?.protocol,encryption:t,limits:c,logger:this.components.logger,newStream:l??p,getStreams:()=>u?.streams??[],close:async g=>{await u?.close(g),await s.close(g)},abort:g=>{s.abort(g),u?.abort(g)}}),this.events.safeDispatchEvent("connection:open",{detail:d}),d.__maConnTimeline=h,d}_onStream(e){const{connection:t,stream:r,protocol:s}=e,{handler:i,options:o}=this.components.registrar.getHandler(s);if(t.limits!=null&&o.runOnLimitedConnection!==!0)throw new bl("Cannot open protocol stream on limited connection");i({connection:t,stream:r})}async _encryptInbound(e,t){const r=Array.from(this.connectionEncrypters.keys());try{const{stream:s,protocol:i}=await Ki(e,r,{...t,log:e.log}),o=this.connectionEncrypters.get(i);if(o==null)throw new es(`no crypto module found for ${i}`);return e.log("encrypting inbound connection to %a using %s",e.remoteAddr,i),{...await o.secureInbound(s,t),protocol:i}}catch(s){throw e.log.error("encrypting inbound connection from %a failed",e.remoteAddr,s),new es(s.message)}}async _encryptOutbound(e,t){const r=Array.from(this.connectionEncrypters.keys());try{e.log.trace("selecting encrypter from %s",r);const{stream:s,protocol:i}=await zi(e,r,{...t,log:e.log,yieldBytes:!0}),o=this.connectionEncrypters.get(i);if(o==null)throw new es(`no crypto module found for ${i}`);return e.log("encrypting outbound connection to %a using %s",e.remoteAddr,i),{...await o.secureOutbound(s,t),protocol:i}}catch(s){throw e.log.error("encrypting outbound connection to %a failed",e.remoteAddr,s),new es(s.message)}}async _multiplexOutbound(e,t,r){const s=Array.from(t.keys());e.log("outbound selecting muxer %s",s);try{e.log.trace("selecting stream muxer from %s",s);const{stream:i,protocol:o}=await zi(e,s,{...r,log:e.log,yieldBytes:!0});e.log("selected %s as muxer protocol",o);const a=t.get(o);return{stream:i,muxerFactory:a}}catch(i){throw e.log.error("error multiplexing outbound connection",i),new Jr(String(i))}}async _multiplexInbound(e,t,r){const s=Array.from(t.keys());e.log("inbound handling muxers %s",s);try{const{stream:i,protocol:o}=await Ki(e,s,{...r,log:e.log}),a=t.get(o);return{stream:i,muxerFactory:a}}catch(i){throw e.log.error("error multiplexing inbound connection",i),new Jr(String(i))}}getConnectionEncrypters(){return this.connectionEncrypters}getStreamMuxers(){return this.streamMuxers}}const xh="2.9.0",Ah="js-libp2p";function _x(n,e){return`${n??Ah}/${e??xh} browser/${globalThis.navigator.userAgent}`}class Cx extends nt{peerId;peerStore;contentRouting;peerRouting;metrics;services;logger;status;components;log;constructor(e){super(),this.status="stopped";const t=new nt,r=t.dispatchEvent.bind(t);t.dispatchEvent=u=>{const l=r(u),d=this.dispatchEvent(new CustomEvent(u.type,{detail:u.detail}));return l||d},this.peerId=e.peerId,this.logger=e.logger??Yd(),this.log=this.logger.forComponent("libp2p"),this.services={};const s=e.nodeInfo?.name??Ah,i=e.nodeInfo?.version??xh,o=this.components=nS({peerId:e.peerId,privateKey:e.privateKey,nodeInfo:{name:s,version:i,userAgent:e.nodeInfo?.userAgent??_x(s,i)},logger:this.logger,events:t,datastore:e.datastore??new x1,connectionGater:lS(e.connectionGater),dns:e.dns});e.metrics!=null&&(this.metrics=this.configureComponent("metrics",e.metrics(this.components))),this.peerStore=this.configureComponent("peerStore",w1(o,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...e.peerStore})),o.events.addEventListener("peer:update",u=>{if(u.detail.previous==null){const l={id:u.detail.peer.id,multiaddrs:u.detail.peer.addresses.map(d=>d.multiaddr)};o.events.safeDispatchEvent("peer:discovery",{detail:l})}}),e.connectionProtector!=null&&this.configureComponent("connectionProtector",e.connectionProtector(o)),this.components.upgrader=new Ax(this.components,{connectionEncrypters:(e.connectionEncrypters??[]).map((u,l)=>this.configureComponent(`connection-encryption-${l}`,u(this.components))),streamMuxers:(e.streamMuxers??[]).map((u,l)=>this.configureComponent(`stream-muxers-${l}`,u(this.components))),inboundUpgradeTimeout:e.connectionManager?.inboundUpgradeTimeout,inboundStreamProtocolNegotiationTimeout:e.connectionManager?.inboundStreamProtocolNegotiationTimeout??e.connectionManager?.protocolNegotiationTimeout,outboundStreamProtocolNegotiationTimeout:e.connectionManager?.outboundStreamProtocolNegotiationTimeout??e.connectionManager?.protocolNegotiationTimeout}),this.configureComponent("transportManager",new px(this.components,e.transportManager)),this.configureComponent("connectionManager",new GS(this.components,e.connectionManager)),e.connectionMonitor?.enabled!==!1&&this.configureComponent("connectionMonitor",new lx(this.components,e.connectionMonitor)),this.configureComponent("registrar",new fx(this.components)),this.configureComponent("addressManager",new $1(this.components,e.addresses));const a=(e.peerRouters??[]).map((u,l)=>this.configureComponent(`peer-router-${l}`,u(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new dx(this.components,{routers:a}));const c=(e.contentRouters??[]).map((u,l)=>this.configureComponent(`content-router-${l}`,u(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new ux(this.components,{routers:c})),this.configureComponent("randomWalk",new hx(this.components)),(e.peerDiscovery??[]).forEach((u,l)=>{this.configureComponent(`peer-discovery-${l}`,u(this.components)).addEventListener("peer",h=>{this.#e(h)})}),e.transports?.forEach((u,l)=>{this.components.transportManager.add(this.configureComponent(`transport-${l}`,u(this.components)))}),e.services!=null)for(const u of Object.keys(e.services)){const l=e.services[u],d=l(this.components);if(d==null){this.log.error("service factory %s returned null or undefined instance",u);continue}this.services[u]=d,this.configureComponent(u,d),d[ha]!=null&&(this.log("registering service %s for content routing",u),c.push(d[ha])),d[pa]!=null&&(this.log("registering service %s for peer routing",u),a.push(d[pa])),d[fa]!=null&&(this.log("registering service %s for peer discovery",u),d[fa].addEventListener?.("peer",h=>{this.#e(h)}))}rS(o)}configureComponent(e,t){return t==null&&this.log.error("component %s was null or undefined",e),this.components[e]=t,t}async start(){if(this.status==="stopped"){this.status="starting",this.log("libp2p is starting");try{await this.components.beforeStart?.(),await this.components.start(),await this.components.afterStart?.(),this.status="started",this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started")}catch(e){throw this.log.error("An error occurred starting libp2p",e),this.status="started",await this.stop(),e}}}async stop(){this.status==="started"&&(this.log("libp2p is stopping"),this.status="stopping",await this.components.beforeStop?.(),await this.components.stop(),await this.components.afterStop?.(),this.status="stopped",this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}getConnections(e){return this.components.connectionManager.getConnections(e)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const e=new pn;for(const t of this.components.connectionManager.getConnections())e.add(t.remotePeer);return Array.from(e)}async dial(e,t={}){return this.components.connectionManager.openConnection(e,{priority:75,...t})}async dialProtocol(e,t,r={}){if(t==null)throw new K("no protocols were provided to open a stream");if(t=Array.isArray(t)?t:[t],t.length===0)throw new K("no protocols were provided to open a stream");return(await this.dial(e,r)).newStream(t,r)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(e,t={}){Xs(e)&&(e=yt(e.getPeerId()??"")),await this.components.connectionManager.closeConnections(e,t)}async getPublicKey(e,t={}){if(this.log("getPublicKey %p",e),e.publicKey!=null)return e.publicKey;try{const o=await this.peerStore.get(e,t);if(o.id.publicKey!=null)return o.id.publicKey}catch(o){if(o.name!=="NotFoundError")throw o}const r=$t([$("/pk/"),e.toMultihash().bytes]),s=await this.contentRouting.get(r,t),i=Pt(s);return await this.peerStore.patch(e,{publicKey:i},t),i}async handle(e,t,r){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async s=>{await this.components.registrar.handle(s,t,r)}))}async unhandle(e,t){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async r=>{await this.components.registrar.unhandle(r,t)}))}async register(e,t,r){return this.components.registrar.register(e,t,r)}unregister(e){this.components.registrar.unregister(e)}async isDialable(e,t={}){return this.components.connectionManager.isDialable(e,t)}#e(e){const{detail:t}=e;if(t.id.toString()===this.peerId.toString()){this.log.error("peer discovery mechanism discovered self");return}this.components.peerStore.merge(t.id,{multiaddrs:t.multiaddrs}).catch(r=>{this.log.error(r)})}}async function Ix(n={}){n.privateKey??=await Pm();const e=new Cx({...await _v(n),peerId:Nm(n.privateKey)});return n.start!==!1&&await e.start(),e}const _h=Lr("webrtc").code,Tx=document.getElementById("output"),Px=document.getElementById("send-section"),Ue=n=>{const e=document.createElement("div");e.appendChild(document.createTextNode(n)),Tx.append(e)},Ch="/libp2p/examples/chat/1.0.0";let He,cn;const it=await Ix({addresses:{listen:["/p2p-circuit","/webrtc"]},transports:[XE({filter:$d}),kE(),f0()],connectionEncrypters:[Gy()],streamMuxers:[gw()],connectionGater:{denyDialMultiaddr:()=>!1},services:{identify:F0(),identifyPush:U0(),ping:Y0()}});await it.start();function Ih(){const n=it.getConnections().map(e=>{e.remoteAddr.protoCodes().includes(_h)&&(He=e.remoteAddr,Px.style.display="block");const t=document.createElement("li");return t.textContent=e.remoteAddr.toString(),t});document.getElementById("connections").replaceChildren(...n)}it.addEventListener("connection:open",n=>{Ih()});it.addEventListener("connection:close",n=>{Ih()});it.addEventListener("self:peer:update",n=>{const e=it.getMultiaddrs().filter(t=>Th(t)).map(t=>{const r=document.createElement("li");return r.textContent=t.toString(),r});document.getElementById("multiaddrs").replaceChildren(...e)});it.handle(Ch,async({stream:n})=>{for(cn=qd(n);;){const e=await cn.read();Ue(`Received message '${q(e.subarray())}'`)}});const Th=n=>n.protoCodes().includes(_h);window.connect.onclick=async()=>{He=W(window.peer.value),Ue(`Dialing '${He}'`);const n=AbortSignal.timeout(5e3);try{if(Th(He)){const e=await it.services.ping.ping(He,{signal:n});Ue(`Connected to '${He}'`),Ue(`RTT to ${He.getPeerId()} was ${e}ms`)}else await it.dial(He,{signal:n}),Ue("Connected to relay")}catch(e){n.aborted?Ue(`Timed out connecting to '${He}'`):Ue(`Connecting to '${He}' failed - ${e.message}`)}};window.send.onclick=async()=>{if(cn==null){Ue("Opening chat stream");const e=AbortSignal.timeout(5e3);try{const t=await it.dialProtocol(He,Ch,{signal:e});cn=qd(t),Promise.resolve().then(async()=>{for(;;){const r=await cn.read();Ue(`Received message '${q(r.subarray())}'`)}})}catch(t){e.aborted?Ue("Timed out opening chat stream"):Ue(`Opening chat stream failed - ${t.message}`);return}}const n=window.message.value.toString().trim();Ue(`Sending message '${n}'`),cn.write($(n)).catch(e=>{Ue(`Error sending message - ${e.message}`)})};
