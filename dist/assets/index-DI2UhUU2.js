(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function t(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function r(s){if(s.ep)return;s.ep=!0;const i=t(s);fetch(s.href,i)}})();const Ch=Symbol.for("@libp2p/connection"),ha=Symbol.for("@libp2p/content-routing"),fa=Symbol.for("@libp2p/peer-discovery"),vo=Symbol.for("@libp2p/peer-id");function Qn(n){return!!n?.[vo]}const pa=Symbol.for("@libp2p/peer-routing"),So="keep-alive",xo=Symbol.for("@libp2p/transport");var rr;(function(n){n[n.FATAL_ALL=0]="FATAL_ALL",n[n.NO_FATAL=1]="NO_FATAL"})(rr||(rr={}));let Ft=class extends Error{static name="AbortError";constructor(e="The operation was aborted"){super(e),this.name="AbortError"}};class Ih extends Error{static name="UnexpectedPeerError";constructor(e="Unexpected Peer"){super(e),this.name="UnexpectedPeerError"}}let Th=class extends Error{static name="InvalidCryptoExchangeError";constructor(e="Invalid crypto exchange"){super(e),this.name="InvalidCryptoExchangeError"}},z=class extends Error{static name="InvalidParametersError";constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}};class ml extends Error{static name="InvalidPublicKeyError";constructor(e="Invalid public key"){super(e),this.name="InvalidPublicKeyError"}}class Ph extends Error{static name="ConnectionClosingError";constructor(e="The connection is closing"){super(e),this.name="ConnectionClosingError"}}class yl extends Error{static name="ConnectionClosedError";constructor(e="The connection is closed"){super(e),this.name="ConnectionClosedError"}}class wl extends Error{static name="ConnectionFailedError";constructor(e="Connection failed"){super(e),this.name="ConnectionFailedError"}}class On extends Error{static name="MuxerClosedError";constructor(e="The muxer is closed"){super(e),this.name="MuxerClosedError"}}class Dh extends Error{static name="StreamResetError";constructor(e="The stream has been reset"){super(e),this.name="StreamResetError"}}class Ki extends Error{static name="StreamStateError";constructor(e="The stream is in an invalid state"){super(e),this.name="StreamStateError"}}let Wi=class extends Error{static name="NotFoundError";constructor(e="Not found"){super(e),this.name="NotFoundError"}};class bl extends Error{static name="InvalidPeerIdError";constructor(e="Invalid PeerID"){super(e),this.name="InvalidPeerIdError"}}let Ao=class extends Error{static name="InvalidMultiaddrError";constructor(e="Invalid multiaddr"){super(e),this.name="InvalidMultiaddrError"}};class Lh extends Error{static name="InvalidCIDError";constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}}class kh extends Error{static name="InvalidMultihashError";constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}}class _o extends Error{static name="UnsupportedProtocolError";constructor(e="Unsupported protocol error"){super(e),this.name="UnsupportedProtocolError"}}class je extends Error{static name="InvalidMessageError";constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}}class Rh extends Error{static name="ProtocolError";constructor(e="Protocol error"){super(e),this.name="ProtocolError"}}let Co=class extends Error{static name="TimeoutError";constructor(e="Timed out"){super(e),this.name="TimeoutError"}};class ts extends Error{static name="NotStartedError";constructor(e="Not started"){super(e),this.name="NotStartedError"}}class Yn extends Error{static name="DialError";constructor(e="Dial error"){super(e),this.name="DialError"}}class Vi extends Error{static name="ListenError";constructor(e="Listen error"){super(e),this.name="ListenError"}}class El extends Error{static name="LimitedConnectionError";constructor(e="Limited connection"){super(e),this.name="LimitedConnectionError"}}class Mh extends Error{static name="TooManyInboundProtocolStreamsError";constructor(e="Too many inbound protocol streams"){super(e),this.name="TooManyInboundProtocolStreamsError"}}class vl extends Error{static name="TooManyOutboundProtocolStreamsError";constructor(e="Too many outbound protocol streams"){super(e),this.name="TooManyOutboundProtocolStreamsError"}}class Io extends Error{static name="UnsupportedKeyTypeError";constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}}class tt extends EventTarget{#e=new Map;constructor(){super()}listenerCount(e){const t=this.#e.get(e);return t==null?0:t.length}addEventListener(e,t,r){super.addEventListener(e,t,r);let s=this.#e.get(e);s==null&&(s=[],this.#e.set(e,s)),s.push({callback:t,once:(r!==!0&&r!==!1&&r?.once)??!1})}removeEventListener(e,t,r){super.removeEventListener(e.toString(),t??null,r);let s=this.#e.get(e);s!=null&&(s=s.filter(({callback:i})=>i!==t),this.#e.set(e,s))}dispatchEvent(e){const t=super.dispatchEvent(e);let r=this.#e.get(e.type);return r==null||(r=r.filter(({once:s})=>!s),this.#e.set(e.type,r)),t}safeDispatchEvent(e,t={}){return this.dispatchEvent(new CustomEvent(e,t))}}function To(n){return n!=null&&typeof n.start=="function"&&typeof n.stop=="function"}async function Sl(...n){const e=[];for(const t of n)To(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStart!=null&&await t.beforeStart()})),await Promise.all(e.map(async t=>{await t.start()})),await Promise.all(e.map(async t=>{t.afterStart!=null&&await t.afterStart()}))}async function xl(...n){const e=[];for(const t of n)To(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStop!=null&&await t.beforeStop()})),await Promise.all(e.map(async t=>{await t.stop()})),await Promise.all(e.map(async t=>{t.afterStop!=null&&await t.afterStop()}))}const Qe=Symbol.for("@libp2p/service-capabilities"),ns=Symbol.for("@libp2p/service-dependencies");function Nh(n,e){if(n===e)return!0;if(n.byteLength!==e.byteLength)return!1;for(let t=0;t<n.byteLength;t++)if(n[t]!==e[t])return!1;return!0}function Us(n){if(n instanceof Uint8Array&&n.constructor.name==="Uint8Array")return n;if(n instanceof ArrayBuffer)return new Uint8Array(n);if(ArrayBuffer.isView(n))return new Uint8Array(n.buffer,n.byteOffset,n.byteLength);throw new Error("Unknown type, must be binary type")}function Oh(n){return new TextEncoder().encode(n)}function Fh(n){return new TextDecoder().decode(n)}function Uh(n,e){if(n.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),r=0;r<t.length;r++)t[r]=255;for(var s=0;s<n.length;s++){var i=n.charAt(s),o=i.charCodeAt(0);if(t[o]!==255)throw new TypeError(i+" is ambiguous");t[o]=s}var a=n.length,c=n.charAt(0),u=Math.log(a)/Math.log(256),l=Math.log(256)/Math.log(a);function d(g){if(g instanceof Uint8Array||(ArrayBuffer.isView(g)?g=new Uint8Array(g.buffer,g.byteOffset,g.byteLength):Array.isArray(g)&&(g=Uint8Array.from(g))),!(g instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(g.length===0)return"";for(var m=0,f=0,w=0,v=g.length;w!==v&&g[w]===0;)w++,m++;for(var x=(v-w)*l+1>>>0,L=new Uint8Array(x);w!==v;){for(var E=g[w],T=0,k=x-1;(E!==0||T<f)&&k!==-1;k--,T++)E+=256*L[k]>>>0,L[k]=E%a>>>0,E=E/a>>>0;if(E!==0)throw new Error("Non-zero carry");f=T,w++}for(var D=x-f;D!==x&&L[D]===0;)D++;for(var y=c.repeat(m);D<x;++D)y+=n.charAt(L[D]);return y}function h(g){if(typeof g!="string")throw new TypeError("Expected String");if(g.length===0)return new Uint8Array;var m=0;if(g[m]!==" "){for(var f=0,w=0;g[m]===c;)f++,m++;for(var v=(g.length-m)*u+1>>>0,x=new Uint8Array(v);g[m];){var L=t[g.charCodeAt(m)];if(L===255)return;for(var E=0,T=v-1;(L!==0||E<w)&&T!==-1;T--,E++)L+=a*x[T]>>>0,x[T]=L%256>>>0,L=L/256>>>0;if(L!==0)throw new Error("Non-zero carry");w=E,m++}if(g[m]!==" "){for(var k=v-w;k!==v&&x[k]===0;)k++;for(var D=new Uint8Array(f+(v-k)),y=f;k!==v;)D[y++]=x[k++];return D}}}function p(g){var m=h(g);if(m)return m;throw new Error(`Non-${e} character`)}return{encode:d,decodeUnsafe:h,decode:p}}var Bh=Uh,$h=Bh;class zh{name;prefix;baseEncode;constructor(e,t,r){this.name=e,this.prefix=t,this.baseEncode=r}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}let qh=class{name;prefix;baseDecode;prefixCodePoint;constructor(e,t,r){this.name=e,this.prefix=t;const s=t.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=r}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return Al(this,e)}};class Kh{decoders;constructor(e){this.decoders=e}or(e){return Al(this,e)}decode(e){const t=e[0],r=this.decoders[t];if(r!=null)return r.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function Al(n,e){return new Kh({...n.decoders??{[n.prefix]:n},...e.decoders??{[e.prefix]:e}})}class Wh{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(e,t,r,s){this.name=e,this.prefix=t,this.baseEncode=r,this.baseDecode=s,this.encoder=new zh(e,t,r),this.decoder=new qh(e,t,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}function Bs({name:n,prefix:e,encode:t,decode:r}){return new Wh(n,e,t,r)}function mr({name:n,prefix:e,alphabet:t}){const{encode:r,decode:s}=$h(t,n);return Bs({prefix:e,name:n,encode:r,decode:i=>Us(s(i))})}function Vh(n,e,t,r){let s=n.length;for(;n[s-1]==="=";)--s;const i=new Uint8Array(s*t/8|0);let o=0,a=0,c=0;for(let u=0;u<s;++u){const l=e[n[u]];if(l===void 0)throw new SyntaxError(`Non-${r} character`);a=a<<t|l,o+=t,o>=8&&(o-=8,i[c++]=255&a>>o)}if(o>=t||(255&a<<8-o)!==0)throw new SyntaxError("Unexpected end of data");return i}function Hh(n,e,t){const r=e[e.length-1]==="=",s=(1<<t)-1;let i="",o=0,a=0;for(let c=0;c<n.length;++c)for(a=a<<8|n[c],o+=8;o>t;)o-=t,i+=e[s&a>>o];if(o!==0&&(i+=e[s&a<<t-o]),r)for(;(i.length*t&7)!==0;)i+="=";return i}function Gh(n){const e={};for(let t=0;t<n.length;++t)e[n[t]]=t;return e}function Ee({name:n,prefix:e,bitsPerChar:t,alphabet:r}){const s=Gh(r);return Bs({prefix:e,name:n,encode(i){return Hh(i,r,t)},decode(i){return Vh(i,s,t,n)}})}const ge=mr({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Qh=mr({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),Yh=Object.freeze(Object.defineProperty({__proto__:null,base58btc:ge,base58flickr:Qh},Symbol.toStringTag,{value:"Module"})),_t=Ee({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Xh=Ee({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Zh=Ee({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),jh=Ee({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Jh=Ee({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),ef=Ee({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),tf=Ee({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),nf=Ee({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),rf=Ee({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),sf=Object.freeze(Object.defineProperty({__proto__:null,base32:_t,base32hex:Jh,base32hexpad:tf,base32hexpadupper:nf,base32hexupper:ef,base32pad:Zh,base32padupper:jh,base32upper:Xh,base32z:rf},Symbol.toStringTag,{value:"Module"})),Zr=mr({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),of=mr({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),af=Object.freeze(Object.defineProperty({__proto__:null,base36:Zr,base36upper:of},Symbol.toStringTag,{value:"Module"}));var cf=_l,ga=128,lf=-128,uf=Math.pow(2,31);function _l(n,e,t){e=e||[],t=t||0;for(var r=t;n>=uf;)e[t++]=n&255|ga,n/=128;for(;n&lf;)e[t++]=n&255|ga,n>>>=7;return e[t]=n|0,_l.bytes=t-r+1,e}var df=Hi,hf=128,ma=127;function Hi(n,r){var t=0,r=r||0,s=0,i=r,o,a=n.length;do{if(i>=a)throw Hi.bytes=0,new RangeError("Could not decode varint");o=n[i++],t+=s<28?(o&ma)<<s:(o&ma)*Math.pow(2,s),s+=7}while(o>=hf);return Hi.bytes=i-r,t}var ff=Math.pow(2,7),pf=Math.pow(2,14),gf=Math.pow(2,21),mf=Math.pow(2,28),yf=Math.pow(2,35),wf=Math.pow(2,42),bf=Math.pow(2,49),Ef=Math.pow(2,56),vf=Math.pow(2,63),Sf=function(n){return n<ff?1:n<pf?2:n<gf?3:n<mf?4:n<yf?5:n<wf?6:n<bf?7:n<Ef?8:n<vf?9:10},xf={encode:cf,decode:df,encodingLength:Sf},rs=xf;function Gi(n,e=0){return[rs.decode(n,e),rs.decode.bytes]}function ss(n,e,t=0){return rs.encode(n,e,t),e}function is(n){return rs.encodingLength(n)}function sr(n,e){const t=e.byteLength,r=is(n),s=r+is(t),i=new Uint8Array(s+t);return ss(n,i,0),ss(t,i,r),i.set(e,s),new Po(n,t,e,i)}function yr(n){const e=Us(n),[t,r]=Gi(e),[s,i]=Gi(e.subarray(r)),o=e.subarray(r+i);if(o.byteLength!==s)throw new Error("Incorrect length");return new Po(t,s,o,e)}function Af(n,e){if(n===e)return!0;{const t=e;return n.code===t.code&&n.size===t.size&&t.bytes instanceof Uint8Array&&Nh(n.bytes,t.bytes)}}class Po{code;size;digest;bytes;constructor(e,t,r,s){this.code=e,this.size=t,this.digest=r,this.bytes=s}}function ya(n,e){const{bytes:t,version:r}=n;switch(r){case 0:return Cf(t,Qi(n),e??ge.encoder);default:return If(t,Qi(n),e??_t.encoder)}}const wa=new WeakMap;function Qi(n){const e=wa.get(n);if(e==null){const t=new Map;return wa.set(n,t),t}return e}class re{code;version;multihash;bytes;"/";constructor(e,t,r,s){this.code=t,this.version=e,this.multihash=r,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==Fn)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==Tf)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return re.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,r=sr(e,t);return re.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return re.equals(this,e)}static equals(e,t){const r=t;return r!=null&&e.code===r.code&&e.version===r.version&&Af(e.multihash,r.multihash)}toString(e){return ya(this,e)}toJSON(){return{"/":ya(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const t=e;if(t instanceof re)return t;if(t["/"]!=null&&t["/"]===t.bytes||t.asCID===t){const{version:r,code:s,multihash:i,bytes:o}=t;return new re(r,s,i,o??ba(r,s,i.bytes))}else if(t[Pf]===!0){const{version:r,multihash:s,code:i}=t,o=yr(s);return re.create(r,i,o)}else return null}static create(e,t,r){if(typeof t!="number")throw new Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(t!==Fn)throw new Error(`Version 0 CID must use dag-pb (code: ${Fn}) block encoding`);return new re(e,t,r,r.bytes)}case 1:{const s=ba(e,t,r.bytes);return new re(e,t,r,s)}default:throw new Error("Invalid version")}}static createV0(e){return re.create(0,Fn,e)}static createV1(e,t){return re.create(1,e,t)}static decode(e){const[t,r]=re.decodeFirst(e);if(r.length!==0)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=re.inspectBytes(e),r=t.size-t.multihashSize,s=Us(e.subarray(r,r+t.multihashSize));if(s.byteLength!==t.multihashSize)throw new Error("Incorrect length");const i=s.subarray(t.multihashSize-t.digestSize),o=new Po(t.multihashCode,t.digestSize,i,s);return[t.version===0?re.createV0(o):re.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const r=()=>{const[d,h]=Gi(e.subarray(t));return t+=h,d};let s=r(),i=Fn;if(s===18?(s=0,t=0):i=r(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);const o=t,a=r(),c=r(),u=t+c,l=u-o;return{version:s,codec:i,multihashCode:a,digestSize:c,multihashSize:l,size:u}}static parse(e,t){const[r,s]=_f(e,t),i=re.decode(s);if(i.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return Qi(i).set(r,e),i}}function _f(n,e){switch(n[0]){case"Q":{const t=e??ge;return[ge.prefix,t.decode(`${ge.prefix}${n}`)]}case ge.prefix:{const t=e??ge;return[ge.prefix,t.decode(n)]}case _t.prefix:{const t=e??_t;return[_t.prefix,t.decode(n)]}case Zr.prefix:{const t=e??Zr;return[Zr.prefix,t.decode(n)]}default:{if(e==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[n[0],e.decode(n)]}}}function Cf(n,e,t){const{prefix:r}=t;if(r!==ge.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);const s=e.get(r);if(s==null){const i=t.encode(n).slice(1);return e.set(r,i),i}else return s}function If(n,e,t){const{prefix:r}=t,s=e.get(r);if(s==null){const i=t.encode(n);return e.set(r,i),i}else return s}const Fn=112,Tf=18;function ba(n,e,t){const r=is(n),s=r+is(e),i=new Uint8Array(s+t.byteLength);return ss(n,i,0),ss(e,i,r),i.set(t,s),i}const Pf=Symbol.for("@ipld/js-cid/CID"),Cl=0,Df="identity",Il=Us;function Lf(n){return sr(Cl,Il(n))}const wr={code:Cl,name:Df,encode:Il,digest:Lf};function Te(n,e){if(n===e)return!0;if(n.byteLength!==e.byteLength)return!1;for(let t=0;t<n.byteLength;t++)if(n[t]!==e[t])return!1;return!0}function j(n=0){return new Uint8Array(n)}function nt(n=0){return new Uint8Array(n)}function Ut(n,e){e==null&&(e=n.reduce((s,i)=>s+i.length,0));const t=nt(e);let r=0;for(const s of n)t.set(s,r),r+=s.length;return t}const Tl=Symbol.for("@achingbrain/uint8arraylist");function Ea(n,e){if(e==null||e<0)throw new RangeError("index is out of bounds");let t=0;for(const r of n){const s=t+r.byteLength;if(e<s)return{buf:r,index:e-t};t=s}throw new RangeError("index is out of bounds")}function Pr(n){return!!n?.[Tl]}class H{bufs;length;[Tl]=!0;constructor(...e){this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(const r of e)if(r instanceof Uint8Array)t+=r.byteLength,this.bufs.push(r);else if(Pr(r))t+=r.byteLength,this.bufs.push(...r.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(const r of e.reverse())if(r instanceof Uint8Array)t+=r.byteLength,this.bufs.unshift(r);else if(Pr(r))t+=r.byteLength,this.bufs.unshift(...r.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}get(e){const t=Ea(this.bufs,e);return t.buf[t.index]}set(e,t){const r=Ea(this.bufs,e);r.buf[r.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let r=0;r<e.length;r++)this.set(t+r,e[r]);else if(Pr(e))for(let r=0;r<e.length;r++)this.set(t+r,e.get(r));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(e>=this.bufs[0].byteLength)e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}}}slice(e,t){const{bufs:r,length:s}=this._subList(e,t);return Ut(r,s)}subarray(e,t){const{bufs:r,length:s}=this._subList(e,t);return r.length===1?r[0]:Ut(r,s)}sublist(e,t){const{bufs:r,length:s}=this._subList(e,t),i=new H;return i.length=s,i.bufs=[...r],i}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(e===0&&t===this.length)return{bufs:this.bufs,length:this.length};const r=[];let s=0;for(let i=0;i<this.bufs.length;i++){const o=this.bufs[i],a=s,c=a+o.byteLength;if(s=c,e>=c)continue;const u=e>=a&&e<c,l=t>a&&t<=c;if(u&&l){if(e===a&&t===c){r.push(o);break}const d=e-a;r.push(o.subarray(d,d+(t-e)));break}if(u){if(e===0){r.push(o);continue}r.push(o.subarray(e-a));continue}if(l){if(t===c){r.push(o);break}r.push(o.subarray(0,t-a));break}r.push(o)}return{bufs:r,length:t-e}}indexOf(e,t=0){if(!Pr(e)&&!(e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const r=e instanceof Uint8Array?e:e.subarray();if(t=Number(t??0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),e.length===0)return t>this.length?this.length:t;const s=r.byteLength;if(s===0)throw new TypeError("search must be at least 1 byte long");const i=256,o=new Int32Array(i);for(let d=0;d<i;d++)o[d]=-1;for(let d=0;d<s;d++)o[r[d]]=d;const a=o,c=this.byteLength-r.byteLength,u=r.byteLength-1;let l;for(let d=t;d<=c;d+=l){l=0;for(let h=u;h>=0;h--){const p=this.get(d+h);if(r[h]!==p){l=Math.max(1,h-a[p]);break}}if(l===0)return d}return-1}getInt8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,t){const r=nt(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setInt8(0,t),this.write(r,e)}getInt16(e,t){const r=this.subarray(e,e+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt16(0,t)}setInt16(e,t,r){const s=j(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt16(0,t,r),this.write(s,e)}getInt32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt32(0,t)}setInt32(e,t,r){const s=j(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt32(0,t,r),this.write(s,e)}getBigInt64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigInt64(0,t)}setBigInt64(e,t,r){const s=j(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigInt64(0,t,r),this.write(s,e)}getUint8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,t){const r=nt(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setUint8(0,t),this.write(r,e)}getUint16(e,t){const r=this.subarray(e,e+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint16(0,t)}setUint16(e,t,r){const s=j(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint16(0,t,r),this.write(s,e)}getUint32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint32(0,t)}setUint32(e,t,r){const s=j(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint32(0,t,r),this.write(s,e)}getBigUint64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigUint64(0,t)}setBigUint64(e,t,r){const s=j(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigUint64(0,t,r),this.write(s,e)}getFloat32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat32(0,t)}setFloat32(e,t,r){const s=j(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat32(0,t,r),this.write(s,e)}getFloat64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat64(0,t)}setFloat64(e,t,r){const s=j(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat64(0,t,r),this.write(s,e)}equals(e){if(e==null||!(e instanceof H)||e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!Te(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){const r=new H;return r.bufs=e,t==null&&(t=e.reduce((s,i)=>s+i.byteLength,0)),r.length=t,r}}const kf=mr({prefix:"9",name:"base10",alphabet:"0123456789"}),Rf=Object.freeze(Object.defineProperty({__proto__:null,base10:kf},Symbol.toStringTag,{value:"Module"})),Mf=Ee({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Nf=Ee({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),Of=Object.freeze(Object.defineProperty({__proto__:null,base16:Mf,base16upper:Nf},Symbol.toStringTag,{value:"Module"})),Ff=Ee({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),Uf=Object.freeze(Object.defineProperty({__proto__:null,base2:Ff},Symbol.toStringTag,{value:"Module"})),Pl=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),Bf=Pl.reduce((n,e,t)=>(n[t]=e,n),[]),$f=Pl.reduce((n,e,t)=>{const r=e.codePointAt(0);if(r==null)throw new Error(`Invalid character: ${e}`);return n[r]=t,n},[]);function zf(n){return n.reduce((e,t)=>(e+=Bf[t],e),"")}function qf(n){const e=[];for(const t of n){const r=t.codePointAt(0);if(r==null)throw new Error(`Invalid character: ${t}`);const s=$f[r];if(s==null)throw new Error(`Non-base256emoji character: ${t}`);e.push(s)}return new Uint8Array(e)}const Kf=Bs({prefix:"🚀",name:"base256emoji",encode:zf,decode:qf}),Wf=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:Kf},Symbol.toStringTag,{value:"Module"})),Dl=Ee({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Vf=Ee({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Ll=Ee({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Hf=Ee({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),Gf=Object.freeze(Object.defineProperty({__proto__:null,base64:Dl,base64pad:Vf,base64url:Ll,base64urlpad:Hf},Symbol.toStringTag,{value:"Module"})),Qf=Ee({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),Yf=Object.freeze(Object.defineProperty({__proto__:null,base8:Qf},Symbol.toStringTag,{value:"Module"})),Xf=Bs({prefix:"\0",name:"identity",encode:n=>Fh(n),decode:n=>Oh(n)}),Zf=Object.freeze(Object.defineProperty({__proto__:null,identity:Xf},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;function jf({name:n,code:e,encode:t}){return new Jf(n,e,t)}class Jf{name;code;encode;constructor(e,t,r){this.name=e,this.code=t,this.encode=r}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?sr(this.code,t):t.then(r=>sr(this.code,r))}else throw Error("Unknown type, must be binary type")}}function ep(n){return async e=>new Uint8Array(await crypto.subtle.digest(n,e))}const kl=jf({name:"sha2-256",code:18,encode:ep("SHA-256")}),Yi={...Zf,...Uf,...Yf,...Rf,...Of,...sf,...af,...Yh,...Gf,...Wf};function Rl(n,e,t,r){return{name:n,prefix:e,encoder:{name:n,prefix:e,encode:t},decoder:{decode:r}}}const va=Rl("utf8","u",n=>"u"+new TextDecoder("utf8").decode(n),n=>new TextEncoder().encode(n.substring(1))),ti=Rl("ascii","a",n=>{let e="a";for(let t=0;t<n.length;t++)e+=String.fromCharCode(n[t]);return e},n=>{n=n.substring(1);const e=nt(n.length);for(let t=0;t<n.length;t++)e[t]=n.charCodeAt(t);return e}),Ml={utf8:va,"utf-8":va,hex:Yi.base16,latin1:ti,ascii:ti,binary:ti,...Yi};function $(n,e="utf8"){const t=Ml[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.decoder.decode(`${t.prefix}${n}`)}function q(n,e="utf8"){const t=Ml[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.encoder.encode(n).substring(1)}const tp=parseInt("11111",2),Xi=parseInt("10000000",2),np=parseInt("01111111",2),Sa={0:Un,1:Un,2:rp,3:op,4:ap,5:ip,6:sp,16:Un,22:Un,48:Un};function $s(n,e={offset:0}){const t=n[e.offset]&tp;if(e.offset++,Sa[t]!=null)return Sa[t](n,e);throw new Error("No decoder for tag "+t)}function br(n,e){let t=0;if((n[e.offset]&Xi)===Xi){const r=n[e.offset]&np;let s="0x";e.offset++;for(let i=0;i<r;i++,e.offset++)s+=n[e.offset].toString(16).padStart(2,"0");t=parseInt(s,16)}else t=n[e.offset],e.offset++;return t}function Un(n,e){br(n,e);const t=[];for(;!(e.offset>=n.byteLength);){const r=$s(n,e);if(r===null)break;t.push(r)}return t}function rp(n,e){const t=br(n,e),r=e.offset,s=e.offset+t,i=[];for(let o=r;o<s;o++)o===r&&n[o]===0||i.push(n[o]);return e.offset+=t,Uint8Array.from(i)}function sp(n,e){const t=br(n,e),r=e.offset+t,s=n[e.offset];e.offset++;let i=0,o=0;s<40?(i=0,o=s):s<80?(i=1,o=s-40):(i=2,o=s-80);let a=`${i}.${o}`,c=[];for(;e.offset<r;){const u=n[e.offset];if(e.offset++,c.push(u&127),u<128){c.reverse();let l=0;for(let d=0;d<c.length;d++)l+=c[d]<<d*7;a+=`.${l}`,c=[]}}return a}function ip(n,e){return e.offset++,null}function op(n,e){const t=br(n,e),r=n[e.offset];e.offset++;const s=n.subarray(e.offset,e.offset+t-1);if(e.offset+=t,r!==0)throw new Error("Unused bits in bit string is unimplemented");return s}function ap(n,e){const t=br(n,e),r=n.subarray(e.offset,e.offset+t);return e.offset+=t,r}function cp(n){let e=n.toString(16);e.length%2===1&&(e="0"+e);const t=new H;for(let r=0;r<e.length;r+=2)t.append(Uint8Array.from([parseInt(`${e[r]}${e[r+1]}`,16)]));return t}function Do(n){if(n.byteLength<128)return Uint8Array.from([n.byteLength]);const e=cp(n.byteLength);return new H(Uint8Array.from([e.byteLength|Xi]),e)}function Zi(n){const e=new H,t=128;return(n.subarray()[0]&t)===t&&e.append(Uint8Array.from([0])),e.append(n),new H(Uint8Array.from([2]),Do(e),e)}function Nl(n){const e=Uint8Array.from([0]),t=new H(e,n);return new H(Uint8Array.from([3]),Do(t),t)}function Xn(n,e=48){const t=new H;for(const r of n)t.append(r);return new H(Uint8Array.from([e]),Do(t),t)}async function lp(n,e,t,r){const s=await crypto.subtle.importKey("jwk",n,{name:"ECDSA",namedCurve:n.crv??"P-256"},!1,["verify"]);r?.signal?.throwIfAborted();const i=await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},s,e,t.subarray());return r?.signal?.throwIfAborted(),i}const up=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),dp=Uint8Array.from([6,5,43,129,4,0,34]),hp=Uint8Array.from([6,5,43,129,4,0,35]),fp={ext:!0,kty:"EC",crv:"P-256"},pp={ext:!0,kty:"EC",crv:"P-384"},gp={ext:!0,kty:"EC",crv:"P-521"},ni=32,ri=48,si=66;function Ol(n){const e=$s(n);return mp(e)}function mp(n){const e=n[1][1][0],t=1;let r,s;if(e.byteLength===ni*2+1)return r=q(e.subarray(t,t+ni),"base64url"),s=q(e.subarray(t+ni),"base64url"),new ii({...fp,key_ops:["verify"],x:r,y:s});if(e.byteLength===ri*2+1)return r=q(e.subarray(t,t+ri),"base64url"),s=q(e.subarray(t+ri),"base64url"),new ii({...pp,key_ops:["verify"],x:r,y:s});if(e.byteLength===si*2+1)return r=q(e.subarray(t,t+si),"base64url"),s=q(e.subarray(t+si),"base64url"),new ii({...gp,key_ops:["verify"],x:r,y:s});throw new z(`coordinates were wrong length, got ${e.byteLength}, expected 65, 97 or 133`)}function yp(n){return Xn([Zi(Uint8Array.from([1])),Xn([wp(n.crv)],160),Xn([Nl(new H(Uint8Array.from([4]),$(n.x??"","base64url"),$(n.y??"","base64url")))],161)]).subarray()}function wp(n){if(n==="P-256")return up;if(n==="P-384")return dp;if(n==="P-521")return hp;throw new z(`Invalid curve ${n}`)}class ii{type="ECDSA";jwk;_raw;constructor(e){this.jwk=e}get raw(){return this._raw==null&&(this._raw=yp(this.jwk)),this._raw}toMultihash(){return wr.digest(dt(this))}toCID(){return re.createV1(114,this.toMultihash())}toString(){return ge.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Te(this.raw,e.raw)}async verify(e,t,r){return lp(this.jwk,t,e,r)}}const Yt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Lo(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function os(n){if(!Number.isSafeInteger(n)||n<0)throw new Error("positive integer expected, got "+n)}function rt(n,...e){if(!Lo(n))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(n.length))throw new Error("Uint8Array expected of length "+e+", got length="+n.length)}function ko(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");os(n.outputLen),os(n.blockLen)}function as(n,e=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(e&&n.finished)throw new Error("Hash#digest() has already been called")}function bp(n,e){rt(n);const t=e.outputLen;if(n.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function Bt(...n){for(let e=0;e<n.length;e++)n[e].fill(0)}function oi(n){return new DataView(n.buffer,n.byteOffset,n.byteLength)}function Ye(n,e){return n<<32-e|n>>>e}const Fl=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Ep=Array.from({length:256},(n,e)=>e.toString(16).padStart(2,"0"));function fn(n){if(rt(n),Fl)return n.toHex();let e="";for(let t=0;t<n.length;t++)e+=Ep[n[t]];return e}const it={_0:48,_9:57,A:65,F:70,a:97,f:102};function xa(n){if(n>=it._0&&n<=it._9)return n-it._0;if(n>=it.A&&n<=it.F)return n-(it.A-10);if(n>=it.a&&n<=it.f)return n-(it.a-10)}function Ro(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);if(Fl)return Uint8Array.fromHex(n);const e=n.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(t);for(let s=0,i=0;s<t;s++,i+=2){const o=xa(n.charCodeAt(i)),a=xa(n.charCodeAt(i+1));if(o===void 0||a===void 0){const c=n[i]+n[i+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+i)}r[s]=o*16+a}return r}function vp(n){if(typeof n!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(n))}function ir(n){return typeof n=="string"&&(n=vp(n)),rt(n),n}function ut(...n){let e=0;for(let r=0;r<n.length;r++){const s=n[r];rt(s),e+=s.length}const t=new Uint8Array(e);for(let r=0,s=0;r<n.length;r++){const i=n[r];t.set(i,s),s+=i.length}return t}class Ul{}function Bl(n){const e=r=>n().update(ir(r)).digest(),t=n();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>n(),e}function zs(n=32){if(Yt&&typeof Yt.getRandomValues=="function")return Yt.getRandomValues(new Uint8Array(n));if(Yt&&typeof Yt.randomBytes=="function")return Uint8Array.from(Yt.randomBytes(n));throw new Error("crypto.getRandomValues must be defined")}function Sp(n,e,t,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(e,t,r);const s=BigInt(32),i=BigInt(4294967295),o=Number(t>>s&i),a=Number(t&i),c=r?4:0,u=r?0:4;n.setUint32(e+c,o,r),n.setUint32(e+u,a,r)}function xp(n,e,t){return n&e^~n&t}function Ap(n,e,t){return n&e^n&t^e&t}class $l extends Ul{constructor(e,t,r,s){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=s,this.buffer=new Uint8Array(e),this.view=oi(this.buffer)}update(e){as(this),e=ir(e),rt(e);const{view:t,buffer:r,blockLen:s}=this,i=e.length;for(let o=0;o<i;){const a=Math.min(s-this.pos,i-o);if(a===s){const c=oi(e);for(;s<=i-o;o+=s)this.process(c,o);continue}r.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){as(this),bp(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:s,isLE:i}=this;let{pos:o}=this;t[o++]=128,Bt(this.buffer.subarray(o)),this.padOffset>s-o&&(this.process(r,0),o=0);for(let d=o;d<s;d++)t[d]=0;Sp(r,s-8,BigInt(this.length*8),i),this.process(r,0);const a=oi(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=c/4,l=this.get();if(u>l.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<u;d++)a.setUint32(4*d,l[d],i)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:s,finished:i,destroyed:o,pos:a}=this;return e.destroyed=o,e.finished=i,e.length=s,e.pos=a,s%t&&e.buffer.set(r),e}clone(){return this._cloneInto()}}const wt=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Se=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),Dr=BigInt(2**32-1),Aa=BigInt(32);function _p(n,e=!1){return e?{h:Number(n&Dr),l:Number(n>>Aa&Dr)}:{h:Number(n>>Aa&Dr)|0,l:Number(n&Dr)|0}}function Cp(n,e=!1){const t=n.length;let r=new Uint32Array(t),s=new Uint32Array(t);for(let i=0;i<t;i++){const{h:o,l:a}=_p(n[i],e);[r[i],s[i]]=[o,a]}return[r,s]}const _a=(n,e,t)=>n>>>t,Ca=(n,e,t)=>n<<32-t|e>>>t,Xt=(n,e,t)=>n>>>t|e<<32-t,Zt=(n,e,t)=>n<<32-t|e>>>t,Lr=(n,e,t)=>n<<64-t|e>>>t-32,kr=(n,e,t)=>n>>>t-32|e<<64-t;function ot(n,e,t,r){const s=(e>>>0)+(r>>>0);return{h:n+t+(s/2**32|0)|0,l:s|0}}const Ip=(n,e,t)=>(n>>>0)+(e>>>0)+(t>>>0),Tp=(n,e,t,r)=>e+t+r+(n/2**32|0)|0,Pp=(n,e,t,r)=>(n>>>0)+(e>>>0)+(t>>>0)+(r>>>0),Dp=(n,e,t,r,s)=>e+t+r+s+(n/2**32|0)|0,Lp=(n,e,t,r,s)=>(n>>>0)+(e>>>0)+(t>>>0)+(r>>>0)+(s>>>0),kp=(n,e,t,r,s,i)=>e+t+r+s+i+(n/2**32|0)|0,Rp=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),bt=new Uint32Array(64);class Mp extends $l{constructor(e=32){super(64,e,8,!1),this.A=wt[0]|0,this.B=wt[1]|0,this.C=wt[2]|0,this.D=wt[3]|0,this.E=wt[4]|0,this.F=wt[5]|0,this.G=wt[6]|0,this.H=wt[7]|0}get(){const{A:e,B:t,C:r,D:s,E:i,F:o,G:a,H:c}=this;return[e,t,r,s,i,o,a,c]}set(e,t,r,s,i,o,a,c){this.A=e|0,this.B=t|0,this.C=r|0,this.D=s|0,this.E=i|0,this.F=o|0,this.G=a|0,this.H=c|0}process(e,t){for(let d=0;d<16;d++,t+=4)bt[d]=e.getUint32(t,!1);for(let d=16;d<64;d++){const h=bt[d-15],p=bt[d-2],g=Ye(h,7)^Ye(h,18)^h>>>3,m=Ye(p,17)^Ye(p,19)^p>>>10;bt[d]=m+bt[d-7]+g+bt[d-16]|0}let{A:r,B:s,C:i,D:o,E:a,F:c,G:u,H:l}=this;for(let d=0;d<64;d++){const h=Ye(a,6)^Ye(a,11)^Ye(a,25),p=l+h+xp(a,c,u)+Rp[d]+bt[d]|0,m=(Ye(r,2)^Ye(r,13)^Ye(r,22))+Ap(r,s,i)|0;l=u,u=c,c=a,a=o+p|0,o=i,i=s,s=r,r=p+m|0}r=r+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,u=u+this.G|0,l=l+this.H|0,this.set(r,s,i,o,a,c,u,l)}roundClean(){Bt(bt)}destroy(){this.set(0,0,0,0,0,0,0,0),Bt(this.buffer)}}const zl=Cp(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(n=>BigInt(n))),Np=zl[0],Op=zl[1],Et=new Uint32Array(80),vt=new Uint32Array(80);class Fp extends $l{constructor(e=64){super(128,e,16,!1),this.Ah=Se[0]|0,this.Al=Se[1]|0,this.Bh=Se[2]|0,this.Bl=Se[3]|0,this.Ch=Se[4]|0,this.Cl=Se[5]|0,this.Dh=Se[6]|0,this.Dl=Se[7]|0,this.Eh=Se[8]|0,this.El=Se[9]|0,this.Fh=Se[10]|0,this.Fl=Se[11]|0,this.Gh=Se[12]|0,this.Gl=Se[13]|0,this.Hh=Se[14]|0,this.Hl=Se[15]|0}get(){const{Ah:e,Al:t,Bh:r,Bl:s,Ch:i,Cl:o,Dh:a,Dl:c,Eh:u,El:l,Fh:d,Fl:h,Gh:p,Gl:g,Hh:m,Hl:f}=this;return[e,t,r,s,i,o,a,c,u,l,d,h,p,g,m,f]}set(e,t,r,s,i,o,a,c,u,l,d,h,p,g,m,f){this.Ah=e|0,this.Al=t|0,this.Bh=r|0,this.Bl=s|0,this.Ch=i|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=u|0,this.El=l|0,this.Fh=d|0,this.Fl=h|0,this.Gh=p|0,this.Gl=g|0,this.Hh=m|0,this.Hl=f|0}process(e,t){for(let x=0;x<16;x++,t+=4)Et[x]=e.getUint32(t),vt[x]=e.getUint32(t+=4);for(let x=16;x<80;x++){const L=Et[x-15]|0,E=vt[x-15]|0,T=Xt(L,E,1)^Xt(L,E,8)^_a(L,E,7),k=Zt(L,E,1)^Zt(L,E,8)^Ca(L,E,7),D=Et[x-2]|0,y=vt[x-2]|0,S=Xt(D,y,19)^Lr(D,y,61)^_a(D,y,6),b=Zt(D,y,19)^kr(D,y,61)^Ca(D,y,6),A=Pp(k,b,vt[x-7],vt[x-16]),_=Dp(A,T,S,Et[x-7],Et[x-16]);Et[x]=_|0,vt[x]=A|0}let{Ah:r,Al:s,Bh:i,Bl:o,Ch:a,Cl:c,Dh:u,Dl:l,Eh:d,El:h,Fh:p,Fl:g,Gh:m,Gl:f,Hh:w,Hl:v}=this;for(let x=0;x<80;x++){const L=Xt(d,h,14)^Xt(d,h,18)^Lr(d,h,41),E=Zt(d,h,14)^Zt(d,h,18)^kr(d,h,41),T=d&p^~d&m,k=h&g^~h&f,D=Lp(v,E,k,Op[x],vt[x]),y=kp(D,w,L,T,Np[x],Et[x]),S=D|0,b=Xt(r,s,28)^Lr(r,s,34)^Lr(r,s,39),A=Zt(r,s,28)^kr(r,s,34)^kr(r,s,39),_=r&i^r&a^i&a,I=s&o^s&c^o&c;w=m|0,v=f|0,m=p|0,f=g|0,p=d|0,g=h|0,{h:d,l:h}=ot(u|0,l|0,y|0,S|0),u=a|0,l=c|0,a=i|0,c=o|0,i=r|0,o=s|0;const C=Ip(S,A,I);r=Tp(C,y,b,_),s=C|0}({h:r,l:s}=ot(this.Ah|0,this.Al|0,r|0,s|0)),{h:i,l:o}=ot(this.Bh|0,this.Bl|0,i|0,o|0),{h:a,l:c}=ot(this.Ch|0,this.Cl|0,a|0,c|0),{h:u,l}=ot(this.Dh|0,this.Dl|0,u|0,l|0),{h:d,l:h}=ot(this.Eh|0,this.El|0,d|0,h|0),{h:p,l:g}=ot(this.Fh|0,this.Fl|0,p|0,g|0),{h:m,l:f}=ot(this.Gh|0,this.Gl|0,m|0,f|0),{h:w,l:v}=ot(this.Hh|0,this.Hl|0,w|0,v|0),this.set(r,s,i,o,a,c,u,l,d,h,p,g,m,f,w,v)}roundClean(){Bt(Et,vt)}destroy(){Bt(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const ql=Bl(()=>new Mp),Up=Bl(()=>new Fp);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Mo=BigInt(0),ji=BigInt(1);function $t(n,e){if(typeof e!="boolean")throw new Error(n+" boolean expected, got "+e)}function Rr(n){const e=n.toString(16);return e.length&1?"0"+e:e}function Kl(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return n===""?Mo:BigInt("0x"+n)}function qs(n){return Kl(fn(n))}function zt(n){return rt(n),Kl(fn(Uint8Array.from(n).reverse()))}function No(n,e){return Ro(n.toString(16).padStart(e*2,"0"))}function Er(n,e){return No(n,e).reverse()}function ce(n,e,t){let r;if(typeof e=="string")try{r=Ro(e)}catch(i){throw new Error(n+" must be hex string or Uint8Array, cause: "+i)}else if(Lo(e))r=Uint8Array.from(e);else throw new Error(n+" must be hex string or Uint8Array");const s=r.length;if(typeof t=="number"&&s!==t)throw new Error(n+" of length "+t+" expected, got "+s);return r}const ai=n=>typeof n=="bigint"&&Mo<=n;function Bp(n,e,t){return ai(n)&&ai(e)&&ai(t)&&e<=n&&n<t}function St(n,e,t,r){if(!Bp(e,t,r))throw new Error("expected valid "+n+": "+t+" <= n < "+r+", got "+e)}function $p(n){let e;for(e=0;n>Mo;n>>=ji,e+=1);return e}const Ks=n=>(ji<<BigInt(n))-ji;function zp(n,e,t){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");const r=p=>new Uint8Array(p),s=p=>Uint8Array.of(p);let i=r(n),o=r(n),a=0;const c=()=>{i.fill(1),o.fill(0),a=0},u=(...p)=>t(o,i,...p),l=(p=r(0))=>{o=u(s(0),p),i=u(),p.length!==0&&(o=u(s(1),p),i=u())},d=()=>{if(a++>=1e3)throw new Error("drbg: tried 1000 values");let p=0;const g=[];for(;p<e;){i=u();const m=i.slice();g.push(m),p+=i.length}return ut(...g)};return(p,g)=>{c(),l(p);let m;for(;!(m=g(d()));)l();return c(),m}}function Pn(n,e,t={}){if(!n||typeof n!="object")throw new Error("expected valid options object");function r(s,i,o){const a=n[s];if(o&&a===void 0)return;const c=typeof a;if(c!==i||a===null)throw new Error(`param "${s}" is invalid: expected ${i}, got ${c}`)}Object.entries(e).forEach(([s,i])=>r(s,i,!1)),Object.entries(t).forEach(([s,i])=>r(s,i,!0))}function cs(n){const e=new WeakMap;return(t,...r)=>{const s=e.get(t);if(s!==void 0)return s;const i=n(t,...r);return e.set(t,i),i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Fe=BigInt(0),be=BigInt(1),Lt=BigInt(2),qp=BigInt(3),Wl=BigInt(4),Vl=BigInt(5),Hl=BigInt(8);function le(n,e){const t=n%e;return t>=Fe?t:e+t}function ae(n,e,t){let r=n;for(;e-- >Fe;)r*=r,r%=t;return r}function Ia(n,e){if(n===Fe)throw new Error("invert: expected non-zero number");if(e<=Fe)throw new Error("invert: expected positive modulus, got "+e);let t=le(n,e),r=e,s=Fe,i=be;for(;t!==Fe;){const a=r/t,c=r%t,u=s-i*a;r=t,t=c,s=i,i=u}if(r!==be)throw new Error("invert: does not exist");return le(s,e)}function Gl(n,e){const t=(n.ORDER+be)/Wl,r=n.pow(e,t);if(!n.eql(n.sqr(r),e))throw new Error("Cannot find square root");return r}function Kp(n,e){const t=(n.ORDER-Vl)/Hl,r=n.mul(e,Lt),s=n.pow(r,t),i=n.mul(e,s),o=n.mul(n.mul(i,Lt),s),a=n.mul(i,n.sub(o,n.ONE));if(!n.eql(n.sqr(a),e))throw new Error("Cannot find square root");return a}function Wp(n){if(n<BigInt(3))throw new Error("sqrt is not defined for small field");let e=n-be,t=0;for(;e%Lt===Fe;)e/=Lt,t++;let r=Lt;const s=Dn(n);for(;Ta(s,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return Gl;let i=s.pow(r,e);const o=(e+be)/Lt;return function(c,u){if(c.is0(u))return u;if(Ta(c,u)!==1)throw new Error("Cannot find square root");let l=t,d=c.mul(c.ONE,i),h=c.pow(u,e),p=c.pow(u,o);for(;!c.eql(h,c.ONE);){if(c.is0(h))return c.ZERO;let g=1,m=c.sqr(h);for(;!c.eql(m,c.ONE);)if(g++,m=c.sqr(m),g===l)throw new Error("Cannot find square root");const f=be<<BigInt(l-g-1),w=c.pow(d,f);l=g,d=c.sqr(w),h=c.mul(h,d),p=c.mul(p,w)}return p}}function Vp(n){return n%Wl===qp?Gl:n%Hl===Vl?Kp:Wp(n)}const Hp=(n,e)=>(le(n,e)&be)===be,Gp=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Qp(n){const e={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},t=Gp.reduce((r,s)=>(r[s]="function",r),e);return Pn(n,t),n}function Yp(n,e,t){if(t<Fe)throw new Error("invalid exponent, negatives unsupported");if(t===Fe)return n.ONE;if(t===be)return e;let r=n.ONE,s=e;for(;t>Fe;)t&be&&(r=n.mul(r,s)),s=n.sqr(s),t>>=be;return r}function Ql(n,e,t=!1){const r=new Array(e.length).fill(t?n.ZERO:void 0),s=e.reduce((o,a,c)=>n.is0(a)?o:(r[c]=o,n.mul(o,a)),n.ONE),i=n.inv(s);return e.reduceRight((o,a,c)=>n.is0(a)?o:(r[c]=n.mul(o,r[c]),n.mul(o,a)),i),r}function Ta(n,e){const t=(n.ORDER-be)/Lt,r=n.pow(e,t),s=n.eql(r,n.ONE),i=n.eql(r,n.ZERO),o=n.eql(r,n.neg(n.ONE));if(!s&&!i&&!o)throw new Error("invalid Legendre symbol result");return s?1:i?0:-1}function Xp(n,e){e!==void 0&&os(e);const t=e!==void 0?e:n.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function Dn(n,e,t=!1,r={}){if(n<=Fe)throw new Error("invalid field: expected ORDER > 0, got "+n);let s,i;if(typeof e=="object"&&e!=null){if(r.sqrt||t)throw new Error("cannot specify opts in two arguments");const l=e;l.BITS&&(s=l.BITS),l.sqrt&&(i=l.sqrt),typeof l.isLE=="boolean"&&(t=l.isLE)}else typeof e=="number"&&(s=e),r.sqrt&&(i=r.sqrt);const{nBitLength:o,nByteLength:a}=Xp(n,s);if(a>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c;const u=Object.freeze({ORDER:n,isLE:t,BITS:o,BYTES:a,MASK:Ks(o),ZERO:Fe,ONE:be,create:l=>le(l,n),isValid:l=>{if(typeof l!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof l);return Fe<=l&&l<n},is0:l=>l===Fe,isValidNot0:l=>!u.is0(l)&&u.isValid(l),isOdd:l=>(l&be)===be,neg:l=>le(-l,n),eql:(l,d)=>l===d,sqr:l=>le(l*l,n),add:(l,d)=>le(l+d,n),sub:(l,d)=>le(l-d,n),mul:(l,d)=>le(l*d,n),pow:(l,d)=>Yp(u,l,d),div:(l,d)=>le(l*Ia(d,n),n),sqrN:l=>l*l,addN:(l,d)=>l+d,subN:(l,d)=>l-d,mulN:(l,d)=>l*d,inv:l=>Ia(l,n),sqrt:i||(l=>(c||(c=Vp(n)),c(u,l))),toBytes:l=>t?Er(l,a):No(l,a),fromBytes:l=>{if(l.length!==a)throw new Error("Field.fromBytes: expected "+a+" bytes, got "+l.length);return t?zt(l):qs(l)},invertBatch:l=>Ql(u,l),cmov:(l,d,h)=>h?d:l});return Object.freeze(u)}function Yl(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const e=n.toString(2).length;return Math.ceil(e/8)}function Xl(n){const e=Yl(n);return e+Math.ceil(e/2)}function Zp(n,e,t=!1){const r=n.length,s=Yl(e),i=Xl(e);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const o=t?zt(n):qs(n),a=le(o,e-be)+be;return t?Er(a,s):No(a,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const pn=BigInt(0),kt=BigInt(1);function Zn(n,e){const t=e.negate();return n?t:e}function Zl(n,e,t){const r=e==="pz"?o=>o.pz:o=>o.ez,s=Ql(n.Fp,t.map(r));return t.map((o,a)=>o.toAffine(s[a])).map(n.fromAffine)}function jl(n,e){if(!Number.isSafeInteger(n)||n<=0||n>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+n)}function ci(n,e){jl(n,e);const t=Math.ceil(e/n)+1,r=2**(n-1),s=2**n,i=Ks(n),o=BigInt(n);return{windows:t,windowSize:r,mask:i,maxNumber:s,shiftBy:o}}function Pa(n,e,t){const{windowSize:r,mask:s,maxNumber:i,shiftBy:o}=t;let a=Number(n&s),c=n>>o;a>r&&(a-=i,c+=kt);const u=e*r,l=u+Math.abs(a)-1,d=a===0,h=a<0,p=e%2!==0;return{nextN:c,offset:l,isZero:d,isNeg:h,isNegF:p,offsetF:u}}function jp(n,e){if(!Array.isArray(n))throw new Error("array expected");n.forEach((t,r)=>{if(!(t instanceof e))throw new Error("invalid point at index "+r)})}function Jp(n,e){if(!Array.isArray(n))throw new Error("array of scalars expected");n.forEach((t,r)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+r)})}const li=new WeakMap,Jl=new WeakMap;function ui(n){return Jl.get(n)||1}function Da(n){if(n!==pn)throw new Error("invalid wNAF")}function eu(n,e){return{constTimeNegate:Zn,hasPrecomputes(t){return ui(t)!==1},unsafeLadder(t,r,s=n.ZERO){let i=t;for(;r>pn;)r&kt&&(s=s.add(i)),i=i.double(),r>>=kt;return s},precomputeWindow(t,r){const{windows:s,windowSize:i}=ci(r,e),o=[];let a=t,c=a;for(let u=0;u<s;u++){c=a,o.push(c);for(let l=1;l<i;l++)c=c.add(a),o.push(c);a=c.double()}return o},wNAF(t,r,s){let i=n.ZERO,o=n.BASE;const a=ci(t,e);for(let c=0;c<a.windows;c++){const{nextN:u,offset:l,isZero:d,isNeg:h,isNegF:p,offsetF:g}=Pa(s,c,a);s=u,d?o=o.add(Zn(p,r[g])):i=i.add(Zn(h,r[l]))}return Da(s),{p:i,f:o}},wNAFUnsafe(t,r,s,i=n.ZERO){const o=ci(t,e);for(let a=0;a<o.windows&&s!==pn;a++){const{nextN:c,offset:u,isZero:l,isNeg:d}=Pa(s,a,o);if(s=c,!l){const h=r[u];i=i.add(d?h.negate():h)}}return Da(s),i},getPrecomputes(t,r,s){let i=li.get(r);return i||(i=this.precomputeWindow(r,t),t!==1&&(typeof s=="function"&&(i=s(i)),li.set(r,i))),i},wNAFCached(t,r,s){const i=ui(t);return this.wNAF(i,this.getPrecomputes(i,t,s),r)},wNAFCachedUnsafe(t,r,s,i){const o=ui(t);return o===1?this.unsafeLadder(t,r,i):this.wNAFUnsafe(o,this.getPrecomputes(o,t,s),r,i)},setWindowSize(t,r){jl(r,e),Jl.set(t,r),li.delete(t)}}}function eg(n,e,t,r){let s=e,i=n.ZERO,o=n.ZERO;for(;t>pn||r>pn;)t&kt&&(i=i.add(s)),r&kt&&(o=o.add(s)),s=s.double(),t>>=kt,r>>=kt;return{p1:i,p2:o}}function tu(n,e,t,r){jp(t,n),Jp(r,e);const s=t.length,i=r.length;if(s!==i)throw new Error("arrays of points and scalars must have equal length");const o=n.ZERO,a=$p(BigInt(s));let c=1;a>12?c=a-3:a>4?c=a-2:a>0&&(c=2);const u=Ks(c),l=new Array(Number(u)+1).fill(o),d=Math.floor((e.BITS-1)/c)*c;let h=o;for(let p=d;p>=0;p-=c){l.fill(o);for(let m=0;m<i;m++){const f=r[m],w=Number(f>>BigInt(p)&u);l[w]=l[w].add(t[m])}let g=o;for(let m=l.length-1,f=o;m>0;m--)f=f.add(l[m]),g=g.add(f);if(h=h.add(g),p!==0)for(let m=0;m<c;m++)h=h.double()}return h}function La(n,e){if(e){if(e.ORDER!==n)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return Qp(e),e}else return Dn(n)}function nu(n,e,t={}){if(!e||typeof e!="object")throw new Error(`expected valid ${n} CURVE object`);for(const a of["p","n","h"]){const c=e[a];if(!(typeof c=="bigint"&&c>pn))throw new Error(`CURVE.${a} must be positive bigint`)}const r=La(e.p,t.Fp),s=La(e.n,t.Fn),o=["Gx","Gy","a",n==="weierstrass"?"b":"d"];for(const a of o)if(!r.isValid(e[a]))throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);return{Fp:r,Fn:s}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Xe=BigInt(0),Pe=BigInt(1),di=BigInt(2),tg=BigInt(8),ng={zip215:!0};function rg(n,e,t,r){const s=n.sqr(t),i=n.sqr(r),o=n.add(n.mul(e.a,s),i),a=n.add(n.ONE,n.mul(e.d,n.mul(s,i)));return n.eql(o,a)}function sg(n,e={}){const{Fp:t,Fn:r}=nu("edwards",n,e),{h:s,n:i}=n;Pn(e,{},{uvRatio:"function"});const o=di<<BigInt(r.BYTES*8)-Pe,a=m=>t.create(m),c=e.uvRatio||((m,f)=>{try{return{isValid:!0,value:t.sqrt(t.div(m,f))}}catch{return{isValid:!1,value:Xe}}});if(!rg(t,n,n.Gx,n.Gy))throw new Error("bad curve params: generator point");function u(m,f,w=!1){const v=w?Pe:Xe;return St("coordinate "+m,f,v,o),f}function l(m){if(!(m instanceof p))throw new Error("ExtendedPoint expected")}const d=cs((m,f)=>{const{ex:w,ey:v,ez:x}=m,L=m.is0();f==null&&(f=L?tg:t.inv(x));const E=a(w*f),T=a(v*f),k=a(x*f);if(L)return{x:Xe,y:Pe};if(k!==Pe)throw new Error("invZ was invalid");return{x:E,y:T}}),h=cs(m=>{const{a:f,d:w}=n;if(m.is0())throw new Error("bad point: ZERO");const{ex:v,ey:x,ez:L,et:E}=m,T=a(v*v),k=a(x*x),D=a(L*L),y=a(D*D),S=a(T*f),b=a(D*a(S+k)),A=a(y+a(w*a(T*k)));if(b!==A)throw new Error("bad point: equation left != right (1)");const _=a(v*x),I=a(L*E);if(_!==I)throw new Error("bad point: equation left != right (2)");return!0});class p{constructor(f,w,v,x){this.ex=u("x",f),this.ey=u("y",w),this.ez=u("z",v,!0),this.et=u("t",x),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(f){if(f instanceof p)throw new Error("extended point not allowed");const{x:w,y:v}=f||{};return u("x",w),u("y",v),new p(w,v,Pe,a(w*v))}static normalizeZ(f){return Zl(p,"ez",f)}static msm(f,w){return tu(p,r,f,w)}_setWindowSize(f){this.precompute(f)}precompute(f=8,w=!0){return g.setWindowSize(this,f),w||this.multiply(di),this}assertValidity(){h(this)}equals(f){l(f);const{ex:w,ey:v,ez:x}=this,{ex:L,ey:E,ez:T}=f,k=a(w*T),D=a(L*x),y=a(v*T),S=a(E*x);return k===D&&y===S}is0(){return this.equals(p.ZERO)}negate(){return new p(a(-this.ex),this.ey,this.ez,a(-this.et))}double(){const{a:f}=n,{ex:w,ey:v,ez:x}=this,L=a(w*w),E=a(v*v),T=a(di*a(x*x)),k=a(f*L),D=w+v,y=a(a(D*D)-L-E),S=k+E,b=S-T,A=k-E,_=a(y*b),I=a(S*A),C=a(y*A),P=a(b*S);return new p(_,I,P,C)}add(f){l(f);const{a:w,d:v}=n,{ex:x,ey:L,ez:E,et:T}=this,{ex:k,ey:D,ez:y,et:S}=f,b=a(x*k),A=a(L*D),_=a(T*v*S),I=a(E*y),C=a((x+L)*(k+D)-b-A),P=I-_,R=I+_,N=a(A-w*b),M=a(C*P),F=a(R*N),O=a(C*N),B=a(P*R);return new p(M,F,B,O)}subtract(f){return this.add(f.negate())}multiply(f){const w=f;St("scalar",w,Pe,i);const{p:v,f:x}=g.wNAFCached(this,w,p.normalizeZ);return p.normalizeZ([v,x])[0]}multiplyUnsafe(f,w=p.ZERO){const v=f;return St("scalar",v,Xe,i),v===Xe?p.ZERO:this.is0()||v===Pe?this:g.wNAFCachedUnsafe(this,v,p.normalizeZ,w)}isSmallOrder(){return this.multiplyUnsafe(s).is0()}isTorsionFree(){return g.wNAFCachedUnsafe(this,i).is0()}toAffine(f){return d(this,f)}clearCofactor(){return s===Pe?this:this.multiplyUnsafe(s)}static fromBytes(f,w=!1){return rt(f),this.fromHex(f,w)}static fromHex(f,w=!1){const{d:v,a:x}=n,L=t.BYTES;f=ce("pointHex",f,L),$t("zip215",w);const E=f.slice(),T=f[L-1];E[L-1]=T&-129;const k=zt(E),D=w?o:t.ORDER;St("pointHex.y",k,Xe,D);const y=a(k*k),S=a(y-Pe),b=a(v*y-x);let{isValid:A,value:_}=c(S,b);if(!A)throw new Error("Point.fromHex: invalid y coordinate");const I=(_&Pe)===Pe,C=(T&128)!==0;if(!w&&_===Xe&&C)throw new Error("Point.fromHex: x=0 and x_0=1");return C!==I&&(_=a(-_)),p.fromAffine({x:_,y:k})}static fromPrivateScalar(f){return p.BASE.multiply(f)}toBytes(){const{x:f,y:w}=this.toAffine(),v=Er(w,t.BYTES);return v[v.length-1]|=f&Pe?128:0,v}toRawBytes(){return this.toBytes()}toHex(){return fn(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}p.BASE=new p(n.Gx,n.Gy,Pe,a(n.Gx*n.Gy)),p.ZERO=new p(Xe,Pe,Pe,Xe),p.Fp=t,p.Fn=r;const g=eu(p,r.BYTES*8);return p}function ig(n,e){Pn(e,{hash:"function"},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:t,hash:r}=e,{BASE:s,Fp:i,Fn:o}=n,a=o.ORDER,c=e.randomBytes||zs,u=e.adjustScalarBytes||(E=>E),l=e.domain||((E,T,k)=>{if($t("phflag",k),T.length||k)throw new Error("Contexts/pre-hash are not supported");return E});function d(E){return o.create(E)}function h(E){return d(zt(E))}function p(E){const T=i.BYTES;E=ce("private key",E,T);const k=ce("hashed private key",r(E),2*T),D=u(k.slice(0,T)),y=k.slice(T,2*T),S=h(D);return{head:D,prefix:y,scalar:S}}function g(E){const{head:T,prefix:k,scalar:D}=p(E),y=s.multiply(D),S=y.toBytes();return{head:T,prefix:k,scalar:D,point:y,pointBytes:S}}function m(E){return g(E).pointBytes}function f(E=Uint8Array.of(),...T){const k=ut(...T);return h(r(l(k,ce("context",E),!!t)))}function w(E,T,k={}){E=ce("message",E),t&&(E=t(E));const{prefix:D,scalar:y,pointBytes:S}=g(T),b=f(k.context,D,E),A=s.multiply(b).toBytes(),_=f(k.context,A,S,E),I=d(b+_*y);St("signature.s",I,Xe,a);const C=i.BYTES,P=ut(A,Er(I,C));return ce("result",P,C*2)}const v=ng;function x(E,T,k,D=v){const{context:y,zip215:S}=D,b=i.BYTES;E=ce("signature",E,2*b),T=ce("message",T),k=ce("publicKey",k,b),S!==void 0&&$t("zip215",S),t&&(T=t(T));const A=zt(E.slice(b,2*b));let _,I,C;try{_=n.fromHex(k,S),I=n.fromHex(E.slice(0,b),S),C=s.multiplyUnsafe(A)}catch{return!1}if(!S&&_.isSmallOrder())return!1;const P=f(y,I.toBytes(),_.toBytes(),T);return I.add(_.multiplyUnsafe(P)).subtract(C).clearCofactor().is0()}return s.precompute(8),{getPublicKey:m,sign:w,verify:x,utils:{getExtendedPublicKey:g,randomPrivateKey:()=>c(i.BYTES),precompute(E=8,T=n.BASE){return T.precompute(E,!1)}},Point:n}}function og(n){const e={a:n.a,d:n.d,p:n.Fp.ORDER,n:n.n,h:n.h,Gx:n.Gx,Gy:n.Gy},t=n.Fp,r=Dn(e.n,n.nBitLength,!0),s={Fp:t,Fn:r,uvRatio:n.uvRatio},i={hash:n.hash,randomBytes:n.randomBytes,adjustScalarBytes:n.adjustScalarBytes,domain:n.domain,prehash:n.prehash,mapToCurve:n.mapToCurve};return{CURVE:e,curveOpts:s,eddsaOpts:i}}function ag(n,e){return Object.assign({},e,{ExtendedPoint:e.Point,CURVE:n})}function cg(n){const{CURVE:e,curveOpts:t,eddsaOpts:r}=og(n),s=sg(e,t),i=ig(s,r);return ag(n,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Bn=BigInt(0),jt=BigInt(1),Mr=BigInt(2);function lg(n){return Pn(n,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...n})}function ug(n){const e=lg(n),{P:t,type:r,adjustScalarBytes:s,powPminus2:i,randomBytes:o}=e,a=r==="x25519";if(!a&&r!=="x448")throw new Error("invalid type");const c=o||zs,u=a?255:448,l=a?32:56,d=BigInt(a?9:5),h=BigInt(a?121665:39081),p=a?Mr**BigInt(254):Mr**BigInt(447),g=a?BigInt(8)*Mr**BigInt(251)-jt:BigInt(4)*Mr**BigInt(445)-jt,m=p+g+jt,f=y=>le(y,t),w=v(d);function v(y){return Er(f(y),l)}function x(y){const S=ce("u coordinate",y,l);return a&&(S[31]&=127),f(zt(S))}function L(y){return zt(s(ce("scalar",y,l)))}function E(y,S){const b=D(x(S),L(y));if(b===Bn)throw new Error("invalid private or public key received");return v(b)}function T(y){return E(y,w)}function k(y,S,b){const A=f(y*(S-b));return S=f(S-A),b=f(b+A),{x_2:S,x_3:b}}function D(y,S){St("u",y,Bn,t),St("scalar",S,p,m);const b=S,A=y;let _=jt,I=Bn,C=y,P=jt,R=Bn;for(let M=BigInt(u-1);M>=Bn;M--){const F=b>>M&jt;R^=F,{x_2:_,x_3:C}=k(R,_,C),{x_2:I,x_3:P}=k(R,I,P),R=F;const O=_+I,B=f(O*O),G=_-I,ne=f(G*G),W=B-ne,ie=C+P,Re=C-P,ve=f(Re*O),me=f(ie*G),Qt=ve+me,st=ve-me;C=f(Qt*Qt),P=f(A*f(st*st)),_=f(B*ne),I=f(W*(B+f(h*W)))}({x_2:_,x_3:C}=k(R,_,C)),{x_2:I,x_3:P}=k(R,I,P);const N=i(I);return f(_*N)}return{scalarMult:E,scalarMultBase:T,getSharedSecret:(y,S)=>E(y,S),getPublicKey:y=>T(y),utils:{randomPrivateKey:()=>c(l)},GuBytes:w.slice()}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */BigInt(0);const dg=BigInt(1),ka=BigInt(2),hg=BigInt(3),fg=BigInt(5),pg=BigInt(8),vr={p:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:pg,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function ru(n){const e=BigInt(10),t=BigInt(20),r=BigInt(40),s=BigInt(80),i=vr.p,a=n*n%i*n%i,c=ae(a,ka,i)*a%i,u=ae(c,dg,i)*n%i,l=ae(u,fg,i)*u%i,d=ae(l,e,i)*l%i,h=ae(d,t,i)*d%i,p=ae(h,r,i)*h%i,g=ae(p,s,i)*p%i,m=ae(g,s,i)*p%i,f=ae(m,e,i)*l%i;return{pow_p_5_8:ae(f,ka,i)*n%i,b2:a}}function su(n){return n[0]&=248,n[31]&=127,n[31]|=64,n}const Ra=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function gg(n,e){const t=vr.p,r=le(e*e*e,t),s=le(r*r*e,t),i=ru(n*s).pow_p_5_8;let o=le(n*r*i,t);const a=le(e*o*o,t),c=o,u=le(o*Ra,t),l=a===n,d=a===le(-n,t),h=a===le(-n*Ra,t);return l&&(o=c),(d||h)&&(o=u),Hp(o,t)&&(o=le(-o,t)),{isValid:l||d,value:o}}const mg=Dn(vr.p,void 0,!0),yg={...vr,Fp:mg,hash:Up,adjustScalarBytes:su,uvRatio:gg},ls=cg(yg),Nr=(()=>{const n=vr.p;return ug({P:n,type:"x25519",powPminus2:e=>{const{pow_p_5_8:t,b2:r}=ru(e);return le(ae(t,hg,n)*r,n)},adjustScalarBytes:su})})();class Ma extends Error{constructor(e="An error occurred while verifying a message"){super(e),this.name="VerificationError"}}class wg extends Error{constructor(e="Missing Web Crypto API"){super(e),this.name="WebCryptoMissingError"}}const qt={get(n=globalThis){const e=n.crypto;if(e?.subtle==null)throw new wg("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return e}},iu=32,Oo=64,Ji=32;let on;const ou=(async()=>{try{return await qt.get().subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),!0}catch{return!1}})();function bg(){const n=ls.utils.randomPrivateKey(),e=ls.getPublicKey(n);return{privateKey:Cg(n,e),publicKey:e}}async function Eg(n,e){let t;n.length===Oo?t=n.subarray(0,32):t=n;const r={crv:"Ed25519",kty:"OKP",x:q(n.subarray(32),"base64url"),d:q(t,"base64url"),ext:!0,key_ops:["sign"]},s=await qt.get().subtle.importKey("jwk",r,{name:"Ed25519"},!0,["sign"]),i=await qt.get().subtle.sign({name:"Ed25519"},s,e instanceof Uint8Array?e:e.subarray());return new Uint8Array(i,0,i.byteLength)}function vg(n,e){const t=n.subarray(0,Ji);return ls.sign(e instanceof Uint8Array?e:e.subarray(),t)}async function Sg(n,e){return on==null&&(on=await ou),on?Eg(n,e):vg(n,e)}async function xg(n,e,t){if(n.buffer instanceof ArrayBuffer){const r=await qt.get().subtle.importKey("raw",n.buffer,{name:"Ed25519"},!1,["verify"]);return await qt.get().subtle.verify({name:"Ed25519"},r,e,t instanceof Uint8Array?t:t.subarray())}throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys")}function Ag(n,e,t){return ls.verify(e,t instanceof Uint8Array?t:t.subarray(),n)}async function _g(n,e,t){return on==null&&(on=await ou),on?xg(n,e,t):Ag(n,e,t)}function Cg(n,e){const t=new Uint8Array(Oo);for(let r=0;r<Ji;r++)t[r]=n[r],t[Ji+r]=e[r];return t}function Fo(n){return n==null?!1:typeof n.then=="function"&&typeof n.catch=="function"&&typeof n.finally=="function"}class au{type="Ed25519";raw;constructor(e){this.raw=Uo(e,iu)}toMultihash(){return wr.digest(dt(this))}toCID(){return re.createV1(114,this.toMultihash())}toString(){return ge.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Te(this.raw,e.raw)}verify(e,t,r){r?.signal?.throwIfAborted();const s=_g(this.raw,t,e);return Fo(s)?s.then(i=>(r?.signal?.throwIfAborted(),i)):s}}class Ig{type="Ed25519";raw;publicKey;constructor(e,t){this.raw=Uo(e,Oo),this.publicKey=new au(t)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Te(this.raw,e.raw)}sign(e,t){t?.signal?.throwIfAborted();const r=Sg(this.raw,e);return Fo(r)?r.then(s=>(t?.signal?.throwIfAborted(),s)):(t?.signal?.throwIfAborted(),r)}}function cu(n){return n=Uo(n,iu),new au(n)}async function Tg(){const{privateKey:n,publicKey:e}=bg();return new Ig(n,e)}function Uo(n,e){if(n=Uint8Array.from(n??[]),n.length!==e)throw new z(`Key must be a Uint8Array of length ${e}, got ${n.length}`);return n}const Pg=Math.pow(2,7),Dg=Math.pow(2,14),Lg=Math.pow(2,21),Bo=Math.pow(2,28),$o=Math.pow(2,35),zo=Math.pow(2,42),qo=Math.pow(2,49),X=128,Ae=127;function Ie(n){if(n<Pg)return 1;if(n<Dg)return 2;if(n<Lg)return 3;if(n<Bo)return 4;if(n<$o)return 5;if(n<zo)return 6;if(n<qo)return 7;if(Number.MAX_SAFE_INTEGER!=null&&n>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function us(n,e,t=0){switch(Ie(n)){case 8:e[t++]=n&255|X,n/=128;case 7:e[t++]=n&255|X,n/=128;case 6:e[t++]=n&255|X,n/=128;case 5:e[t++]=n&255|X,n/=128;case 4:e[t++]=n&255|X,n>>>=7;case 3:e[t++]=n&255|X,n>>>=7;case 2:e[t++]=n&255|X,n>>>=7;case 1:{e[t++]=n&255,n>>>=7;break}default:throw new Error("unreachable")}return e}function kg(n,e,t=0){switch(Ie(n)){case 8:e.set(t++,n&255|X),n/=128;case 7:e.set(t++,n&255|X),n/=128;case 6:e.set(t++,n&255|X),n/=128;case 5:e.set(t++,n&255|X),n/=128;case 4:e.set(t++,n&255|X),n>>>=7;case 3:e.set(t++,n&255|X),n>>>=7;case 2:e.set(t++,n&255|X),n>>>=7;case 1:{e.set(t++,n&255),n>>>=7;break}default:throw new Error("unreachable")}return e}function lu(n,e){let t=n[e],r=0;if(r+=t&Ae,t<X||(t=n[e+1],r+=(t&Ae)<<7,t<X)||(t=n[e+2],r+=(t&Ae)<<14,t<X)||(t=n[e+3],r+=(t&Ae)<<21,t<X)||(t=n[e+4],r+=(t&Ae)*Bo,t<X)||(t=n[e+5],r+=(t&Ae)*$o,t<X)||(t=n[e+6],r+=(t&Ae)*zo,t<X)||(t=n[e+7],r+=(t&Ae)*qo,t<X))return r;throw new RangeError("Could not decode varint")}function Rg(n,e){let t=n.get(e),r=0;if(r+=t&Ae,t<X||(t=n.get(e+1),r+=(t&Ae)<<7,t<X)||(t=n.get(e+2),r+=(t&Ae)<<14,t<X)||(t=n.get(e+3),r+=(t&Ae)<<21,t<X)||(t=n.get(e+4),r+=(t&Ae)*Bo,t<X)||(t=n.get(e+5),r+=(t&Ae)*$o,t<X)||(t=n.get(e+6),r+=(t&Ae)*zo,t<X)||(t=n.get(e+7),r+=(t&Ae)*qo,t<X))return r;throw new RangeError("Could not decode varint")}function an(n,e,t=0){return e==null&&(e=nt(Ie(n))),e instanceof Uint8Array?us(n,e,t):kg(n,e,t)}function Ws(n,e=0){return n instanceof Uint8Array?lu(n,e):Rg(n,e)}const Ko=new Float32Array([-0]),xt=new Uint8Array(Ko.buffer);function Mg(n,e,t){Ko[0]=n,e[t]=xt[0],e[t+1]=xt[1],e[t+2]=xt[2],e[t+3]=xt[3]}function Ng(n,e){return xt[0]=n[e],xt[1]=n[e+1],xt[2]=n[e+2],xt[3]=n[e+3],Ko[0]}const Wo=new Float64Array([-0]),_e=new Uint8Array(Wo.buffer);function Og(n,e,t){Wo[0]=n,e[t]=_e[0],e[t+1]=_e[1],e[t+2]=_e[2],e[t+3]=_e[3],e[t+4]=_e[4],e[t+5]=_e[5],e[t+6]=_e[6],e[t+7]=_e[7]}function Fg(n,e){return _e[0]=n[e],_e[1]=n[e+1],_e[2]=n[e+2],_e[3]=n[e+3],_e[4]=n[e+4],_e[5]=n[e+5],_e[6]=n[e+6],_e[7]=n[e+7],Wo[0]}const Ug=BigInt(Number.MAX_SAFE_INTEGER),Bg=BigInt(Number.MIN_SAFE_INTEGER);class Ce{lo;hi;constructor(e,t){this.lo=e|0,this.hi=t|0}toNumber(e=!1){if(!e&&this.hi>>>31>0){const t=~this.lo+1>>>0;let r=~this.hi>>>0;return t===0&&(r=r+1>>>0),-(t+r*4294967296)}return this.lo+this.hi*4294967296}toBigInt(e=!1){if(e)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const t=~this.lo+1>>>0;let r=~this.hi>>>0;return t===0&&(r=r+1>>>0),-(BigInt(t)+(BigInt(r)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(e=!1){return this.toBigInt(e).toString()}zzEncode(){const e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this}zzDecode(){const e=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this}length(){const e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,r=this.hi>>>24;return r===0?t===0?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:r<128?9:10}static fromBigInt(e){if(e===0n)return Ot;if(e<Ug&&e>Bg)return this.fromNumber(Number(e));const t=e<0n;t&&(e=-e);let r=e>>32n,s=e-(r<<32n);return t&&(r=~r|0n,s=~s|0n,++s>Na&&(s=0n,++r>Na&&(r=0n))),new Ce(Number(s),Number(r))}static fromNumber(e){if(e===0)return Ot;const t=e<0;t&&(e=-e);let r=e>>>0,s=(e-r)/4294967296>>>0;return t&&(s=~s>>>0,r=~r>>>0,++r>4294967295&&(r=0,++s>4294967295&&(s=0))),new Ce(r,s)}static from(e){return typeof e=="number"?Ce.fromNumber(e):typeof e=="bigint"?Ce.fromBigInt(e):typeof e=="string"?Ce.fromBigInt(BigInt(e)):e.low!=null||e.high!=null?new Ce(e.low>>>0,e.high>>>0):Ot}}const Ot=new Ce(0,0);Ot.toBigInt=function(){return 0n};Ot.zzEncode=Ot.zzDecode=function(){return this};Ot.length=function(){return 1};const Na=4294967296n;function $g(n){let e=0,t=0;for(let r=0;r<n.length;++r)t=n.charCodeAt(r),t<128?e+=1:t<2048?e+=2:(t&64512)===55296&&(n.charCodeAt(r+1)&64512)===56320?(++r,e+=4):e+=3;return e}function zg(n,e,t){if(t-e<1)return"";let s;const i=[];let o=0,a;for(;e<t;)a=n[e++],a<128?i[o++]=a:a>191&&a<224?i[o++]=(a&31)<<6|n[e++]&63:a>239&&a<365?(a=((a&7)<<18|(n[e++]&63)<<12|(n[e++]&63)<<6|n[e++]&63)-65536,i[o++]=55296+(a>>10),i[o++]=56320+(a&1023)):i[o++]=(a&15)<<12|(n[e++]&63)<<6|n[e++]&63,o>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,i)),o=0);return s!=null?(o>0&&s.push(String.fromCharCode.apply(String,i.slice(0,o))),s.join("")):String.fromCharCode.apply(String,i.slice(0,o))}function uu(n,e,t){const r=t;let s,i;for(let o=0;o<n.length;++o)s=n.charCodeAt(o),s<128?e[t++]=s:s<2048?(e[t++]=s>>6|192,e[t++]=s&63|128):(s&64512)===55296&&((i=n.charCodeAt(o+1))&64512)===56320?(s=65536+((s&1023)<<10)+(i&1023),++o,e[t++]=s>>18|240,e[t++]=s>>12&63|128,e[t++]=s>>6&63|128,e[t++]=s&63|128):(e[t++]=s>>12|224,e[t++]=s>>6&63|128,e[t++]=s&63|128);return t-r}function Ke(n,e){return RangeError(`index out of range: ${n.pos} + ${e??1} > ${n.len}`)}function Or(n,e){return(n[e-4]|n[e-3]<<8|n[e-2]<<16|n[e-1]<<24)>>>0}class qg{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(e){this.buf=e,this.pos=0,this.len=e.length}uint32(){let e=4294967295;if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,Ke(this,10);return e}int32(){return this.uint32()|0}sint32(){const e=this.uint32();return e>>>1^-(e&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw Ke(this,4);return Or(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw Ke(this,4);return Or(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw Ke(this,4);const e=Ng(this.buf,this.pos);return this.pos+=4,e}double(){if(this.pos+8>this.len)throw Ke(this,4);const e=Fg(this.buf,this.pos);return this.pos+=8,e}bytes(){const e=this.uint32(),t=this.pos,r=this.pos+e;if(r>this.len)throw Ke(this,e);return this.pos+=e,t===r?new Uint8Array(0):this.buf.subarray(t,r)}string(){const e=this.bytes();return zg(e,0,e.length)}skip(e){if(typeof e=="number"){if(this.pos+e>this.len)throw Ke(this,e);this.pos+=e}else do if(this.pos>=this.len)throw Ke(this);while((this.buf[this.pos++]&128)!==0);return this}skipType(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(e=this.uint32()&7)!==4;)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${e} at offset ${this.pos}`)}return this}readLongVarint(){const e=new Ce(0,0);let t=0;if(this.len-this.pos>4){for(;t<4;++t)if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(this.buf[this.pos]&127)<<28)>>>0,e.hi=(e.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return e;t=0}else{for(;t<3;++t){if(this.pos>=this.len)throw Ke(this);if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(this.buf[this.pos++]&127)<<t*7)>>>0,e}if(this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw Ke(this);if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw Ke(this,8);const e=Or(this.buf,this.pos+=4),t=Or(this.buf,this.pos+=4);return new Ce(e,t)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const e=lu(this.buf,this.pos);return this.pos+=Ie(e),e}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function Kg(n){return new qg(n instanceof Uint8Array?n:n.subarray())}function de(n,e,t){const r=Kg(n);return e.decode(r,void 0,t)}function Wg(n){let r,s=8192;return function(o){if(o<1||o>4096)return nt(o);s+o>8192&&(r=nt(8192),s=0);const a=r.subarray(s,s+=o);return(s&7)!==0&&(s=(s|7)+1),a}}class Wn{fn;len;next;val;constructor(e,t,r){this.fn=e,this.len=t,this.next=void 0,this.val=r}}function hi(){}class Vg{head;tail;len;next;constructor(e){this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}}const Hg=Wg();function Gg(n){return globalThis.Buffer!=null?nt(n):Hg(n)}class eo{len;head;tail;states;constructor(){this.len=0,this.head=new Wn(hi,0,0),this.tail=this.head,this.states=null}_push(e,t,r){return this.tail=this.tail.next=new Wn(e,t,r),this.len+=t,this}uint32(e){return this.len+=(this.tail=this.tail.next=new Yg((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this}int32(e){return e<0?this._push(Fr,10,Ce.fromNumber(e)):this.uint32(e)}sint32(e){return this.uint32((e<<1^e>>31)>>>0)}uint64(e){const t=Ce.fromBigInt(e);return this._push(Fr,t.length(),t)}uint64Number(e){return this._push(us,Ie(e),e)}uint64String(e){return this.uint64(BigInt(e))}int64(e){return this.uint64(e)}int64Number(e){return this.uint64Number(e)}int64String(e){return this.uint64String(e)}sint64(e){const t=Ce.fromBigInt(e).zzEncode();return this._push(Fr,t.length(),t)}sint64Number(e){const t=Ce.fromNumber(e).zzEncode();return this._push(Fr,t.length(),t)}sint64String(e){return this.sint64(BigInt(e))}bool(e){return this._push(fi,1,e?1:0)}fixed32(e){return this._push($n,4,e>>>0)}sfixed32(e){return this.fixed32(e)}fixed64(e){const t=Ce.fromBigInt(e);return this._push($n,4,t.lo)._push($n,4,t.hi)}fixed64Number(e){const t=Ce.fromNumber(e);return this._push($n,4,t.lo)._push($n,4,t.hi)}fixed64String(e){return this.fixed64(BigInt(e))}sfixed64(e){return this.fixed64(e)}sfixed64Number(e){return this.fixed64Number(e)}sfixed64String(e){return this.fixed64String(e)}float(e){return this._push(Mg,4,e)}double(e){return this._push(Og,8,e)}bytes(e){const t=e.length>>>0;return t===0?this._push(fi,1,0):this.uint32(t)._push(Xg,t,e)}string(e){const t=$g(e);return t!==0?this.uint32(t)._push(uu,t,e):this._push(fi,1,0)}fork(){return this.states=new Vg(this),this.head=this.tail=new Wn(hi,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Wn(hi,0,0),this.len=0),this}ldelim(){const e=this.head,t=this.tail,r=this.len;return this.reset().uint32(r),r!==0&&(this.tail.next=e.next,this.tail=t,this.len+=r),this}finish(){let e=this.head.next;const t=Gg(this.len);let r=0;for(;e!=null;)e.fn(e.val,t,r),r+=e.len,e=e.next;return t}}function fi(n,e,t){e[t]=n&255}function Qg(n,e,t){for(;n>127;)e[t++]=n&127|128,n>>>=7;e[t]=n}class Yg extends Wn{next;constructor(e,t){super(Qg,e,t),this.next=void 0}}function Fr(n,e,t){for(;n.hi!==0;)e[t++]=n.lo&127|128,n.lo=(n.lo>>>7|n.hi<<25)>>>0,n.hi>>>=7;for(;n.lo>127;)e[t++]=n.lo&127|128,n.lo=n.lo>>>7;e[t++]=n.lo}function $n(n,e,t){e[t]=n&255,e[t+1]=n>>>8&255,e[t+2]=n>>>16&255,e[t+3]=n>>>24}function Xg(n,e,t){e.set(n,t)}globalThis.Buffer!=null&&(eo.prototype.bytes=function(n){const e=n.length>>>0;return this.uint32(e),e>0&&this._push(Zg,e,n),this},eo.prototype.string=function(n){const e=globalThis.Buffer.byteLength(n);return this.uint32(e),e>0&&this._push(jg,e,n),this});function Zg(n,e,t){e.set(n,t)}function jg(n,e,t){n.length<40?uu(n,e,t):e.utf8Write!=null?e.utf8Write(n,t):e.set($(n),t)}function Jg(){return new eo}function he(n,e){const t=Jg();return e.encode(n,t,{lengthDelimited:!1}),t.finish()}var ds;(function(n){n[n.VARINT=0]="VARINT",n[n.BIT64=1]="BIT64",n[n.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",n[n.START_GROUP=3]="START_GROUP",n[n.END_GROUP=4]="END_GROUP",n[n.BIT32=5]="BIT32"})(ds||(ds={}));function du(n,e,t,r){return{name:n,type:e,encode:t,decode:r}}function Ln(n){function e(s){if(n[s.toString()]==null)throw new Error("Invalid enum value");return n[s]}const t=function(i,o){const a=e(i);o.int32(a)},r=function(i){const o=i.int32();return e(o)};return du("enum",ds.VARINT,t,r)}function fe(n,e){return du("message",ds.LENGTH_DELIMITED,n,e)}class pt extends Error{code="ERR_MAX_LENGTH";name="MaxLengthError"}class Oa extends Error{code="ERR_MAX_SIZE";name="MaxSizeError"}var we;(function(n){n.RSA="RSA",n.Ed25519="Ed25519",n.secp256k1="secp256k1",n.ECDSA="ECDSA"})(we||(we={}));var to;(function(n){n[n.RSA=0]="RSA",n[n.Ed25519=1]="Ed25519",n[n.secp256k1=2]="secp256k1",n[n.ECDSA=3]="ECDSA"})(to||(to={}));(function(n){n.codec=()=>Ln(to)})(we||(we={}));var gn;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.Type!=null&&(r.uint32(8),we.codec().encode(t.Type,r)),t.Data!=null&&(r.uint32(18),r.bytes(t.Data)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.Type=we.codec().decode(t);break}case 2:{i.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(gn||(gn={}));var Fa;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.Type!=null&&(r.uint32(8),we.codec().encode(t.Type,r)),t.Data!=null&&(r.uint32(18),r.bytes(t.Data)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.Type=we.codec().decode(t);break}case 2:{i.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(Fa||(Fa={}));function Vo(n){if(isNaN(n)||n<=0)throw new z("random bytes length must be a Number bigger than 0");return zs(n)}const jr=ql;class em{type="RSA";jwk;_raw;_multihash;constructor(e,t){this.jwk=e,this._multihash=t}get raw(){return this._raw==null&&(this._raw=im(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return re.createV1(114,this._multihash)}toString(){return ge.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Te(this.raw,e.raw)}verify(e,t,r){return cm(this.jwk,t,e,r)}}const tm=18,nm=1062,rm=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function sm(n){const e=$s(n[1],{offset:0});return{kty:"RSA",n:q(e[0],"base64url"),e:q(e[1],"base64url")}}function im(n){if(n.n==null||n.e==null)throw new z("JWK was missing components");return Xn([rm,Nl(Xn([Zi($(n.n,"base64url")),Zi($(n.e,"base64url"))]))]).subarray()}function om(n,e){if(n.byteLength>=nm)throw new ml("Key size is too large");const t=$s(n,{offset:0});return am(t,n,e)}function am(n,e,t){const r=sm(n);if(t==null){const s=jr(gn.encode({Type:we.RSA,Data:e}));t=sr(tm,s)}return new em(r,t)}async function cm(n,e,t,r){const s=await qt.get().subtle.importKey("jwk",n,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);r?.signal?.throwIfAborted();const i=await qt.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},s,e,t instanceof Uint8Array?t:t.subarray());return r?.signal?.throwIfAborted(),i}class hu extends Ul{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,ko(e);const r=ir(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(r.length>s?e.create().update(r).digest():r);for(let o=0;o<i.length;o++)i[o]^=54;this.iHash.update(i),this.oHash=e.create();for(let o=0;o<i.length;o++)i[o]^=106;this.oHash.update(i),Bt(i)}update(e){return as(this),this.iHash.update(e),this}digestInto(e){as(this),rt(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:s,destroyed:i,blockLen:o,outputLen:a}=this;return e=e,e.finished=s,e.destroyed=i,e.blockLen=o,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Vs=(n,e,t)=>new hu(n,e).update(t).digest();Vs.create=(n,e)=>new hu(n,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ua(n){n.lowS!==void 0&&$t("lowS",n.lowS),n.prehash!==void 0&&$t("prehash",n.prehash)}class lm extends Error{constructor(e=""){super(e)}}const lt={Err:lm,_tlv:{encode:(n,e)=>{const{Err:t}=lt;if(n<0||n>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const r=e.length/2,s=Rr(r);if(s.length/2&128)throw new t("tlv.encode: long form length too big");const i=r>127?Rr(s.length/2|128):"";return Rr(n)+i+s+e},decode(n,e){const{Err:t}=lt;let r=0;if(n<0||n>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[r++]!==n)throw new t("tlv.decode: wrong tlv");const s=e[r++],i=!!(s&128);let o=0;if(!i)o=s;else{const c=s&127;if(!c)throw new t("tlv.decode(long): indefinite length not supported");if(c>4)throw new t("tlv.decode(long): byte length is too big");const u=e.subarray(r,r+c);if(u.length!==c)throw new t("tlv.decode: length bytes not complete");if(u[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const l of u)o=o<<8|l;if(r+=c,o<128)throw new t("tlv.decode(long): not minimal encoding")}const a=e.subarray(r,r+o);if(a.length!==o)throw new t("tlv.decode: wrong value length");return{v:a,l:e.subarray(r+o)}}},_int:{encode(n){const{Err:e}=lt;if(n<jn)throw new e("integer: negative integers are not allowed");let t=Rr(n);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(n){const{Err:e}=lt;if(n[0]&128)throw new e("invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return qs(n)}},toSig(n){const{Err:e,_int:t,_tlv:r}=lt,s=ce("signature",n),{v:i,l:o}=r.decode(48,s);if(o.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=r.decode(2,i),{v:u,l}=r.decode(2,c);if(l.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(u)}},hexFromSig(n){const{_tlv:e,_int:t}=lt,r=e.encode(2,t.encode(n.r)),s=e.encode(2,t.encode(n.s)),i=r+s;return e.encode(48,i)}},jn=BigInt(0),Jn=BigInt(1),um=BigInt(2),Ur=BigInt(3),dm=BigInt(4);function hm(n,e,t){function r(s){const i=n.sqr(s),o=n.mul(i,s);return n.add(n.add(o,n.mul(s,e)),t)}return r}function fu(n,e,t){const{BYTES:r}=n;function s(i){let o;if(typeof i=="bigint")o=i;else{let a=ce("private key",i);if(e){if(!e.includes(a.length*2))throw new Error("invalid private key");const c=new Uint8Array(r);c.set(a,c.length-a.length),a=c}try{o=n.fromBytes(a)}catch{throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof i}`)}}if(t&&(o=n.create(o)),!n.isValidNot0(o))throw new Error("invalid private key: out of range [1..N-1]");return o}return s}function fm(n,e={}){const{Fp:t,Fn:r}=nu("weierstrass",n,e),{h:s,n:i}=n;Pn(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:o}=e;if(o&&(!t.is0(n.a)||typeof o.beta!="bigint"||typeof o.splitScalar!="function"))throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');function a(){if(!t.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function c(D,y,S){const{x:b,y:A}=y.toAffine(),_=t.toBytes(b);if($t("isCompressed",S),S){a();const I=!t.isOdd(A);return ut(pu(I),_)}else return ut(Uint8Array.of(4),_,t.toBytes(A))}function u(D){rt(D);const y=t.BYTES,S=y+1,b=2*y+1,A=D.length,_=D[0],I=D.subarray(1);if(A===S&&(_===2||_===3)){const C=t.fromBytes(I);if(!t.isValid(C))throw new Error("bad point: is not on curve, wrong x");const P=h(C);let R;try{R=t.sqrt(P)}catch(F){const O=F instanceof Error?": "+F.message:"";throw new Error("bad point: is not on curve, sqrt error"+O)}a();const N=t.isOdd(R);return(_&1)===1!==N&&(R=t.neg(R)),{x:C,y:R}}else if(A===b&&_===4){const C=t.fromBytes(I.subarray(y*0,y*1)),P=t.fromBytes(I.subarray(y*1,y*2));if(!p(C,P))throw new Error("bad point: is not on curve");return{x:C,y:P}}else throw new Error(`bad point: got length ${A}, expected compressed=${S} or uncompressed=${b}`)}const l=e.toBytes||c,d=e.fromBytes||u,h=hm(t,n.a,n.b);function p(D,y){const S=t.sqr(y),b=h(D);return t.eql(S,b)}if(!p(n.Gx,n.Gy))throw new Error("bad curve params: generator point");const g=t.mul(t.pow(n.a,Ur),dm),m=t.mul(t.sqr(n.b),BigInt(27));if(t.is0(t.add(g,m)))throw new Error("bad curve params: a or b");function f(D,y,S=!1){if(!t.isValid(y)||S&&t.is0(y))throw new Error(`bad point coordinate ${D}`);return y}function w(D){if(!(D instanceof E))throw new Error("ProjectivePoint expected")}const v=cs((D,y)=>{const{px:S,py:b,pz:A}=D;if(t.eql(A,t.ONE))return{x:S,y:b};const _=D.is0();y==null&&(y=_?t.ONE:t.inv(A));const I=t.mul(S,y),C=t.mul(b,y),P=t.mul(A,y);if(_)return{x:t.ZERO,y:t.ZERO};if(!t.eql(P,t.ONE))throw new Error("invZ was invalid");return{x:I,y:C}}),x=cs(D=>{if(D.is0()){if(e.allowInfinityPoint&&!t.is0(D.py))return;throw new Error("bad point: ZERO")}const{x:y,y:S}=D.toAffine();if(!t.isValid(y)||!t.isValid(S))throw new Error("bad point: x or y not field elements");if(!p(y,S))throw new Error("bad point: equation left != right");if(!D.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function L(D,y,S,b,A){return S=new E(t.mul(S.px,D),S.py,S.pz),y=Zn(b,y),S=Zn(A,S),y.add(S)}class E{constructor(y,S,b){this.px=f("x",y),this.py=f("y",S,!0),this.pz=f("z",b),Object.freeze(this)}static fromAffine(y){const{x:S,y:b}=y||{};if(!y||!t.isValid(S)||!t.isValid(b))throw new Error("invalid affine point");if(y instanceof E)throw new Error("projective point not allowed");return t.is0(S)&&t.is0(b)?E.ZERO:new E(S,b,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(y){return Zl(E,"pz",y)}static fromBytes(y){return rt(y),E.fromHex(y)}static fromHex(y){const S=E.fromAffine(d(ce("pointHex",y)));return S.assertValidity(),S}static fromPrivateKey(y){const S=fu(r,e.allowedPrivateKeyLengths,e.wrapPrivateKey);return E.BASE.multiply(S(y))}static msm(y,S){return tu(E,r,y,S)}precompute(y=8,S=!0){return k.setWindowSize(this,y),S||this.multiply(Ur),this}_setWindowSize(y){this.precompute(y)}assertValidity(){x(this)}hasEvenY(){const{y}=this.toAffine();if(!t.isOdd)throw new Error("Field doesn't support isOdd");return!t.isOdd(y)}equals(y){w(y);const{px:S,py:b,pz:A}=this,{px:_,py:I,pz:C}=y,P=t.eql(t.mul(S,C),t.mul(_,A)),R=t.eql(t.mul(b,C),t.mul(I,A));return P&&R}negate(){return new E(this.px,t.neg(this.py),this.pz)}double(){const{a:y,b:S}=n,b=t.mul(S,Ur),{px:A,py:_,pz:I}=this;let C=t.ZERO,P=t.ZERO,R=t.ZERO,N=t.mul(A,A),M=t.mul(_,_),F=t.mul(I,I),O=t.mul(A,_);return O=t.add(O,O),R=t.mul(A,I),R=t.add(R,R),C=t.mul(y,R),P=t.mul(b,F),P=t.add(C,P),C=t.sub(M,P),P=t.add(M,P),P=t.mul(C,P),C=t.mul(O,C),R=t.mul(b,R),F=t.mul(y,F),O=t.sub(N,F),O=t.mul(y,O),O=t.add(O,R),R=t.add(N,N),N=t.add(R,N),N=t.add(N,F),N=t.mul(N,O),P=t.add(P,N),F=t.mul(_,I),F=t.add(F,F),N=t.mul(F,O),C=t.sub(C,N),R=t.mul(F,M),R=t.add(R,R),R=t.add(R,R),new E(C,P,R)}add(y){w(y);const{px:S,py:b,pz:A}=this,{px:_,py:I,pz:C}=y;let P=t.ZERO,R=t.ZERO,N=t.ZERO;const M=n.a,F=t.mul(n.b,Ur);let O=t.mul(S,_),B=t.mul(b,I),G=t.mul(A,C),ne=t.add(S,b),W=t.add(_,I);ne=t.mul(ne,W),W=t.add(O,B),ne=t.sub(ne,W),W=t.add(S,A);let ie=t.add(_,C);return W=t.mul(W,ie),ie=t.add(O,G),W=t.sub(W,ie),ie=t.add(b,A),P=t.add(I,C),ie=t.mul(ie,P),P=t.add(B,G),ie=t.sub(ie,P),N=t.mul(M,W),P=t.mul(F,G),N=t.add(P,N),P=t.sub(B,N),N=t.add(B,N),R=t.mul(P,N),B=t.add(O,O),B=t.add(B,O),G=t.mul(M,G),W=t.mul(F,W),B=t.add(B,G),G=t.sub(O,G),G=t.mul(M,G),W=t.add(W,G),O=t.mul(B,W),R=t.add(R,O),O=t.mul(ie,W),P=t.mul(ne,P),P=t.sub(P,O),O=t.mul(ne,B),N=t.mul(ie,N),N=t.add(N,O),new E(P,R,N)}subtract(y){return this.add(y.negate())}is0(){return this.equals(E.ZERO)}multiply(y){const{endo:S}=e;if(!r.isValidNot0(y))throw new Error("invalid scalar: out of range");let b,A;const _=I=>k.wNAFCached(this,I,E.normalizeZ);if(S){const{k1neg:I,k1:C,k2neg:P,k2:R}=S.splitScalar(y),{p:N,f:M}=_(C),{p:F,f:O}=_(R);A=M.add(O),b=L(S.beta,N,F,I,P)}else{const{p:I,f:C}=_(y);b=I,A=C}return E.normalizeZ([b,A])[0]}multiplyUnsafe(y){const{endo:S}=e,b=this;if(!r.isValid(y))throw new Error("invalid scalar: out of range");if(y===jn||b.is0())return E.ZERO;if(y===Jn)return b;if(k.hasPrecomputes(this))return this.multiply(y);if(S){const{k1neg:A,k1:_,k2neg:I,k2:C}=S.splitScalar(y),{p1:P,p2:R}=eg(E,b,_,C);return L(S.beta,P,R,A,I)}else return k.wNAFCachedUnsafe(b,y)}multiplyAndAddUnsafe(y,S,b){const A=this.multiplyUnsafe(S).add(y.multiplyUnsafe(b));return A.is0()?void 0:A}toAffine(y){return v(this,y)}isTorsionFree(){const{isTorsionFree:y}=e;return s===Jn?!0:y?y(E,this):k.wNAFCachedUnsafe(this,i).is0()}clearCofactor(){const{clearCofactor:y}=e;return s===Jn?this:y?y(E,this):this.multiplyUnsafe(s)}toBytes(y=!0){return $t("isCompressed",y),this.assertValidity(),l(E,this,y)}toRawBytes(y=!0){return this.toBytes(y)}toHex(y=!0){return fn(this.toBytes(y))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}E.BASE=new E(n.Gx,n.Gy,t.ONE),E.ZERO=new E(t.ZERO,t.ONE,t.ZERO),E.Fp=t,E.Fn=r;const T=r.BITS,k=eu(E,e.endo?Math.ceil(T/2):T);return E}function pu(n){return Uint8Array.of(n?2:3)}function pm(n,e,t={}){Pn(e,{hash:"function"},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const r=e.randomBytes||zs,s=e.hmac||((b,...A)=>Vs(e.hash,b,ut(...A))),{Fp:i,Fn:o}=n,{ORDER:a,BITS:c}=o;function u(b){const A=a>>Jn;return b>A}function l(b){return u(b)?o.neg(b):b}function d(b,A){if(!o.isValidNot0(A))throw new Error(`invalid signature ${b}: out of range 1..CURVE.n`)}class h{constructor(A,_,I){d("r",A),d("s",_),this.r=A,this.s=_,I!=null&&(this.recovery=I),Object.freeze(this)}static fromCompact(A){const _=o.BYTES,I=ce("compactSignature",A,_*2);return new h(o.fromBytes(I.subarray(0,_)),o.fromBytes(I.subarray(_,_*2)))}static fromDER(A){const{r:_,s:I}=lt.toSig(ce("DER",A));return new h(_,I)}assertValidity(){}addRecoveryBit(A){return new h(this.r,this.s,A)}recoverPublicKey(A){const _=i.ORDER,{r:I,s:C,recovery:P}=this;if(P==null||![0,1,2,3].includes(P))throw new Error("recovery id invalid");if(a*um<_&&P>1)throw new Error("recovery id is ambiguous for h>1 curve");const N=P===2||P===3?I+a:I;if(!i.isValid(N))throw new Error("recovery id 2 or 3 invalid");const M=i.toBytes(N),F=n.fromHex(ut(pu((P&1)===0),M)),O=o.inv(N),B=x(ce("msgHash",A)),G=o.create(-B*O),ne=o.create(C*O),W=n.BASE.multiplyUnsafe(G).add(F.multiplyUnsafe(ne));if(W.is0())throw new Error("point at infinify");return W.assertValidity(),W}hasHighS(){return u(this.s)}normalizeS(){return this.hasHighS()?new h(this.r,o.neg(this.s),this.recovery):this}toBytes(A){if(A==="compact")return ut(o.toBytes(this.r),o.toBytes(this.s));if(A==="der")return Ro(lt.hexFromSig(this));throw new Error("invalid format")}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return fn(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return fn(this.toBytes("compact"))}}const p=fu(o,t.allowedPrivateKeyLengths,t.wrapPrivateKey),g={isValidPrivateKey(b){try{return p(b),!0}catch{return!1}},normPrivateKeyToScalar:p,randomPrivateKey:()=>{const b=a;return Zp(r(Xl(b)),b)},precompute(b=8,A=n.BASE){return A.precompute(b,!1)}};function m(b,A=!0){return n.fromPrivateKey(b).toBytes(A)}function f(b){if(typeof b=="bigint")return!1;if(b instanceof n)return!0;const _=ce("key",b).length,I=i.BYTES,C=I+1,P=2*I+1;if(!(t.allowedPrivateKeyLengths||o.BYTES===C))return _===C||_===P}function w(b,A,_=!0){if(f(b)===!0)throw new Error("first arg must be private key");if(f(A)===!1)throw new Error("second arg must be public key");return n.fromHex(A).multiply(p(b)).toBytes(_)}const v=e.bits2int||function(b){if(b.length>8192)throw new Error("input is too large");const A=qs(b),_=b.length*8-c;return _>0?A>>BigInt(_):A},x=e.bits2int_modN||function(b){return o.create(v(b))},L=Ks(c);function E(b){return St("num < 2^"+c,b,jn,L),o.toBytes(b)}function T(b,A,_=k){if(["recovered","canonical"].some(ne=>ne in _))throw new Error("sign() legacy options not supported");const{hash:I}=e;let{lowS:C,prehash:P,extraEntropy:R}=_;C==null&&(C=!0),b=ce("msgHash",b),Ua(_),P&&(b=ce("prehashed msgHash",I(b)));const N=x(b),M=p(A),F=[E(M),E(N)];if(R!=null&&R!==!1){const ne=R===!0?r(i.BYTES):R;F.push(ce("extraEntropy",ne))}const O=ut(...F),B=N;function G(ne){const W=v(ne);if(!o.isValidNot0(W))return;const ie=o.inv(W),Re=n.BASE.multiply(W).toAffine(),ve=o.create(Re.x);if(ve===jn)return;const me=o.create(ie*o.create(B+ve*M));if(me===jn)return;let Qt=(Re.x===ve?0:2)|Number(Re.y&Jn),st=me;return C&&u(me)&&(st=l(me),Qt^=1),new h(ve,st,Qt)}return{seed:O,k2sig:G}}const k={lowS:e.lowS,prehash:!1},D={lowS:e.lowS,prehash:!1};function y(b,A,_=k){const{seed:I,k2sig:C}=T(b,A,_);return zp(e.hash.outputLen,o.BYTES,s)(I,C)}n.BASE.precompute(8);function S(b,A,_,I=D){const C=b;A=ce("msgHash",A),_=ce("publicKey",_),Ua(I);const{lowS:P,prehash:R,format:N}=I;if("strict"in I)throw new Error("options.strict was renamed to lowS");if(N!==void 0&&!["compact","der","js"].includes(N))throw new Error('format must be "compact", "der" or "js"');const M=typeof C=="string"||Lo(C),F=!M&&!N&&typeof C=="object"&&C!==null&&typeof C.r=="bigint"&&typeof C.s=="bigint";if(!M&&!F)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let O,B;try{if(F)if(N===void 0||N==="js")O=new h(C.r,C.s);else throw new Error("invalid format");if(M){try{N!=="compact"&&(O=h.fromDER(C))}catch(st){if(!(st instanceof lt.Err))throw st}!O&&N!=="der"&&(O=h.fromCompact(C))}B=n.fromHex(_)}catch{return!1}if(!O||P&&O.hasHighS())return!1;R&&(A=e.hash(A));const{r:G,s:ne}=O,W=x(A),ie=o.inv(ne),Re=o.create(W*ie),ve=o.create(G*ie),me=n.BASE.multiplyUnsafe(Re).add(B.multiplyUnsafe(ve));return me.is0()?!1:o.create(me.x)===G}return Object.freeze({getPublicKey:m,getSharedSecret:w,sign:y,verify:S,utils:g,Point:n,Signature:h})}function gm(n){const e={a:n.a,b:n.b,p:n.Fp.ORDER,n:n.n,h:n.h,Gx:n.Gx,Gy:n.Gy},t=n.Fp,r=Dn(e.n,n.nBitLength),s={Fp:t,Fn:r,allowedPrivateKeyLengths:n.allowedPrivateKeyLengths,allowInfinityPoint:n.allowInfinityPoint,endo:n.endo,wrapPrivateKey:n.wrapPrivateKey,isTorsionFree:n.isTorsionFree,clearCofactor:n.clearCofactor,fromBytes:n.fromBytes,toBytes:n.toBytes};return{CURVE:e,curveOpts:s}}function mm(n){const{CURVE:e,curveOpts:t}=gm(n),r={hash:n.hash,hmac:n.hmac,randomBytes:n.randomBytes,lowS:n.lowS,bits2int:n.bits2int,bits2int_modN:n.bits2int_modN};return{CURVE:e,curveOpts:t,ecdsaOpts:r}}function ym(n,e){return Object.assign({},e,{ProjectivePoint:e.Point,CURVE:n})}function wm(n){const{CURVE:e,curveOpts:t,ecdsaOpts:r}=mm(n),s=fm(e,t),i=pm(s,r,t);return ym(n,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function bm(n,e){const t=r=>wm({...n,hash:r});return{...t(e),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const hs={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")};BigInt(0);const Em=BigInt(1),no=BigInt(2),Ba=(n,e)=>(n+e/no)/e;function vm(n){const e=hs.p,t=BigInt(3),r=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),u=n*n*n%e,l=u*u*n%e,d=ae(l,t,e)*l%e,h=ae(d,t,e)*l%e,p=ae(h,no,e)*u%e,g=ae(p,s,e)*p%e,m=ae(g,i,e)*g%e,f=ae(m,a,e)*m%e,w=ae(f,c,e)*f%e,v=ae(w,a,e)*m%e,x=ae(v,t,e)*l%e,L=ae(x,o,e)*g%e,E=ae(L,r,e)*u%e,T=ae(E,no,e);if(!ro.eql(ro.sqr(T),n))throw new Error("Cannot find square root");return T}const ro=Dn(hs.p,void 0,void 0,{sqrt:vm}),fs=bm({...hs,Fp:ro,lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:n=>{const e=hs.n,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Em*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=t,o=BigInt("0x100000000000000000000000000000000"),a=Ba(i*n,e),c=Ba(-r*n,e);let u=le(n-a*t-c*s,e),l=le(-a*r-c*i,e);const d=u>o,h=l>o;if(d&&(u=e-u),h&&(l=e-l),u>o||l>o)throw new Error("splitScalar: Endomorphism failed, k="+n);return{k1neg:d,k1:u,k2neg:h,k2:l}}}},ql);function Sm(n,e,t,r){const s=kl.digest(t instanceof Uint8Array?t:t.subarray());if(Fo(s))return s.then(({digest:i})=>(r?.signal?.throwIfAborted(),fs.verify(e,i,n))).catch(i=>{throw i.name==="AbortError"?i:new Ma(String(i))});try{return r?.signal?.throwIfAborted(),fs.verify(e,s.digest,n)}catch(i){throw new Ma(String(i))}}class xm{type="secp256k1";raw;_key;constructor(e){this._key=_m(e),this.raw=Am(this._key)}toMultihash(){return wr.digest(dt(this))}toCID(){return re.createV1(114,this.toMultihash())}toString(){return ge.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Te(this.raw,e.raw)}verify(e,t,r){return Sm(this._key,t,e,r)}}function gu(n){return new xm(n)}function Am(n){return fs.ProjectivePoint.fromHex(n).toRawBytes(!0)}function _m(n){try{return fs.ProjectivePoint.fromHex(n),n}catch(e){throw new ml(String(e))}}async function Cm(n,e){return Tg()}function It(n,e){const{Type:t,Data:r}=gn.decode(n),s=r??new Uint8Array;switch(t){case we.RSA:return om(s,e);case we.Ed25519:return cu(s);case we.secp256k1:return gu(s);case we.ECDSA:return Ol(s);default:throw new Io}}function Im(n){const{Type:e,Data:t}=gn.decode(n.digest),r=t??new Uint8Array;switch(e){case we.Ed25519:return cu(r);case we.secp256k1:return gu(r);case we.ECDSA:return Ol(r);default:throw new Io}}function dt(n){return gn.encode({Type:we[n.type],Data:n.raw})}const mu=Symbol.for("nodejs.util.inspect.custom"),Tm=114;class Ho{type;multihash;publicKey;string;constructor(e){this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}[vo]=!0;toString(){return this.string==null&&(this.string=ge.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return re.createV1(Tm,this.multihash)}toJSON(){return this.toString()}equals(e){if(e==null)return!1;if(e instanceof Uint8Array)return Te(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(e?.toMultihash()?.bytes!=null)return Te(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[mu](){return`PeerId(${this.toString()})`}}class yu extends Ho{type="RSA";publicKey;constructor(e){super({...e,type:"RSA"}),this.publicKey=e.publicKey}}class wu extends Ho{type="Ed25519";publicKey;constructor(e){super({...e,type:"Ed25519"}),this.publicKey=e.publicKey}}class bu extends Ho{type="secp256k1";publicKey;constructor(e){super({...e,type:"secp256k1"}),this.publicKey=e.publicKey}}const Pm=2336;class Eu{type="url";multihash;publicKey;url;constructor(e){this.url=e.toString(),this.multihash=wr.digest($(this.url))}[mu](){return`PeerId(${this.url})`}[vo]=!0;toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return re.createV1(Pm,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=q(e)),e.toString()===this.toString())}}const Dm=114,$a=2336;function gt(n,e){let t;if(n.charAt(0)==="1"||n.charAt(0)==="Q")t=yr(ge.decode(`z${n}`));else{if(n.startsWith("k51qzi5uqu5")||n.startsWith("kzwfwjn5ji4")||n.startsWith("k2k4r8")||n.startsWith("bafz"))return xr(re.parse(n));throw new z('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return Sr(t)}function or(n){if(n.type==="Ed25519")return new wu({multihash:n.toCID().multihash,publicKey:n});if(n.type==="secp256k1")return new bu({multihash:n.toCID().multihash,publicKey:n});if(n.type==="RSA")return new yu({multihash:n.toCID().multihash,publicKey:n});throw new Io}function Lm(n){return or(n.publicKey)}function Sr(n){if(Rm(n))return new yu({multihash:n});if(km(n))try{const e=Im(n);if(e.type==="Ed25519")return new wu({multihash:n,publicKey:e});if(e.type==="secp256k1")return new bu({multihash:n,publicKey:e})}catch{const t=q(n.digest);return new Eu(new URL(t))}throw new kh("Supplied PeerID Multihash is invalid")}function xr(n){if(n?.multihash==null||n.version==null||n.version===1&&n.code!==Dm&&n.code!==$a)throw new Lh("Supplied PeerID CID is invalid");if(n.code===$a){const e=q(n.multihash.digest);return new Eu(new URL(e))}return Sr(n.multihash)}function km(n){return n.code===wr.code}function Rm(n){return n.code===kl.code}const Mm=8,Go=1024*1024*4;let Nm=class extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"},vu=class extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"},Om=class extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"},za=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};function Su(n){return n[Symbol.asyncIterator]!=null}function xu(n,e){if(n.byteLength>e)throw new vu("Message length too long")}const Hs=n=>{const e=Ie(n),t=nt(e);return an(n,t),Hs.bytes=e,t};Hs.bytes=0;function ps(n,e){e=e??{};const t=e.lengthEncoder??Hs,r=e?.maxDataLength??Go;function*s(i){xu(i,r);const o=t(i.byteLength);o instanceof Uint8Array?yield o:yield*o,i instanceof Uint8Array?yield i:yield*i}return Su(n)?async function*(){for await(const i of n)yield*s(i)}():function*(){for(const i of n)yield*s(i)}()}ps.single=(n,e)=>{e=e??{};const t=e.lengthEncoder??Hs,r=e?.maxDataLength??Go;return xu(n,r),new H(t(n.byteLength),n)};var Dt;(function(n){n[n.LENGTH=0]="LENGTH",n[n.DATA=1]="DATA"})(Dt||(Dt={}));const Qo=n=>{const e=Ws(n);return Qo.bytes=Ie(e),e};Qo.bytes=0;function gs(n,e){const t=new H;let r=Dt.LENGTH,s=-1;const i=e?.lengthDecoder??Qo,o=e?.maxLengthLength??Mm,a=e?.maxDataLength??Go;function*c(){for(;t.byteLength>0;){if(r===Dt.LENGTH)try{if(s=i(t),s<0)throw new Nm("Invalid message length");if(s>a)throw new vu("Message length too long");const u=i.bytes;t.consume(u),e?.onLength!=null&&e.onLength(s),r=Dt.DATA}catch(u){if(u instanceof RangeError){if(t.byteLength>o)throw new Om("Message length length too long");break}throw u}if(r===Dt.DATA){if(t.byteLength<s)break;const u=t.sublist(0,s);t.consume(s),e?.onData!=null&&e.onData(u),yield u,r=Dt.LENGTH}}}return Su(n)?async function*(){for await(const u of n)t.append(u),yield*c();if(t.byteLength>0)throw new za("Unexpected end of input")}():function*(){for(const u of n)t.append(u),yield*c();if(t.byteLength>0)throw new za("Unexpected end of input")}()}gs.fromReader=(n,e)=>{let t=1;const r=async function*(){for(;;)try{const{done:i,value:o}=await n.next(t);if(i===!0)return;o!=null&&(yield o)}catch(i){if(i.code==="ERR_UNDER_READ")return{done:!0,value:null};throw i}finally{t=1}}();return gs(r,{...e??{},onLength:i=>{t=i}})};function V(){const n={};return n.promise=new Promise((e,t)=>{n.resolve=e,n.reject=t}),n}let qa=class extends Error{type;code;constructor(e,t,r){super(e??"The operation was aborted"),this.type="aborted",this.name=r??"AbortError",this.code=t??"ABORT_ERR"}};async function oe(n,e,t){if(e==null)return n;if(e.aborted)return n.catch(()=>{}),Promise.reject(new qa(t?.errorMessage,t?.errorCode,t?.errorName));let r;const s=new qa(t?.errorMessage,t?.errorCode,t?.errorName);try{return await Promise.race([n,new Promise((i,o)=>{r=()=>{o(s)},e.addEventListener("abort",r)})])}finally{r!=null&&e.removeEventListener("abort",r)}}let Fm=class{readNext;haveNext;ended;nextResult;error;constructor(){this.ended=!1,this.readNext=V(),this.haveNext=V()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=V(),e}async throw(e){return this.ended=!0,this.error=e,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=V(),await oe(this.readNext.promise,t?.signal,t)}};function Um(){return new Fm}let Bm=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};function $m(n,e){const t=Um();n.sink(t).catch(async o=>{await t.end(o)}),n.sink=async o=>{for await(const a of o)await t.push(a);await t.end()};let r=n.source;n.source[Symbol.iterator]!=null?r=n.source[Symbol.iterator]():n.source[Symbol.asyncIterator]!=null&&(r=n.source[Symbol.asyncIterator]());const s=new H;return{read:async o=>{if(o?.signal?.throwIfAborted(),o?.bytes==null){const{done:c,value:u}=await oe(r.next(),o?.signal);return c===!0?null:u}for(;s.byteLength<o.bytes;){const{value:c,done:u}=await oe(r.next(),o?.signal);if(u===!0)throw new Bm("unexpected end of input");s.append(c)}const a=s.sublist(0,o.bytes);return s.consume(o.bytes),a},write:async(o,a)=>{a?.signal?.throwIfAborted(),o instanceof Uint8Array?await t.push(o,a):await t.push(o.subarray(),a)},unwrap:()=>{if(s.byteLength>0){const o=n.source;n.source=async function*(){e?.yieldBytes===!1?yield s:yield*s,yield*o}()}return n}}}class zm extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"}class qm extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"}class Km extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"}function mn(n,e={}){const t=$m(n,e);e.maxDataLength!=null&&e.maxLengthLength==null&&(e.maxLengthLength=Ie(e.maxDataLength));const r=e?.lengthDecoder??Ws,s=e?.lengthEncoder??an;return{read:async o=>{let a=-1;const c=new H;for(;;){c.append(await t.read({...o,bytes:1}));try{a=r(c)}catch(u){if(u instanceof RangeError)continue;throw u}if(a<0)throw new zm("Invalid message length");if(e?.maxLengthLength!=null&&c.byteLength>e.maxLengthLength)throw new Km("message length length too long");if(a>-1)break}if(e?.maxDataLength!=null&&a>e.maxDataLength)throw new qm("message length too long");return t.read({...o,bytes:a})},write:async(o,a)=>{await t.write(new H(s(o.byteLength),o),a)},writeV:async(o,a)=>{const c=new H(...o.flatMap(u=>[s(u.byteLength),u]));await t.write(c,a)},unwrap:()=>t.unwrap()}}function Ka(){const n=V();let e=!1;return{sink:async t=>{if(e)throw new Error("already piped");e=!0,n.resolve(t)},source:async function*(){yield*await n.promise}()}}function Wm(){const n=Ka(),e=Ka();return[{source:n.source,sink:e.sink},{source:e.source,sink:n.sink}]}class Wa{buffer;mask;top;btm;next;constructor(e){if(!(e>0)||(e-1&e)!==0)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){const e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return this.buffer[this.btm]===void 0}}class pi{size;hwm;head;tail;constructor(e={}){this.hwm=e.splitLimit??16,this.head=new Wa(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return e?.byteLength!=null?e.byteLength:1}push(e){if(e?.value!=null&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){const t=this.head;this.head=t.next=new Wa(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(e===void 0&&this.tail.next!=null){const t=this.tail.next;this.tail.next=null,this.tail=t,e=this.tail.shift()}return e?.value!=null&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}}let Vm=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.code=t??"ABORT_ERR"}};function kn(n={}){return Hm(t=>{const r=t.shift();if(r==null)return{done:!0};if(r.error!=null)throw r.error;return{done:r.done===!0,value:r.value}},n)}function Hm(n,e){e=e??{};let t=e.onEnd,r=new pi,s,i,o,a=V();const c=async()=>{try{return r.isEmpty()?o?{done:!0}:await new Promise((f,w)=>{i=v=>{i=null,r.push(v);try{f(n(r))}catch(x){w(x)}return s}}):n(r)}finally{r.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=V()})}},u=f=>i!=null?i(f):(r.push(f),s),l=f=>(r=new pi,i!=null?i({error:f}):(r.push({error:f}),s)),d=f=>{if(o)return s;if(e?.objectMode!==!0&&f?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return u({done:!1,value:f})},h=f=>o?s:(o=!0,f!=null?l(f):u({done:!0})),p=()=>(r=new pi,h(),{done:!0}),g=f=>(h(f),{done:!0});if(s={[Symbol.asyncIterator](){return this},next:c,return:p,throw:g,push:d,end:h,get readableLength(){return r.size},onEmpty:async f=>{const w=f?.signal;if(w?.throwIfAborted(),r.isEmpty())return;let v,x;w!=null&&(v=new Promise((L,E)=>{x=()=>{E(new Vm)},w.addEventListener("abort",x)}));try{await Promise.race([a.promise,v])}finally{x!=null&&w!=null&&w?.removeEventListener("abort",x)}}},t==null)return s;const m=s;return s={[Symbol.asyncIterator](){return this},next(){return m.next()},throw(f){return m.throw(f),t!=null&&(t(f),t=void 0),{done:!0}},return(){return m.return(),t!=null&&(t(),t=void 0),{done:!0}},push:d,end(f){return m.end(f),t!=null&&(t(f),t=void 0),s},get readableLength(){return m.readableLength},onEmpty:f=>m.onEmpty(f)},s}let Gm=class{readNext;haveNext;ended;nextResult;error;constructor(){this.ended=!1,this.readNext=V(),this.haveNext=V()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=V(),e}async throw(e){return this.ended=!0,this.error=e,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=V(),await oe(this.readNext.promise,t?.signal,t)}};function Qm(){return new Gm}function Ym(n){return n[Symbol.asyncIterator]!=null}async function Xm(n,e,t){try{await Promise.all(n.map(async r=>{for await(const s of r)await e.push(s,{signal:t}),t.throwIfAborted()})),await e.end(void 0,{signal:t})}catch(r){await e.end(r,{signal:t}).catch(()=>{})}}async function*Zm(n){const e=new AbortController,t=Qm();Xm(n,t,e.signal).catch(()=>{});try{yield*t}finally{e.abort()}}function*jm(n){for(const e of n)yield*e}function ms(...n){const e=[];for(const t of n)Ym(t)||e.push(t);return e.length===n.length?jm(e):Zm(n)}function Au(n,...e){if(n==null)throw new Error("Empty pipeline");if(gi(n)){const r=n;n=()=>r.source}else if(Cu(n)||_u(n)){const r=n;n=()=>r}const t=[n,...e];if(t.length>1&&gi(t[t.length-1])&&(t[t.length-1]=t[t.length-1].sink),t.length>2)for(let r=1;r<t.length-1;r++)gi(t[r])&&(t[r]=ey(t[r]));return Jm(...t)}const Jm=(...n)=>{let e;for(;n.length>0;)e=n.shift()(e);return e},_u=n=>n?.[Symbol.asyncIterator]!=null,Cu=n=>n?.[Symbol.iterator]!=null,gi=n=>n==null?!1:n.sink!=null&&n.source!=null,ey=n=>e=>{const t=n.sink(e);if(t?.then!=null){const r=kn({objectMode:!0});t.then(()=>{r.end()},o=>{r.end(o)});let s;const i=n.source;if(_u(i))s=async function*(){yield*i,r.end()};else if(Cu(i))s=function*(){yield*i,r.end()};else throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");return ms(r,s())}return n.source},ar=65535,Va=ar-16,Ar=!!globalThis.process?.env?.DUMP_SESSION_KEYS;/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function Iu(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function so(n){if(typeof n!="boolean")throw new Error(`boolean expected, not ${n}`)}function mi(n){if(!Number.isSafeInteger(n)||n<0)throw new Error("positive integer expected, got "+n)}function Ne(n,...e){if(!Iu(n))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(n.length))throw new Error("Uint8Array expected of length "+e+", got length="+n.length)}function Ha(n,e=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(e&&n.finished)throw new Error("Hash#digest() has already been called")}function ty(n,e){Ne(n);const t=e.outputLen;if(n.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function Ct(n){return new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength/4))}function yn(...n){for(let e=0;e<n.length;e++)n[e].fill(0)}function ny(n){return new DataView(n.buffer,n.byteOffset,n.byteLength)}const ry=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function sy(n){if(typeof n!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(n))}function io(n){if(typeof n=="string")n=sy(n);else if(Iu(n))n=oo(n);else throw new Error("Uint8Array expected, got "+typeof n);return n}function iy(n,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(n,e)}function oy(n,e){if(n.length!==e.length)return!1;let t=0;for(let r=0;r<n.length;r++)t|=n[r]^e[r];return t===0}const ay=(n,e)=>{function t(r,...s){if(Ne(r),!ry)throw new Error("Non little-endian hardware is not yet supported");if(n.nonceLength!==void 0){const l=s[0];if(!l)throw new Error("nonce / iv required");n.varSizeNonce?Ne(l):Ne(l,n.nonceLength)}const i=n.tagLength;i&&s[1]!==void 0&&Ne(s[1]);const o=e(r,...s),a=(l,d)=>{if(d!==void 0){if(l!==2)throw new Error("cipher output not supported");Ne(d)}};let c=!1;return{encrypt(l,d){if(c)throw new Error("cannot encrypt() twice with same key + nonce");return c=!0,Ne(l),a(o.encrypt.length,d),o.encrypt(l,d)},decrypt(l,d){if(Ne(l),i&&l.length<i)throw new Error("invalid ciphertext length: smaller than tagLength="+i);return a(o.decrypt.length,d),o.decrypt(l,d)}}}return Object.assign(t,n),t};function Ga(n,e,t=!0){if(e===void 0)return new Uint8Array(n);if(e.length!==n)throw new Error("invalid output length, expected "+n+", got: "+e.length);if(t&&!ly(e))throw new Error("invalid output, must be aligned");return e}function Qa(n,e,t,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(e,t,r);const s=BigInt(32),i=BigInt(4294967295),o=Number(t>>s&i),a=Number(t&i),c=4,u=0;n.setUint32(e+c,o,r),n.setUint32(e+u,a,r)}function cy(n,e,t){so(t);const r=new Uint8Array(16),s=ny(r);return Qa(s,0,BigInt(e),t),Qa(s,8,BigInt(n),t),r}function ly(n){return n.byteOffset%4===0}function oo(n){return Uint8Array.from(n)}const Tu=n=>Uint8Array.from(n.split("").map(e=>e.charCodeAt(0))),uy=Tu("expand 16-byte k"),dy=Tu("expand 32-byte k"),hy=Ct(uy),fy=Ct(dy);function Q(n,e){return n<<e|n>>>32-e}function ao(n){return n.byteOffset%4===0}const Br=64,py=16,Pu=2**32-1,Ya=new Uint32Array;function gy(n,e,t,r,s,i,o,a){const c=s.length,u=new Uint8Array(Br),l=Ct(u),d=ao(s)&&ao(i),h=d?Ct(s):Ya,p=d?Ct(i):Ya;for(let g=0;g<c;o++){if(n(e,t,r,l,o,a),o>=Pu)throw new Error("arx: counter overflow");const m=Math.min(Br,c-g);if(d&&m===Br){const f=g/4;if(g%4!==0)throw new Error("arx: invalid block position");for(let w=0,v;w<py;w++)v=f+w,p[v]=h[v]^l[w];g+=Br;continue}for(let f=0,w;f<m;f++)w=g+f,i[w]=s[w]^u[f];g+=m}}function my(n,e){const{allowShortKeys:t,extendNonceFn:r,counterLength:s,counterRight:i,rounds:o}=iy({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof n!="function")throw new Error("core must be a function");return mi(s),mi(o),so(i),so(t),(a,c,u,l,d=0)=>{Ne(a),Ne(c),Ne(u);const h=u.length;if(l===void 0&&(l=new Uint8Array(h)),Ne(l),mi(d),d<0||d>=Pu)throw new Error("arx: counter overflow");if(l.length<h)throw new Error(`arx: output (${l.length}) is shorter than data (${h})`);const p=[];let g=a.length,m,f;if(g===32)p.push(m=oo(a)),f=fy;else if(g===16&&t)m=new Uint8Array(32),m.set(a),m.set(a,16),f=hy,p.push(m);else throw new Error(`arx: invalid 32-byte key, got length=${g}`);ao(c)||p.push(c=oo(c));const w=Ct(m);if(r){if(c.length!==24)throw new Error("arx: extended nonce must be 24 bytes");r(f,w,Ct(c.subarray(0,16)),w),c=c.subarray(16)}const v=16-s;if(v!==c.length)throw new Error(`arx: nonce must be ${v} or 16 bytes`);if(v!==12){const L=new Uint8Array(12);L.set(c,i?0:12-c.length),c=L,p.push(c)}const x=Ct(c);return gy(n,f,w,x,u,l,d,o),yn(...p),l}}const ye=(n,e)=>n[e++]&255|(n[e++]&255)<<8;class yy{constructor(e){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,e=io(e),Ne(e,32);const t=ye(e,0),r=ye(e,2),s=ye(e,4),i=ye(e,6),o=ye(e,8),a=ye(e,10),c=ye(e,12),u=ye(e,14);this.r[0]=t&8191,this.r[1]=(t>>>13|r<<3)&8191,this.r[2]=(r>>>10|s<<6)&7939,this.r[3]=(s>>>7|i<<9)&8191,this.r[4]=(i>>>4|o<<12)&255,this.r[5]=o>>>1&8190,this.r[6]=(o>>>14|a<<2)&8191,this.r[7]=(a>>>11|c<<5)&8065,this.r[8]=(c>>>8|u<<8)&8191,this.r[9]=u>>>5&127;for(let l=0;l<8;l++)this.pad[l]=ye(e,16+2*l)}process(e,t,r=!1){const s=r?0:2048,{h:i,r:o}=this,a=o[0],c=o[1],u=o[2],l=o[3],d=o[4],h=o[5],p=o[6],g=o[7],m=o[8],f=o[9],w=ye(e,t+0),v=ye(e,t+2),x=ye(e,t+4),L=ye(e,t+6),E=ye(e,t+8),T=ye(e,t+10),k=ye(e,t+12),D=ye(e,t+14);let y=i[0]+(w&8191),S=i[1]+((w>>>13|v<<3)&8191),b=i[2]+((v>>>10|x<<6)&8191),A=i[3]+((x>>>7|L<<9)&8191),_=i[4]+((L>>>4|E<<12)&8191),I=i[5]+(E>>>1&8191),C=i[6]+((E>>>14|T<<2)&8191),P=i[7]+((T>>>11|k<<5)&8191),R=i[8]+((k>>>8|D<<8)&8191),N=i[9]+(D>>>5|s),M=0,F=M+y*a+S*(5*f)+b*(5*m)+A*(5*g)+_*(5*p);M=F>>>13,F&=8191,F+=I*(5*h)+C*(5*d)+P*(5*l)+R*(5*u)+N*(5*c),M+=F>>>13,F&=8191;let O=M+y*c+S*a+b*(5*f)+A*(5*m)+_*(5*g);M=O>>>13,O&=8191,O+=I*(5*p)+C*(5*h)+P*(5*d)+R*(5*l)+N*(5*u),M+=O>>>13,O&=8191;let B=M+y*u+S*c+b*a+A*(5*f)+_*(5*m);M=B>>>13,B&=8191,B+=I*(5*g)+C*(5*p)+P*(5*h)+R*(5*d)+N*(5*l),M+=B>>>13,B&=8191;let G=M+y*l+S*u+b*c+A*a+_*(5*f);M=G>>>13,G&=8191,G+=I*(5*m)+C*(5*g)+P*(5*p)+R*(5*h)+N*(5*d),M+=G>>>13,G&=8191;let ne=M+y*d+S*l+b*u+A*c+_*a;M=ne>>>13,ne&=8191,ne+=I*(5*f)+C*(5*m)+P*(5*g)+R*(5*p)+N*(5*h),M+=ne>>>13,ne&=8191;let W=M+y*h+S*d+b*l+A*u+_*c;M=W>>>13,W&=8191,W+=I*a+C*(5*f)+P*(5*m)+R*(5*g)+N*(5*p),M+=W>>>13,W&=8191;let ie=M+y*p+S*h+b*d+A*l+_*u;M=ie>>>13,ie&=8191,ie+=I*c+C*a+P*(5*f)+R*(5*m)+N*(5*g),M+=ie>>>13,ie&=8191;let Re=M+y*g+S*p+b*h+A*d+_*l;M=Re>>>13,Re&=8191,Re+=I*u+C*c+P*a+R*(5*f)+N*(5*m),M+=Re>>>13,Re&=8191;let ve=M+y*m+S*g+b*p+A*h+_*d;M=ve>>>13,ve&=8191,ve+=I*l+C*u+P*c+R*a+N*(5*f),M+=ve>>>13,ve&=8191;let me=M+y*f+S*m+b*g+A*p+_*h;M=me>>>13,me&=8191,me+=I*d+C*l+P*u+R*c+N*a,M+=me>>>13,me&=8191,M=(M<<2)+M|0,M=M+F|0,F=M&8191,M=M>>>13,O+=M,i[0]=F,i[1]=O,i[2]=B,i[3]=G,i[4]=ne,i[5]=W,i[6]=ie,i[7]=Re,i[8]=ve,i[9]=me}finalize(){const{h:e,pad:t}=this,r=new Uint16Array(10);let s=e[1]>>>13;e[1]&=8191;for(let a=2;a<10;a++)e[a]+=s,s=e[a]>>>13,e[a]&=8191;e[0]+=s*5,s=e[0]>>>13,e[0]&=8191,e[1]+=s,s=e[1]>>>13,e[1]&=8191,e[2]+=s,r[0]=e[0]+5,s=r[0]>>>13,r[0]&=8191;for(let a=1;a<10;a++)r[a]=e[a]+s,s=r[a]>>>13,r[a]&=8191;r[9]-=8192;let i=(s^1)-1;for(let a=0;a<10;a++)r[a]&=i;i=~i;for(let a=0;a<10;a++)e[a]=e[a]&i|r[a];e[0]=(e[0]|e[1]<<13)&65535,e[1]=(e[1]>>>3|e[2]<<10)&65535,e[2]=(e[2]>>>6|e[3]<<7)&65535,e[3]=(e[3]>>>9|e[4]<<4)&65535,e[4]=(e[4]>>>12|e[5]<<1|e[6]<<14)&65535,e[5]=(e[6]>>>2|e[7]<<11)&65535,e[6]=(e[7]>>>5|e[8]<<8)&65535,e[7]=(e[8]>>>8|e[9]<<5)&65535;let o=e[0]+t[0];e[0]=o&65535;for(let a=1;a<8;a++)o=(e[a]+t[a]|0)+(o>>>16)|0,e[a]=o&65535;yn(r)}update(e){Ha(this),e=io(e),Ne(e);const{buffer:t,blockLen:r}=this,s=e.length;for(let i=0;i<s;){const o=Math.min(r-this.pos,s-i);if(o===r){for(;r<=s-i;i+=r)this.process(e,i);continue}t.set(e.subarray(i,i+o),this.pos),this.pos+=o,i+=o,this.pos===r&&(this.process(t,0,!1),this.pos=0)}return this}destroy(){yn(this.h,this.r,this.buffer,this.pad)}digestInto(e){Ha(this),ty(e,this),this.finished=!0;const{buffer:t,h:r}=this;let{pos:s}=this;if(s){for(t[s++]=1;s<16;s++)t[s]=0;this.process(t,0,!0)}this.finalize();let i=0;for(let o=0;o<8;o++)e[i++]=r[o]>>>0,e[i++]=r[o]>>>8;return e}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}}function wy(n){const e=(r,s)=>n(s).update(io(r)).digest(),t=n(new Uint8Array(32));return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=r=>n(r),e}const by=wy(n=>new yy(n));function Ey(n,e,t,r,s,i=20){let o=n[0],a=n[1],c=n[2],u=n[3],l=e[0],d=e[1],h=e[2],p=e[3],g=e[4],m=e[5],f=e[6],w=e[7],v=s,x=t[0],L=t[1],E=t[2],T=o,k=a,D=c,y=u,S=l,b=d,A=h,_=p,I=g,C=m,P=f,R=w,N=v,M=x,F=L,O=E;for(let G=0;G<i;G+=2)T=T+S|0,N=Q(N^T,16),I=I+N|0,S=Q(S^I,12),T=T+S|0,N=Q(N^T,8),I=I+N|0,S=Q(S^I,7),k=k+b|0,M=Q(M^k,16),C=C+M|0,b=Q(b^C,12),k=k+b|0,M=Q(M^k,8),C=C+M|0,b=Q(b^C,7),D=D+A|0,F=Q(F^D,16),P=P+F|0,A=Q(A^P,12),D=D+A|0,F=Q(F^D,8),P=P+F|0,A=Q(A^P,7),y=y+_|0,O=Q(O^y,16),R=R+O|0,_=Q(_^R,12),y=y+_|0,O=Q(O^y,8),R=R+O|0,_=Q(_^R,7),T=T+b|0,O=Q(O^T,16),P=P+O|0,b=Q(b^P,12),T=T+b|0,O=Q(O^T,8),P=P+O|0,b=Q(b^P,7),k=k+A|0,N=Q(N^k,16),R=R+N|0,A=Q(A^R,12),k=k+A|0,N=Q(N^k,8),R=R+N|0,A=Q(A^R,7),D=D+_|0,M=Q(M^D,16),I=I+M|0,_=Q(_^I,12),D=D+_|0,M=Q(M^D,8),I=I+M|0,_=Q(_^I,7),y=y+S|0,F=Q(F^y,16),C=C+F|0,S=Q(S^C,12),y=y+S|0,F=Q(F^y,8),C=C+F|0,S=Q(S^C,7);let B=0;r[B++]=o+T|0,r[B++]=a+k|0,r[B++]=c+D|0,r[B++]=u+y|0,r[B++]=l+S|0,r[B++]=d+b|0,r[B++]=h+A|0,r[B++]=p+_|0,r[B++]=g+I|0,r[B++]=m+C|0,r[B++]=f+P|0,r[B++]=w+R|0,r[B++]=v+N|0,r[B++]=x+M|0,r[B++]=L+F|0,r[B++]=E+O|0}const vy=my(Ey,{counterRight:!1,counterLength:4,allowShortKeys:!1}),Sy=new Uint8Array(16),Xa=(n,e)=>{n.update(e);const t=e.length%16;t&&n.update(Sy.subarray(t))},xy=new Uint8Array(32);function Za(n,e,t,r,s){const i=n(e,t,xy),o=by.create(i);s&&Xa(o,s),Xa(o,r);const a=cy(r.length,s?s.length:0,!0);o.update(a);const c=o.digest();return yn(i,a),c}const Ay=n=>(e,t,r)=>({encrypt(i,o){const a=i.length;o=Ga(a+16,o,!1),o.set(i);const c=o.subarray(0,-16);n(e,t,c,c,1);const u=Za(n,e,t,c,r);return o.set(u,a),yn(u),o},decrypt(i,o){o=Ga(i.length-16,o,!1);const a=i.subarray(0,-16),c=i.subarray(-16),u=Za(n,e,t,a,r);if(!oy(c,u))throw new Error("invalid tag");return o.set(i.subarray(0,-16)),n(e,t,o,o,1),yn(u),o}}),ja=ay({blockSize:64,nonceLength:12,tagLength:16},Ay(vy));function _y(n,e,t){return ko(n),t===void 0&&(t=new Uint8Array(n.outputLen)),Vs(n,ir(t),ir(e))}const yi=Uint8Array.from([0]),Ja=Uint8Array.of();function Cy(n,e,t,r=32){ko(n),os(r);const s=n.outputLen;if(r>255*s)throw new Error("Length should be <= 255*HashLen");const i=Math.ceil(r/s);t===void 0&&(t=Ja);const o=new Uint8Array(i*s),a=Vs.create(n,e),c=a._cloneInto(),u=new Uint8Array(a.outputLen);for(let l=0;l<i;l++)yi[0]=l+1,c.update(l===0?Ja:u).update(t).update(yi).digestInto(u),o.set(u,s*l),a._cloneInto(c);return a.destroy(),c.destroy(),Bt(u,yi),o.slice(0,r)}const Iy={hashSHA256(n){return jr(n.subarray())},getHKDF(n,e){const t=_y(jr,e,n),s=Cy(jr,t,void 0,96),i=s.subarray(0,32),o=s.subarray(32,64),a=s.subarray(64,96);return[i,o,a]},generateX25519KeyPair(){const n=Nr.utils.randomPrivateKey();return{publicKey:Nr.getPublicKey(n),privateKey:n}},generateX25519KeyPairFromSeed(n){return{publicKey:Nr.getPublicKey(n),privateKey:n}},generateX25519SharedKey(n,e){return Nr.getSharedSecret(n.subarray(),e.subarray())},chaCha20Poly1305Encrypt(n,e,t,r){return ja(r,e,t).encrypt(n.subarray())},chaCha20Poly1305Decrypt(n,e,t,r,s){return ja(r,e,t).decrypt(n.subarray(),s)}},Ty=Iy;function Py(n){return{generateKeypair:n.generateX25519KeyPair,dh:(e,t)=>n.generateX25519SharedKey(e.privateKey,t).subarray(0,32),encrypt:n.chaCha20Poly1305Encrypt,decrypt:n.chaCha20Poly1305Decrypt,hash:n.hashSHA256,hkdf:n.getHKDF}}const ys=n=>{const e=nt(2);return e[0]=n>>8,e[1]=n,e};ys.bytes=2;const Jr=n=>{if(n.length<2)throw RangeError("Could not decode int16BE");if(n instanceof Uint8Array){let e=0;return e+=n[0]<<8,e+=n[1],e}return n.getUint16(0)};Jr.bytes=2;function Dy(n){return{xxHandshakeSuccesses:n.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:n.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:n.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:n.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:n.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}function Du(n,e){!e.enabled||!Ar||(n?(e(`LOCAL_STATIC_PUBLIC_KEY ${q(n.publicKey,"hex")}`),e(`LOCAL_STATIC_PRIVATE_KEY ${q(n.privateKey,"hex")}`)):e("Missing local static keys."))}function Lu(n,e){!e.enabled||!Ar||(n?(e(`LOCAL_PUBLIC_EPHEMERAL_KEY ${q(n.publicKey,"hex")}`),e(`LOCAL_PRIVATE_EPHEMERAL_KEY ${q(n.privateKey,"hex")}`)):e("Missing local ephemeral keys."))}function Ly(n,e){!e.enabled||!Ar||e(n?`REMOTE_STATIC_PUBLIC_KEY ${q(n.subarray(),"hex")}`:"Missing remote static public key.")}function ku(n,e){!e.enabled||!Ar||e(n?`REMOTE_EPHEMERAL_PUBLIC_KEY ${q(n.subarray(),"hex")}`:"Missing remote ephemeral keys.")}function Ru(n,e,t){!t.enabled||!Ar||(t(`CIPHER_STATE_1 ${n.n.getUint64()} ${n.k&&q(n.k,"hex")}`),t(`CIPHER_STATE_2 ${e.n.getUint64()} ${e.k&&q(e.k,"hex")}`))}class er extends Error{code;constructor(e="Invalid crypto exchange"){super(e),this.code=er.code}static code="ERR_INVALID_CRYPTO_EXCHANGE"}const ky=0,Ry=4294967295,My="Cipherstate has reached maximum n, a new handshake must be performed";class Ny{n;bytes;view;constructor(e=ky){this.n=e,this.bytes=j(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,e,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>Ry)throw new Error(My)}}const cn=j(0);class $r{k;n;crypto;constructor(e,t=void 0,r=0){this.crypto=e,this.k=t,this.n=new Ny(r)}hasKey(){return!!this.k}encryptWithAd(e,t){if(!this.hasKey())return t;this.n.assertValue();const r=this.crypto.encrypt(t,this.n.getBytes(),e,this.k);return this.n.increment(),r}decryptWithAd(e,t,r){if(!this.hasKey())return t;this.n.assertValue();const s=this.crypto.decrypt(t,this.n.getBytes(),e,this.k,r);return this.n.increment(),s}}class Oy{cs;ck;h;crypto;constructor(e,t){this.crypto=e;const r=$(t,"utf-8");this.h=Uy(e,r),this.ck=this.h,this.cs=new $r(e)}mixKey(e){const[t,r]=this.crypto.hkdf(this.ck,e);this.ck=t,this.cs=new $r(this.crypto,r)}mixHash(e){this.h=this.crypto.hash(new H(this.h,e))}encryptAndHash(e){const t=this.cs.encryptWithAd(this.h,e);return this.mixHash(t),t}decryptAndHash(e){const t=this.cs.decryptWithAd(this.h,e);return this.mixHash(e),t}split(){const[e,t]=this.crypto.hkdf(this.ck,cn);return[new $r(this.crypto,e),new $r(this.crypto,t)]}}class Fy{ss;s;e;rs;re;initiator;crypto;constructor(e){const{crypto:t,protocolName:r,prologue:s,initiator:i,s:o,e:a,rs:c,re:u}=e;this.crypto=t,this.ss=new Oy(t,r),this.ss.mixHash(s),this.initiator=i,this.s=o,this.e=a,this.rs=c,this.re=u}writeE(){if(this.e)throw new Error("ephemeral keypair is already set");const e=this.crypto.generateKeypair();return this.ss.mixHash(e.publicKey),this.e=e,e.publicKey}writeS(){if(!this.s)throw new Error("static keypair is not set");return this.ss.encryptAndHash(this.s.publicKey)}writeEE(){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.re))}writeES(){if(this.initiator){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}else{if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}}writeSE(){if(this.initiator){if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}else{if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}}readE(e,t=0){if(this.re)throw new Error("remote ephemeral public key is already set");if(e.byteLength<t+32)throw new Error("message is not long enough");this.re=e.sublist(t,t+32),this.ss.mixHash(this.re)}readS(e,t=0){if(this.rs)throw new Error("remote static public key is already set");const r=32+(this.ss.cs.hasKey()?16:0);if(e.byteLength<t+r)throw new Error("message is not long enough");const s=e.sublist(t,t+r);return this.rs=this.ss.decryptAndHash(s),r}readEE(){this.writeEE()}readES(){this.writeES()}readSE(){this.writeSE()}}class Mu extends Fy{writeMessageA(e){return new H(this.writeE(),this.ss.encryptAndHash(e))}writeMessageB(e){const t=this.writeE();this.writeEE();const r=this.writeS();return this.writeES(),new H(t,r,this.ss.encryptAndHash(e))}writeMessageC(e){const t=this.writeS();return this.writeSE(),new H(t,this.ss.encryptAndHash(e))}readMessageA(e){try{return this.readE(e),this.ss.decryptAndHash(e.sublist(32))}catch(t){throw new er(`handshake stage 0 validation fail: ${t.message}`)}}readMessageB(e){try{this.readE(e),this.readEE();const t=this.readS(e,32);return this.readES(),this.ss.decryptAndHash(e.sublist(32+t))}catch(t){throw new er(`handshake stage 1 validation fail: ${t.message}`)}}readMessageC(e){try{const t=this.readS(e);return this.readSE(),this.ss.decryptAndHash(e.sublist(t))}catch(t){throw new er(`handshake stage 2 validation fail: ${t.message}`)}}}function Uy(n,e){if(e.length<=32){const t=j(32);return t.set(e),t}else return n.hash(e)}var ws;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.webtransportCerthashes!=null)for(const i of t.webtransportCerthashes)r.uint32(10),r.bytes(i);if(t.streamMuxers!=null)for(const i of t.streamMuxers)r.uint32(18),r.string(i);s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={webtransportCerthashes:[],streamMuxers:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{if(s.limits?.webtransportCerthashes!=null&&i.webtransportCerthashes.length===s.limits.webtransportCerthashes)throw new pt('Decode error - map field "webtransportCerthashes" had too many elements');i.webtransportCerthashes.push(t.bytes());break}case 2:{if(s.limits?.streamMuxers!=null&&i.streamMuxers.length===s.limits.streamMuxers)throw new pt('Decode error - map field "streamMuxers" had too many elements');i.streamMuxers.push(t.string());break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(ws||(ws={}));var bs;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.identityKey!=null&&t.identityKey.byteLength>0&&(r.uint32(10),r.bytes(t.identityKey)),t.identitySig!=null&&t.identitySig.byteLength>0&&(r.uint32(18),r.bytes(t.identitySig)),t.extensions!=null&&(r.uint32(34),ws.codec().encode(t.extensions,r)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={identityKey:j(0),identitySig:j(0)},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.identityKey=t.bytes();break}case 2:{i.identitySig=t.bytes();break}case 4:{i.extensions=ws.codec().decode(t,t.uint32(),{limits:s.limits?.extensions});break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(bs||(bs={}));async function Nu(n,e,t){const r=await n.sign(Fu(e));return bs.encode({identityKey:dt(n.publicKey),identitySig:r,extensions:t})}async function Ou(n,e,t){try{const r=bs.decode(n),s=It(r.identityKey);if(t?.equals(s)===!1)throw new Error(`Payload identity key ${s} does not match expected remote identity key ${t}`);if(!e)throw new Error("Remote static does not exist");const i=Fu(e);if(!await s.verify(i,r.identitySig))throw new Error("Invalid payload signature");return r}catch(r){throw new Ih(r.message)}}function Fu(n){const e=$("noise-libp2p-static-key:");return n instanceof Uint8Array?Ut([e,n],e.length+n.length):(n.prepend(e),n)}async function By(n,e){const{log:t,connection:r,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:u}=n,l=await Nu(i,a.publicKey,u),d=new Mu({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!0,prologue:o,s:a});Du(d.s,t),t.trace("Stage 0 - Initiator starting to send first message."),await r.write(d.writeMessageA(cn),e),t.trace("Stage 0 - Initiator finished sending first message."),Lu(d.e,t),t.trace("Stage 1 - Initiator waiting to receive first message from responder...");const h=d.readMessageB(await r.read(e));t.trace("Stage 1 - Initiator received the message."),ku(d.re,t),Ly(d.rs,t),t.trace("Initiator going to check remote's signature...");const p=await Ou(h,d.rs,c);t.trace("All good with the signature!"),t.trace("Stage 2 - Initiator sending third handshake message."),await r.write(d.writeMessageC(l),e),t.trace("Stage 2 - Initiator sent message with signed payload.");const[g,m]=d.ss.split();return Ru(g,m,t),{payload:p,encrypt:f=>g.encryptWithAd(cn,f),decrypt:(f,w)=>m.decryptWithAd(cn,f,w)}}async function $y(n,e){const{log:t,connection:r,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:u}=n,l=await Nu(i,a.publicKey,u),d=new Mu({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!1,prologue:o,s:a});Du(d.s,t),t.trace("Stage 0 - Responder waiting to receive first message."),d.readMessageA(await r.read(e)),t.trace("Stage 0 - Responder received first message."),ku(d.re,t),t.trace("Stage 1 - Responder sending out first message with signed payload and static key."),await r.write(d.writeMessageB(l),e),t.trace("Stage 1 - Responder sent the second handshake message with signed payload."),Lu(d.e,t),t.trace("Stage 2 - Responder waiting for third handshake message...");const h=d.readMessageC(await r.read(e));t.trace("Stage 2 - Responder received the message, finished handshake.");const p=await Ou(h,d.rs,c),[g,m]=d.ss.split();return Ru(g,m,t),{payload:p,encrypt:f=>m.encryptWithAd(cn,f),decrypt:(f,w)=>g.decryptWithAd(cn,f,w)}}const ec=16;function zy(n,e){return async function*(t){for await(const r of t)for(let s=0;s<r.length;s+=Va){let i=s+Va;i>r.length&&(i=r.length);let o;r instanceof Uint8Array?o=n.encrypt(r.subarray(s,i)):o=n.encrypt(r.sublist(s,i)),e?.encryptedPackets.increment(),yield new H(ys(o.byteLength),o)}}}function qy(n,e){return async function*(t){for await(const r of t)for(let s=0;s<r.length;s+=ar){let i=s+ar;if(i>r.length&&(i=r.length),i-ec<s)throw new Error("Invalid chunk");const o=r.sublist(s,i),a=r.subarray(s,i-ec);try{const c=n.decrypt(o,a);e?.decryptedPackets.increment(),yield c}catch(c){throw e?.decryptErrors.increment(),c}}}}class Ky{protocol="/noise";crypto;prologue;staticKey;extensions;metrics;components;constructor(e,t={}){const{staticNoiseKey:r,extensions:s,crypto:i,prologueBytes:o}=t,{metrics:a}=e;this.components=e;const c=i??Ty;this.crypto=Py(c),this.extensions={webtransportCerthashes:[],...s},this.metrics=a?Dy(a):void 0,r?this.staticKey=c.generateX25519KeyPairFromSeed(r):this.staticKey=c.generateX25519KeyPair(),this.prologue=o??j(0)}[Symbol.toStringTag]="@chainsafe/libp2p-noise";[Qe]=["@libp2p/connection-encryption","@chainsafe/libp2p-noise"];async secureOutbound(e,t){const r=mn(e,{lengthEncoder:ys,lengthDecoder:Jr,maxDataLength:ar}),s=await this.performHandshakeInitiator(r,this.components.privateKey,t?.remotePeer?.publicKey,t),i=await this.createSecureConnection(r,s);e.source=i.source,e.sink=i.sink;const o=It(s.payload.identityKey);return{conn:e,remoteExtensions:s.payload.extensions,remotePeer:or(o),streamMuxer:t?.skipStreamMuxerNegotiation===!0?void 0:this.getStreamMuxer(s.payload.extensions?.streamMuxers)}}getStreamMuxer(e){if(e==null||e.length===0)return;const t=this.components.upgrader.getStreamMuxers();if(t!=null)for(const r of e){const s=t.get(r);if(s!=null)return s}if(e.length)throw new Th("Early muxer negotiation was requested but the initiator and responder had no common muxers")}async secureInbound(e,t){const r=mn(e,{lengthEncoder:ys,lengthDecoder:Jr,maxDataLength:ar}),s=await this.performHandshakeResponder(r,this.components.privateKey,t?.remotePeer?.publicKey,t),i=await this.createSecureConnection(r,s);e.source=i.source,e.sink=i.sink;const o=It(s.payload.identityKey);return{conn:e,remoteExtensions:s.payload.extensions,remotePeer:or(o),streamMuxer:t?.skipStreamMuxerNegotiation===!0?void 0:this.getStreamMuxer(s.payload.extensions?.streamMuxers)}}async performHandshakeInitiator(e,t,r,s){let i;const o=s?.skipStreamMuxerNegotiation===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{i=await By({connection:e,privateKey:t,remoteIdentityKey:r,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:o,webtransportCerthashes:[],...this.extensions}},s),this.metrics?.xxHandshakeSuccesses.increment()}catch(a){throw this.metrics?.xxHandshakeErrors.increment(),a}return i}async performHandshakeResponder(e,t,r,s){let i;const o=s?.skipStreamMuxerNegotiation===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{i=await $y({connection:e,privateKey:t,remoteIdentityKey:r,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:o,webtransportCerthashes:[],...this.extensions}},s),this.metrics?.xxHandshakeSuccesses.increment()}catch(a){throw this.metrics?.xxHandshakeErrors.increment(),a}return i}async createSecureConnection(e,t){const[r,s]=Wm(),i=e.unwrap();return await Au(r,zy(t,this.metrics),i,o=>gs(o,{lengthDecoder:Jr}),qy(t,this.metrics),r),s}}function Wy(n={}){return e=>new Ky(e,n)}function Uu(n){if(n!=null){if(typeof n[Symbol.iterator]=="function")return n[Symbol.iterator]();if(typeof n[Symbol.asyncIterator]=="function")return n[Symbol.asyncIterator]();if(typeof n.next=="function")return n}throw new Error("argument is not an iterator or iterable")}class nn extends Error{static name="InvalidFrameError";constructor(e="The frame was invalid"){super(e),this.name="InvalidFrameError"}}class Bu extends Error{static name="UnrequestedPingError";constructor(e="Unrequested ping error"){super(e),this.name="UnrequestedPingError"}}class $u extends Error{static name="NotMatchingPingError";constructor(e="Unrequested ping error"){super(e),this.name="NotMatchingPingError"}}class Vy extends Error{static name="InvalidStateError";constructor(e="Invalid state"){super(e),this.name="InvalidStateError"}}class Hy extends Error{static name="StreamAlreadyExistsError";constructor(e="Strean already exists"){super(e),this.name="StreamAlreadyExistsError"}}class Gy extends Error{static name="DecodeInvalidVersionError";constructor(e="Decode invalid version"){super(e),this.name="DecodeInvalidVersionError"}}class Qy extends Error{static name="BothClientsError";constructor(e="Both clients"){super(e),this.name="BothClientsError"}}class zu extends Error{static name="ReceiveWindowExceededError";constructor(e="Receive window exceeded"){super(e),this.name="ReceiveWindowExceededError"}}const Yy=new Set([nn.name,Bu.name,$u.name,Hy.name,Gy.name,Qy.name,zu.name]),Yo=256*1024,Xy=16*1024*1024,Zy={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3,initialStreamWindowSize:Yo,maxStreamWindowSize:Xy,maxMessageSize:64*1024};function jy(n){if(n.keepAliveInterval<=0)throw new z("keep-alive interval must be positive");if(n.maxInboundStreams<0)throw new z("max inbound streams must be larger or equal 0");if(n.maxOutboundStreams<0)throw new z("max outbound streams must be larger or equal 0");if(n.initialStreamWindowSize<Yo)throw new z("InitialStreamWindowSize must be larger or equal 256 kB");if(n.maxStreamWindowSize<n.initialStreamWindowSize)throw new z("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");if(n.maxStreamWindowSize>2**32-1)throw new z("MaxStreamWindowSize must be less than equal MAX_UINT32");if(n.maxMessageSize<1024)throw new z("MaxMessageSize must be greater than a kilobyte")}var pe;(function(n){n[n.Data=0]="Data",n[n.WindowUpdate=1]="WindowUpdate",n[n.Ping=2]="Ping",n[n.GoAway=3]="GoAway"})(pe||(pe={}));var ue;(function(n){n[n.SYN=1]="SYN",n[n.ACK=2]="ACK",n[n.FIN=4]="FIN",n[n.RST=8]="RST"})(ue||(ue={}));Object.values(ue).filter(n=>typeof n!="string");const Jy=0;var Ze;(function(n){n[n.NormalTermination=0]="NormalTermination",n[n.ProtocolError=1]="ProtocolError",n[n.InternalError=2]="InternalError"})(Ze||(Ze={}));const tr=12,tc=2**24;function ew(n){if(n[0]!==Jy)throw new nn("Invalid frame version");return{type:n[1],flag:(n[2]<<8)+n[3],streamID:n[4]*tc+(n[5]<<16)+(n[6]<<8)+n[7],length:n[8]*tc+(n[9]<<16)+(n[10]<<8)+n[11]}}class tw{source;buffer;frameInProgress;constructor(e){this.source=nw(e),this.buffer=new H,this.frameInProgress=!1}async*emitFrames(){for await(const e of this.source)for(this.buffer.append(e);;){const t=this.readHeader();if(t===void 0)break;const{type:r,length:s}=t;r===pe.Data?(this.frameInProgress=!0,yield{header:t,readData:this.readBytes.bind(this,s)}):yield{header:t}}}readHeader(){if(this.frameInProgress)throw new Vy("decoding frame already in progress");if(this.buffer.length<tr)return;const e=ew(this.buffer.subarray(0,tr));return this.buffer.consume(tr),e}async readBytes(e){if(this.buffer.length<e){for await(const r of this.source)if(this.buffer.append(r),this.buffer.length>=e)break}const t=this.buffer.sublist(0,e);return this.buffer.consume(e),this.frameInProgress=!1,t}}function nw(n){if(n[Symbol.iterator]!==void 0){const e=n[Symbol.iterator]();return e.return=void 0,{[Symbol.iterator](){return e}}}else if(n[Symbol.asyncIterator]!==void 0){const e=n[Symbol.asyncIterator]();return e.return=void 0,{[Symbol.asyncIterator](){return e}}}else throw new Error("a source must be either an iterable or an async iterable")}function nc(n){const e=new Uint8Array(tr);return e[1]=n.type,e[2]=n.flag>>>8,e[3]=n.flag,e[4]=n.streamID>>>24,e[5]=n.streamID>>>16,e[6]=n.streamID>>>8,e[7]=n.streamID,e[8]=n.length>>>24,e[9]=n.length>>>16,e[10]=n.length>>>8,e[11]=n.length,e}function rw(n){return n==null?!1:typeof n.then=="function"&&typeof n.catch=="function"&&typeof n.finally=="function"}function sw(n,e){const t=Uu(n).return?.();rw(t)&&t.catch(r=>{e.error("could not cause iterator to return",r)})}const iw=5e3;function wi(n){return n==null?!1:typeof n.then=="function"&&typeof n.catch=="function"&&typeof n.finally=="function"}class qu{id;direction;timeline;protocol;metadata;source;status;readStatus;writeStatus;log;sinkController;sinkEnd;closed;endErr;streamSource;onEnd;onCloseRead;onCloseWrite;onReset;onAbort;sendCloseWriteTimeout;sendingData;constructor(e){this.sinkController=new AbortController,this.sinkEnd=V(),this.closed=V(),this.log=e.log,this.status="open",this.readStatus="ready",this.writeStatus="ready",this.id=e.id,this.metadata=e.metadata??{},this.direction=e.direction,this.timeline={open:Date.now()},this.sendCloseWriteTimeout=e.sendCloseWriteTimeout??iw,this.onEnd=e.onEnd,this.onCloseRead=e.onCloseRead,this.onCloseWrite=e.onCloseWrite,this.onReset=e.onReset,this.onAbort=e.onAbort,this.source=this.streamSource=kn({onEnd:t=>{t!=null?this.log.trace("source ended with error",t):this.log.trace("source ended"),this.onSourceEnd(t)}}),this.sink=this.sink.bind(this)}async sink(e){if(this.writeStatus!=="ready")throw new Ki(`writable end state is "${this.writeStatus}" not "ready"`);try{this.writeStatus="writing";const t={signal:this.sinkController.signal};if(this.direction==="outbound"){const s=this.sendNewStream(t);wi(s)&&await s}const r=()=>{sw(e,this.log)};try{this.sinkController.signal.addEventListener("abort",r),this.log.trace("sink reading from source");for await(let s of e){s=s instanceof Uint8Array?new H(s):s;const i=this.sendData(s,t);wi(i)&&(this.sendingData=V(),await i,this.sendingData.resolve(),this.sendingData=void 0)}}finally{this.sinkController.signal.removeEventListener("abort",r)}this.log.trace('sink finished reading from source, write status is "%s"',this.writeStatus),this.writeStatus==="writing"&&(this.writeStatus="closing",this.log.trace("send close write to remote"),await this.sendCloseWrite({signal:AbortSignal.timeout(this.sendCloseWriteTimeout)}),this.writeStatus="closed"),this.onSinkEnd()}catch(t){throw this.log.trace("sink ended with error, calling abort with error",t),this.abort(t),t}finally{this.log.trace("resolve sink end"),this.sinkEnd.resolve()}}onSourceEnd(e){this.timeline.closeRead==null&&(this.timeline.closeRead=Date.now(),this.readStatus="closed",e!=null&&this.endErr==null&&(this.endErr=e),this.onCloseRead?.(),this.timeline.closeWrite!=null?(this.log.trace("source and sink ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("source ended, waiting for sink to end"))}onSinkEnd(e){this.timeline.closeWrite==null&&(this.timeline.closeWrite=Date.now(),this.writeStatus="closed",e!=null&&this.endErr==null&&(this.endErr=e),this.onCloseWrite?.(),this.timeline.closeRead!=null?(this.log.trace("sink and source ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("sink ended, waiting for source to end"))}async close(e){this.status==="open"&&(this.log.trace("closing gracefully"),this.status="closing",await oe(Promise.all([this.closeWrite(e),this.closeRead(e),this.closed.promise]),e?.signal),this.status="closed",this.log.trace("closed gracefully"))}async closeRead(e={}){if(this.readStatus==="closing"||this.readStatus==="closed")return;this.log.trace('closing readable end of stream with starting read status "%s"',this.readStatus);const t=this.readStatus;this.readStatus="closing",this.status!=="reset"&&this.status!=="aborted"&&this.timeline.closeRead==null&&(this.log.trace("send close read to remote"),await this.sendCloseRead(e)),t==="ready"&&(this.log.trace("ending internal source queue with %d queued bytes",this.streamSource.readableLength),this.streamSource.end()),this.log.trace("closed readable end of stream")}async closeWrite(e={}){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.log.trace('closing writable end of stream with starting write status "%s"',this.writeStatus),this.writeStatus==="ready"&&(this.log.trace("sink was never sunk, sink an empty array"),await oe(this.sink([]),e.signal)),this.writeStatus==="writing"&&(this.sendingData!=null&&await oe(this.sendingData.promise,e.signal),this.log.trace("aborting source passed to .sink"),this.sinkController.abort(),await oe(this.sinkEnd.promise,e.signal)),this.writeStatus="closed",this.log.trace("closed writable end of stream"))}abort(e){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;this.log("abort with error",e),this.log("try to send reset to remote");const t=this.sendReset();wi(t)&&t.catch(r=>{this.log.error("error sending reset message",r)}),this.status="aborted",this.timeline.abort=Date.now(),this._closeSinkAndSource(e),this.onAbort?.(e)}reset(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;const e=new Dh("stream reset");this.status="reset",this.timeline.reset=Date.now(),this._closeSinkAndSource(e),this.onReset?.()}_closeSinkAndSource(e){this._closeSink(e),this._closeSource(e)}_closeSink(e){this.writeStatus==="writing"&&(this.log.trace("end sink source"),this.sinkController.abort()),this.onSinkEnd(e)}_closeSource(e){this.readStatus!=="closing"&&this.readStatus!=="closed"&&(this.log.trace("ending source with %d bytes to be read by consumer",this.streamSource.readableLength),this.readStatus="closing",this.streamSource.end(e))}remoteCloseWrite(){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("received remote close write but local source is already closed");return}this.log.trace("remote close write"),this._closeSource()}remoteCloseRead(){if(this.writeStatus==="closing"||this.writeStatus==="closed"){this.log("received remote close read but local sink is already closed");return}this.log.trace("remote close read"),this._closeSink()}destroy(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset"){this.log("received destroy but we are already closed");return}this.log.trace("stream destroyed"),this._closeSinkAndSource()}sourcePush(e){this.streamSource.push(e)}sourceReadableLength(){return this.streamSource.readableLength}}function Ku(n){const[e,t]=n[Symbol.asyncIterator]!=null?[n[Symbol.asyncIterator](),Symbol.asyncIterator]:[n[Symbol.iterator](),Symbol.iterator],r=[];return{peek:()=>e.next(),push:s=>{r.push(s)},next:()=>r.length>0?{done:!1,value:r.shift()}:e.next(),[t](){return this}}}function ow(n){return n[Symbol.asyncIterator]!=null}function rc(n){return n?.then!=null}function Wu(n,e){let t=0;if(ow(n))return async function*(){for await(const c of n){const u=e(c,t++);rc(u)&&await u,yield c}}();const r=Ku(n),{value:s,done:i}=r.next();if(i===!0)return function*(){}();if(typeof e(s,t++)?.then=="function")return async function*(){yield s;for(const c of r){const u=e(c,t++);rc(u)&&await u,yield c}}();const a=e;return function*(){yield s;for(const c of r)a(c,t++),yield c}()}var Ve;(function(n){n[n.Init=0]="Init",n[n.SYNSent=1]="SYNSent",n[n.SYNReceived=2]="SYNReceived",n[n.Established=3]="Established",n[n.Finished=4]="Finished"})(Ve||(Ve={}));class aw extends qu{name;state;config;_id;sendWindowCapacity;sendWindowCapacityUpdate;recvWindow;recvWindowCapacity;epochStart;getRTT;sendFrame;constructor(e){super({...e,onEnd:t=>{this.state=Ve.Finished,e.onEnd?.(t)}}),this.config=e.config,this._id=parseInt(e.id,10),this.name=e.name,this.state=e.state,this.sendWindowCapacity=Yo,this.recvWindow=this.config.initialStreamWindowSize,this.recvWindowCapacity=this.recvWindow,this.epochStart=Date.now(),this.getRTT=e.getRTT,this.sendFrame=e.sendFrame,this.source=Wu(this.source,()=>{this.sendWindowUpdate()})}async sendNewStream(){}async sendData(e,t={}){for(e=e.sublist();e.byteLength!==0;){if(this.sendWindowCapacity===0&&(this.log?.trace("wait for send window capacity, status %s",this.status),await this.waitForSendWindowCapacity(t),this.status==="closed"||this.status==="aborted"||this.status==="reset")){this.log?.trace("%s while waiting for send window capacity",this.status);return}const r=Math.min(this.sendWindowCapacity,this.config.maxMessageSize-tr,e.length),s=this.getSendFlags();this.sendFrame({type:pe.Data,flag:s,streamID:this._id,length:r},e.sublist(0,r)),this.sendWindowCapacity-=r,e.consume(r)}}async sendReset(){this.sendFrame({type:pe.WindowUpdate,flag:ue.RST,streamID:this._id,length:0})}async sendCloseWrite(){const e=this.getSendFlags()|ue.FIN;this.sendFrame({type:pe.WindowUpdate,flag:e,streamID:this._id,length:0})}async sendCloseRead(){}async waitForSendWindowCapacity(e={}){if(this.sendWindowCapacity>0)return;let t,r;const s=()=>{this.status==="open"||this.status==="closing"?r(new Ft("Stream aborted")):t()};e.signal?.addEventListener("abort",s);try{await new Promise((i,o)=>{this.sendWindowCapacityUpdate=()=>{i()},r=o,t=i})}finally{e.signal?.removeEventListener("abort",s)}}handleWindowUpdate(e){this.log?.trace("stream received window update id=%s",this._id),this.processFlags(e.flag);const t=this.sendWindowCapacity;this.sendWindowCapacity+=e.length,t===0&&e.length>0&&this.sendWindowCapacityUpdate?.()}async handleData(e,t){if(this.log?.trace("stream received data id=%s",this._id),this.processFlags(e.flag),this.recvWindowCapacity<e.length)throw new zu("Receive window exceeded");const r=await t();this.recvWindowCapacity-=e.length,this.sourcePush(r)}processFlags(e){(e&ue.ACK)===ue.ACK&&this.state===Ve.SYNSent&&(this.state=Ve.Established),(e&ue.FIN)===ue.FIN&&this.remoteCloseWrite(),(e&ue.RST)===ue.RST&&this.reset()}getSendFlags(){switch(this.state){case Ve.Init:return this.state=Ve.SYNSent,ue.SYN;case Ve.SYNReceived:return this.state=Ve.Established,ue.ACK;default:return 0}}sendWindowUpdate(){const e=this.getSendFlags(),t=Date.now(),r=this.getRTT();if(e===0&&r>-1&&t-this.epochStart<r*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.config.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&e===0)return;const s=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=t,this.sendFrame({type:pe.WindowUpdate,flag:e,streamID:this._id,length:s})}}const Vu="/yamux/1.0.0",cw=500;class lw{protocol=Vu;_components;_init;constructor(e,t={}){this._components=e,this._init=t}[Symbol.toStringTag]="@chainsafe/libp2p-yamux";[Qe]=["@libp2p/stream-multiplexing"];createStreamMuxer(e){return new uw(this._components,{...this._init,...e})}}class uw{protocol=Vu;source;sink;config;log;logger;closeController;nextStreamID;_streams;nextPingID;activePing;rtt;client;localGoAway;remoteGoAway;numInboundStreams;numOutboundStreams;onIncomingStream;onStreamEnd;constructor(e,t){this.client=t.direction==="outbound",this.config={...Zy,...t},this.logger=e.logger,this.log=this.logger.forComponent("libp2p:yamux"),jy(this.config),this.closeController=new AbortController,this.closeController.signal,this.onIncomingStream=t.onIncomingStream,this.onStreamEnd=t.onStreamEnd,this._streams=new Map,this.source=kn({onEnd:()=>{this.log?.trace("muxer source ended"),this._streams.forEach(r=>{r.destroy()})}}),this.sink=async r=>{const s=()=>{const a=Uu(r);if(a.return!=null){const c=a.return();dw(c)&&c.catch(u=>{this.log?.("could not cause sink source to return",u)})}};let i,o;try{const a=new tw(r);try{this.closeController.signal.addEventListener("abort",s);for await(const c of a.emitFrames())await this.handleFrame(c.header,c.readData)}finally{this.closeController.signal.removeEventListener("abort",s)}i=Ze.NormalTermination}catch(a){Yy.has(a.name)?(this.log?.error("protocol error in sink",a),i=Ze.ProtocolError):(this.log?.error("internal error in sink",a),i=Ze.InternalError),o=a}this.log?.trace("muxer sink ended"),o!=null?this.abort(o,i):await this.close({reason:i})},this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,this.log?.trace("muxer created"),this.config.enableKeepAlive&&this.keepAliveLoop().catch(r=>this.log?.error("keepalive error: %s",r)),this.ping().catch(r=>this.log?.error("ping error: %s",r))}get streams(){return Array.from(this._streams.values())}newStream(e){if(this.remoteGoAway!==void 0)throw new On("Muxer closed remotely");if(this.localGoAway!==void 0)throw new On("Muxer closed locally");const t=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.config.maxOutboundStreams)throw new vl("max outbound streams exceeded");this.log?.trace("new outgoing stream id=%s",t);const r=this._newStream(t,e,Ve.Init,"outbound");return this._streams.set(t,r),this.numOutboundStreams++,r.sendWindowUpdate(),r}async ping(){if(this.remoteGoAway!==void 0)throw new On("Muxer closed remotely");if(this.localGoAway!==void 0)throw new On("Muxer closed locally");if(this.activePing===void 0){let e=()=>{};this.activePing={id:this.nextPingID++,promise:new Promise((s,i)=>{const o=()=>{i(new On("Muxer closed locally"))};this.closeController.signal.addEventListener("abort",o,{once:!0}),e=()=>{this.closeController.signal.removeEventListener("abort",o),s()}}),resolve:e};const t=Date.now();this.sendPing(this.activePing.id);try{await this.activePing.promise}finally{delete this.activePing}const r=Date.now();this.rtt=r-t}else await this.activePing.promise;return this.rtt}getRTT(){return this.rtt}async close(e={}){if(this.closeController.signal.aborted)return;const t=e?.reason??Ze.NormalTermination;if(this.log?.trace("muxer close reason=%s",t),e.signal==null){const r=AbortSignal.timeout(cw);e={...e,signal:r}}try{await Promise.all([...this._streams.values()].map(async r=>r.close(e))),this.sendGoAway(t),this._closeMuxer()}catch(r){this.abort(r)}}abort(e,t){if(!this.closeController.signal.aborted){t=t??Ze.InternalError,this.log?.error("muxer abort reason=%s error=%s",t,e);for(const r of this._streams.values())r.abort(e);this.sendGoAway(t),this._closeMuxer()}}isClosed(){return this.closeController.signal.aborted}_closeMuxer(){this.closeController.abort(),this.source.end()}_newStream(e,t,r,s){if(this._streams.get(e)!=null)throw new z("Stream already exists with that id");const i=new aw({id:e.toString(),name:t,state:r,direction:s,sendFrame:this.sendFrame.bind(this),onEnd:()=>{this.closeStream(e),this.onStreamEnd?.(i)},log:this.logger.forComponent(`libp2p:yamux:${s}:${e}`),config:this.config,getRTT:this.getRTT.bind(this)});return i}closeStream(e){this.client===(e%2===0)?this.numInboundStreams--:this.numOutboundStreams--,this._streams.delete(e)}async keepAliveLoop(){for(this.log?.trace("muxer keepalive enabled interval=%s",this.config.keepAliveInterval);;){let e;try{await oe(new Promise(t=>{e=setTimeout(t,this.config.keepAliveInterval)}),this.closeController.signal),this.ping().catch(t=>this.log?.error("ping error: %s",t))}catch{clearInterval(e);return}}}async handleFrame(e,t){const{streamID:r,type:s,length:i}=e;if(this.log?.trace("received frame %o",e),r===0)switch(s){case pe.Ping:{this.handlePing(e);return}case pe.GoAway:{this.handleGoAway(i);return}default:throw new nn("Invalid frame type")}else switch(e.type){case pe.Data:case pe.WindowUpdate:{await this.handleStreamMessage(e,t);return}default:throw new nn("Invalid frame type")}}handlePing(e){if(e.flag===ue.SYN)this.log?.trace("received ping request pingId=%s",e.length),this.sendPing(e.length,ue.ACK);else if(e.flag===ue.ACK)this.log?.trace("received ping response pingId=%s",e.length),this.handlePingResponse(e.length);else throw new nn("Invalid frame flag")}handlePingResponse(e){if(this.activePing===void 0)throw new Bu("ping not requested");if(this.activePing.id!==e)throw new $u("ping doesn't match our id");this.activePing.resolve()}handleGoAway(e){this.log?.trace("received GoAway reason=%s",Ze[e]??"unknown"),this.remoteGoAway=e;for(const t of this._streams.values())t.reset();this._closeMuxer()}async handleStreamMessage(e,t){const{streamID:r,flag:s,type:i}=e;(s&ue.SYN)===ue.SYN&&this.incomingStream(r);const o=this._streams.get(r);if(o===void 0){if(i===pe.Data){if(this.log?.("discarding data for stream id=%s",r),t===void 0)throw new Error("unreachable");await t()}else this.log?.trace("frame for missing stream id=%s",r);return}switch(i){case pe.WindowUpdate:{o.handleWindowUpdate(e);return}case pe.Data:{if(t===void 0)throw new Error("unreachable");await o.handleData(e,t);return}default:throw new Error("unreachable")}}incomingStream(e){if(this.client!==(e%2===0))throw new z("Both endpoints are clients");if(this._streams.has(e))return;if(this.log?.trace("new incoming stream id=%s",e),this.localGoAway!==void 0){this.sendFrame({type:pe.WindowUpdate,flag:ue.RST,streamID:e,length:0});return}if(this.numInboundStreams>=this.config.maxInboundStreams){this.log?.("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:pe.WindowUpdate,flag:ue.RST,streamID:e,length:0});return}const t=this._newStream(e,void 0,Ve.SYNReceived,"inbound");this.numInboundStreams++,this._streams.set(e,t),this.onIncomingStream?.(t)}sendFrame(e,t){if(this.log?.trace("sending frame %o",e),e.type===pe.Data){if(t===void 0)throw new nn("Invalid frame");this.source.push(new H(nc(e),t))}else this.source.push(nc(e))}sendPing(e,t=ue.SYN){t===ue.SYN?this.log?.trace("sending ping request pingId=%s",e):this.log?.trace("sending ping response pingId=%s",e),this.sendFrame({type:pe.Ping,flag:t,streamID:0,length:e})}sendGoAway(e=Ze.NormalTermination){this.log?.("sending GoAway reason=%s",Ze[e]),this.localGoAway=e,this.sendFrame({type:pe.GoAway,flag:0,streamID:0,length:e})}}function dw(n){return n!=null&&typeof n.then=="function"}function hw(n={}){return e=>new lw(e,n)}var Es;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(r.uint32(10),r.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(r.uint32(18),r.bytes(t.payloadType)),t.payload!=null&&t.payload.byteLength>0&&(r.uint32(26),r.bytes(t.payload)),t.signature!=null&&t.signature.byteLength>0&&(r.uint32(42),r.bytes(t.signature)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={publicKey:j(0),payloadType:j(0),payload:j(0),signature:j(0)},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.publicKey=t.bytes();break}case 2:{i.payloadType=t.bytes();break}case 3:{i.payload=t.bytes();break}case 5:{i.signature=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(Es||(Es={}));class fw extends Error{constructor(e="Invalid signature"){super(e),this.name="InvalidSignatureError"}}class Je{static createFromProtobuf=e=>{const t=Es.decode(e),r=It(t.publicKey);return new Je({publicKey:r,payloadType:t.payloadType,payload:t.payload,signature:t.signature})};static seal=async(e,t,r)=>{if(t==null)throw new Error("Missing private key");const s=e.domain,i=e.codec,o=e.marshal(),a=sc(s,i,o),c=await t.sign(a.subarray(),r);return new Je({publicKey:t.publicKey,payloadType:i,payload:o,signature:c})};static openAndCertify=async(e,t,r)=>{const s=Je.createFromProtobuf(e);if(!await s.validate(t,r))throw new fw("Envelope signature is not valid for the given domain");return s};publicKey;payloadType;payload;signature;marshaled;constructor(e){const{publicKey:t,payloadType:r,payload:s,signature:i}=e;this.publicKey=t,this.payloadType=r,this.payload=s,this.signature=i}marshal(){return this.marshaled==null&&(this.marshaled=Es.encode({publicKey:dt(this.publicKey),payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(e){return e==null?!1:Te(this.marshal(),e.marshal())}async validate(e,t){const r=sc(e,this.payloadType,this.payload);return this.publicKey.verify(r.subarray(),this.signature,t)}}const sc=(n,e,t)=>{const r=$(n),s=an(r.byteLength),i=an(e.length),o=an(t.length);return new H(s,r,i,e,o,t)};function pw(n,e){const t=(r,s)=>r.toString().localeCompare(s.toString());return n.length!==e.length?!1:(e.sort(t),n.sort(t).every((r,s)=>e[s].equals(r)))}class ze extends Error{static name="InvalidMultiaddrError";name="InvalidMultiaddrError"}class cr extends Error{static name="ValidationError";name="ValidationError"}class gw extends Error{static name="InvalidParametersError";name="InvalidParametersError"}class mw extends Error{static name="UnknownProtocolError";name="UnknownProtocolError"}class yw{index=0;input="";new(e){return this.index=0,this.input=e,this}readAtomically(e){const t=this.index,r=e();return r===void 0&&(this.index=t),r}parseWith(e){const t=e();if(this.index===this.input.length)return t}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(e){return this.readAtomically(()=>{const t=this.readChar();if(t===e)return t})}readSeparator(e,t,r){return this.readAtomically(()=>{if(!(t>0&&this.readGivenChar(e)===void 0))return r()})}readNumber(e,t,r,s){return this.readAtomically(()=>{let i=0,o=0;const a=this.peekChar();if(a===void 0)return;const c=a==="0",u=2**(8*s)-1;for(;;){const l=this.readAtomically(()=>{const d=this.readChar();if(d===void 0)return;const h=Number.parseInt(d,e);if(!Number.isNaN(h))return h});if(l===void 0)break;if(i*=e,i+=l,i>u||(o+=1,t!==void 0&&o>t))return}if(o!==0)return!r&&c&&o>1?void 0:i})}readIPv4Addr(){return this.readAtomically(()=>{const e=new Uint8Array(4);for(let t=0;t<e.length;t++){const r=this.readSeparator(".",t,()=>this.readNumber(10,3,!1,1));if(r===void 0)return;e[t]=r}return e})}readIPv6Addr(){const e=t=>{for(let r=0;r<t.length/2;r++){const s=r*2;if(r<t.length-3){const o=this.readSeparator(":",r,()=>this.readIPv4Addr());if(o!==void 0)return t[s]=o[0],t[s+1]=o[1],t[s+2]=o[2],t[s+3]=o[3],[s+4,!0]}const i=this.readSeparator(":",r,()=>this.readNumber(16,4,!0,2));if(i===void 0)return[s,!1];t[s]=i>>8,t[s+1]=i&255}return[t.length,!1]};return this.readAtomically(()=>{const t=new Uint8Array(16),[r,s]=e(t);if(r===16)return t;if(s||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;const i=new Uint8Array(14),o=16-(r+2),[a]=e(i.subarray(0,o));return t.set(i.subarray(0,a),16-a),t})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}}const Hu=45,ww=15,wn=new yw;function Gu(n){if(!(n.length>ww))return wn.new(n).parseWith(()=>wn.readIPv4Addr())}function Qu(n){if(n.includes("%")&&(n=n.split("%")[0]),!(n.length>Hu))return wn.new(n).parseWith(()=>wn.readIPv6Addr())}function co(n,e=!1){if(n.includes("%")&&(n=n.split("%")[0]),n.length>Hu)return;const t=wn.new(n).parseWith(()=>wn.readIPAddr());if(t)return e&&t.length===4?Uint8Array.from([0,0,0,0,0,0,0,0,0,0,255,255,t[0],t[1],t[2],t[3]]):t}function bn(n){return!!Gu(n)}function Yu(n){return!!Qu(n)}const Kt=4,ht=6,vs=273,bw=33,qe=41,Ht=42,Xo=43,_r=53,Cr=54,Rn=55,Ir=56,Ew=132,vw=301,Sw=302,Xu=400,J=421,xw=444,Aw=445,_w=446,Cw=447,ln=448,Zu=449,Iw=454,ju=460,Ju=461,ed=465,lr=466,un=480,Tw=481,lo=443,Zo=477,td=478,Pw=479,Dw=277,Lw=275,kw=276,nd=280,es=281,Gt=290,rd=777;function ic(n){return e=>q(e,n)}function oc(n){return e=>$(e,n)}function Vn(n){return new DataView(n.buffer).getUint16(n.byteOffset).toString()}function rn(n){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof n=="string"?parseInt(n):n),new Uint8Array(e)}function Rw(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=$(e[0],"base32"),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const s=rn(r);return Ut([t,s],t.length+s.length)}function Mw(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=_t.decode(`b${e[0]}`),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const s=rn(r);return Ut([t,s],t.length+s.length)}function ac(n){const e=n.subarray(0,n.length-2),t=n.subarray(n.length-2),r=q(e,"base32"),s=Vn(t);return`${r}:${s}`}const sd=function(n){n=n.toString().trim();const e=new Uint8Array(4);return n.split(/\./g).forEach((t,r)=>{const s=parseInt(t,10);if(isNaN(s)||s<0||s>255)throw new ze("Invalid byte value in IP address");e[r]=s}),e},Nw=function(n){let e=0;n=n.toString().trim();const t=n.split(":",8);let r;for(r=0;r<t.length;r++){const i=bn(t[r]);let o;i&&(o=sd(t[r]),t[r]=q(o.subarray(0,2),"base16")),o!=null&&++r<8&&t.splice(r,0,q(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(r=0;r<t.length&&t[r]!=="";r++);const i=[r,1];for(r=9-t.length;r>0;r--)i.push("0");t.splice.apply(t,i)}const s=new Uint8Array(e+16);for(r=0;r<t.length;r++){t[r]===""&&(t[r]="0");const i=parseInt(t[r],16);if(isNaN(i)||i<0||i>65535)throw new ze("Invalid byte value in IP address");s[e++]=i>>8&255,s[e++]=i&255}return s},Ow=function(n){if(n.byteLength!==4)throw new ze("IPv4 address was incorrect length");const e=[];for(let t=0;t<n.byteLength;t++)e.push(n[t]);return e.join(".")},Fw=function(n){if(n.byteLength!==16)throw new ze("IPv6 address was incorrect length");const e=[];for(let r=0;r<n.byteLength;r+=2){const s=n[r],i=n[r+1],o=`${s.toString(16).padStart(2,"0")}${i.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const r=new URL(`http://[${t}]`);return r.hostname.substring(1,r.hostname.length-1)}catch{throw new ze(`Invalid IPv6 address "${t}"`)}};function Uw(n){try{const e=new URL(`http://[${n}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new ze(`Invalid IPv6 address "${n}"`)}}const bi=Object.values(Yi).map(n=>n.decoder),Bw=function(){let n=bi[0].or(bi[1]);return bi.slice(2).forEach(e=>n=n.or(e)),n}();function $w(n){return Bw.decode(n)}function zw(n){return e=>n.encoder.encode(e)}function qw(n){if(parseInt(n).toString()!==n)throw new cr("Value must be an integer")}function Kw(n){if(n<0)throw new cr("Value must be a positive integer, or zero")}function Ww(n){return e=>{if(e>n)throw new cr(`Value must be smaller than or equal to ${n}`)}}function Vw(...n){return e=>{for(const t of n)t(e)}}const zr=Vw(qw,Kw,Ww(65535)),xe=-1;class Hw{protocolsByCode=new Map;protocolsByName=new Map;getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new mw(`Protocol ${e} was unknown`);return t}addProtocol(e){this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),e.aliases?.forEach(t=>{this.protocolsByName.set(t,e)})}removeProtocol(e){const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),t.aliases?.forEach(r=>{this.protocolsByName.delete(r)}))}}const et=new Hw,Gw=[{code:Kt,name:"ip4",size:32,valueToBytes:sd,bytesToValue:Ow,validate:n=>{if(!bn(n))throw new cr(`Invalid IPv4 address "${n}"`)}},{code:ht,name:"tcp",size:16,valueToBytes:rn,bytesToValue:Vn,validate:zr},{code:vs,name:"udp",size:16,valueToBytes:rn,bytesToValue:Vn,validate:zr},{code:bw,name:"dccp",size:16,valueToBytes:rn,bytesToValue:Vn,validate:zr},{code:qe,name:"ip6",size:128,valueToBytes:Nw,bytesToValue:Fw,stringToValue:Uw,validate:n=>{if(!Yu(n))throw new cr(`Invalid IPv6 address "${n}"`)}},{code:Ht,name:"ip6zone",size:xe},{code:Xo,name:"ipcidr",size:8,bytesToValue:ic("base10"),valueToBytes:oc("base10")},{code:_r,name:"dns",size:xe,resolvable:!0},{code:Cr,name:"dns4",size:xe,resolvable:!0},{code:Rn,name:"dns6",size:xe,resolvable:!0},{code:Ir,name:"dnsaddr",size:xe,resolvable:!0},{code:Ew,name:"sctp",size:16,valueToBytes:rn,bytesToValue:Vn,validate:zr},{code:vw,name:"udt"},{code:Sw,name:"utp"},{code:Xu,name:"unix",size:xe,path:!0,stringToValue:n=>decodeURIComponent(n),valueToString:n=>encodeURIComponent(n)},{code:J,name:"p2p",aliases:["ipfs"],size:xe,bytesToValue:ic("base58btc"),valueToBytes:n=>n.startsWith("Q")||n.startsWith("1")?oc("base58btc")(n):re.parse(n).multihash.bytes},{code:xw,name:"onion",size:96,bytesToValue:ac,valueToBytes:Rw},{code:Aw,name:"onion3",size:296,bytesToValue:ac,valueToBytes:Mw},{code:_w,name:"garlic64",size:xe},{code:Cw,name:"garlic32",size:xe},{code:ln,name:"tls"},{code:Zu,name:"sni",size:xe},{code:Iw,name:"noise"},{code:ju,name:"quic"},{code:Ju,name:"quic-v1"},{code:ed,name:"webtransport"},{code:lr,name:"certhash",size:xe,bytesToValue:zw(Ll),valueToBytes:$w},{code:un,name:"http"},{code:Tw,name:"http-path",size:xe,stringToValue:n=>`/${decodeURIComponent(n)}`,valueToString:n=>encodeURIComponent(n.substring(1))},{code:lo,name:"https"},{code:Zo,name:"ws"},{code:td,name:"wss"},{code:Pw,name:"p2p-websocket-star"},{code:Dw,name:"p2p-stardust"},{code:Lw,name:"p2p-webrtc-star"},{code:kw,name:"p2p-webrtc-direct"},{code:nd,name:"webrtc-direct"},{code:es,name:"webrtc"},{code:Gt,name:"p2p-circuit"},{code:rd,name:"memory",size:xe}];Gw.forEach(n=>{et.addProtocol(n)});function Qw(n){const e=[];let t=0;for(;t<n.length;){const r=Ws(n,t),s=et.getProtocol(r),i=Ie(r),o=jw(s,n,t+i);let a=0;o>0&&s.size===xe&&(a=Ie(o));const c=i+a+o,u={code:r,name:s.name,bytes:n.subarray(t,t+c)};if(o>0){const l=t+i+a,d=n.subarray(l,l+o);u.value=s.bytesToValue?.(d)??q(d)}e.push(u),t+=c}return e}function Yw(n){let e=0;const t=[];for(const r of n){if(r.bytes==null){const s=et.getProtocol(r.code),i=Ie(r.code);let o,a=0,c=0;r.value!=null&&(o=s.valueToBytes?.(r.value)??$(r.value),a=o.byteLength,s.size===xe&&(c=Ie(a)));const u=new Uint8Array(i+c+a);let l=0;us(r.code,u,l),l+=i,o!=null&&(s.size===xe&&(us(a,u,l),l+=c),u.set(o,l)),r.bytes=u}t.push(r.bytes),e+=r.bytes.byteLength}return Ut(t,e)}function Xw(n){if(n.charAt(0)!=="/")throw new ze('String multiaddr must start with "/"');const e=[];let t="protocol",r="",s="";for(let i=1;i<n.length;i++){const o=n.charAt(i);o!=="/"&&(t==="protocol"?s+=n.charAt(i):r+=n.charAt(i));const a=i===n.length-1;if(o==="/"||a){const c=et.getProtocol(s);if(t==="protocol"){if(c.size==null||c.size===0){e.push({code:c.code,name:c.name}),r="",s="",t="protocol";continue}else if(a)throw new ze(`Component ${s} was missing value`);t="value"}else if(t==="value"){const u={code:c.code,name:c.name};if(c.size!=null&&c.size!==0){if(r==="")throw new ze(`Component ${s} was missing value`);u.value=c.stringToValue?.(r)??r}e.push(u),r="",s="",t="protocol"}}}if(s!==""&&r!=="")throw new ze("Incomplete multiaddr");return e}function Zw(n){return`/${n.flatMap(e=>{if(e.value==null)return e.name;const t=et.getProtocol(e.code);if(t==null)throw new ze(`Unknown protocol code ${e.code}`);return[e.name,t.valueToString?.(e.value)??e.value]}).join("/")}`}function jw(n,e,t){return n.size==null||n.size===0?0:n.size>0?n.size/8:Ws(e,t)}const Jw=Symbol.for("nodejs.util.inspect.custom"),id=Symbol.for("@multiformats/multiaddr"),eb=[_r,Cr,Rn,Ir];class tb extends Error{constructor(e="No available resolver"){super(e),this.name="NoAvailableResolverError"}}function nb(n){if(n==null&&(n="/"),Gs(n))return n.getComponents();if(n instanceof Uint8Array)return Qw(n);if(typeof n=="string")return n=n.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),n===""&&(n="/"),Xw(n);if(Array.isArray(n))return n;throw new ze("Must be a string, Uint8Array, Component[], or another Multiaddr")}class sn{[id]=!0;#e;#n;#t;constructor(e="/",t={}){this.#e=nb(e),t.validate!==!1&&rb(this)}get bytes(){return this.#t==null&&(this.#t=Yw(this.#e)),this.#t}toString(){return this.#n==null&&(this.#n=Zw(this.#e)),this.#n}toJSON(){return this.toString()}toOptions(){let e,t,r,s,i="";for(const{code:a,name:c,value:u}of this.#e)a===Ht&&(i=`%${u??""}`),eb.includes(a)&&(t="tcp",s=443,r=`${u??""}${i}`,e=a===Rn?6:4),(a===ht||a===vs)&&(t=c==="tcp"?"tcp":"udp",s=parseInt(u??"")),(a===Kt||a===qe)&&(t="tcp",r=`${u??""}${i}`,e=a===qe?6:4);if(e==null||t==null||r==null||s==null)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:e,host:r,transport:t,port:s}}getComponents(){return[...this.#e]}protos(){return this.#e.map(({code:e,value:t})=>{const r=et.getProtocol(e);return{code:e,size:r.size??0,name:r.name,resolvable:!!r.resolvable,path:!!r.path}})}protoCodes(){return this.#e.map(({code:e})=>e)}protoNames(){return this.#e.map(({name:e})=>e)}tuples(){return this.#e.map(({code:e,value:t})=>{if(t==null)return[e];const r=et.getProtocol(e),s=[e];return t!=null&&s.push(r.valueToBytes?.(t)??$(t)),s})}stringTuples(){return this.#e.map(({code:e,value:t})=>t==null?[e]:[e,t])}encapsulate(e){const t=new sn(e);return new sn([...this.#e,...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),r=this.toString(),s=r.lastIndexOf(t);if(s<0)throw new gw(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);return new sn(r.slice(0,s),{validate:!1})}decapsulateCode(e){let t;for(let r=this.#e.length-1;r>-1;r--)if(this.#e[r].code===e){t=r;break}return new sn(this.#e.slice(0,t),{validate:!1})}getPeerId(){try{let e=[];this.#e.forEach(({code:r,value:s})=>{r===J&&e.push([r,s]),r===Gt&&(e=[])});const t=e.pop();if(t?.[1]!=null){const r=t[1];return r[0]==="Q"||r[0]==="1"?q(ge.decode(`z${r}`),"base58btc"):q(re.parse(r).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){for(const e of this.#e)if(et.getProtocol(e.code).path)return e.value??null;return null}equals(e){return Te(this.bytes,e.bytes)}async resolve(e){const t=this.protos().find(i=>i.resolvable);if(t==null)return[this];const r=pb.get(t.name);if(r==null)throw new tb(`no available resolver for ${t.name}`);return(await r(this,e)).map(i=>K(i))}nodeAddress(){const e=this.toOptions();if(e.transport!=="tcp"&&e.transport!=="udp")throw new Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:e.family,address:e.host,port:e.port}}isThinWaistAddress(){return!(this.#e.length!==2||this.#e[0].code!==Kt&&this.#e[0].code!==qe||this.#e[1].code!==ht&&this.#e[1].code!==vs)}[Jw](){return`Multiaddr(${this.toString()})`}}function rb(n){n.getComponents().forEach(e=>{const t=et.getProtocol(e.code);e.value!=null&&t.validate?.(e.value)})}function sb(n,e,t){let r=0;for(const s of n)if(!(r<e)){if(r>t)break;if(s!==255)return!1;r++}return!0}function ib(n,e,t,r){let s=0;for(const i of n)if(!(s<t)){if(s>r)break;if(i!==e[s])return!1;s++}return!0}function ob(n){switch(n.length){case ur:return n.join(".");case dr:{const e=[];for(let t=0;t<n.length;t++)t%2===0&&e.push(n[t].toString(16).padStart(2,"0")+n[t+1].toString(16).padStart(2,"0"));return e.join(":")}default:throw new Error("Invalid ip length")}}function ab(n){let e=0;for(let[t,r]of n.entries()){if(r===255){e+=8;continue}for(;(r&128)!=0;)e++,r=r<<1;if((r&128)!=0)return-1;for(let s=t+1;s<n.length;s++)if(n[s]!=0)return-1;break}return e}function cb(n){let e="0x";for(const t of n)e+=(t>>4).toString(16)+(t&15).toString(16);return e}const ur=4,dr=16,lb=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function od(n,e){e.length===dr&&n.length===ur&&sb(e,0,11)&&(e=e.slice(12)),e.length===ur&&n.length===dr&&ib(n,lb,0,11)&&(n=n.slice(12));const t=n.length;if(t!=e.length)throw new Error("Failed to mask ip");const r=new Uint8Array(t);for(let s=0;s<t;s++)r[s]=n[s]&e[s];return r}function ub(n,e){if(typeof e=="string"&&(e=co(e)),e==null)throw new Error("Invalid ip");if(e.length!==n.network.length)return!1;for(let t=0;t<e.length;t++)if((n.network[t]&n.mask[t])!==(e[t]&n.mask[t]))return!1;return!0}function db(n){const[e,t]=n.split("/");if(!e||!t)throw new Error("Failed to parse given CIDR: "+n);let r=ur,s=Gu(e);if(s==null&&(r=dr,s=Qu(e),s==null))throw new Error("Failed to parse given CIDR: "+n);const i=parseInt(t,10);if(Number.isNaN(i)||String(i).length!==t.length||i<0||i>r*8)throw new Error("Failed to parse given CIDR: "+n);const o=ad(i,8*r);return{network:od(s,o),mask:o}}function ad(n,e){if(e!==8*ur&&e!==8*dr)throw new Error("Invalid CIDR mask");if(n<0||n>e)throw new Error("Invalid CIDR mask");const t=e/8,r=new Uint8Array(t);for(let s=0;s<t;s++){if(n>=8){r[s]=255,n-=8;continue}r[s]=255-(255>>n),n=0}return r}class cd{constructor(e,t){if(t==null)({network:this.network,mask:this.mask}=db(e));else{const r=co(e);if(r==null)throw new Error("Failed to parse network");t=String(t);const s=parseInt(t,10);if(Number.isNaN(s)||String(s).length!==t.length||s<0||s>r.length*8){const i=co(t);if(i==null)throw new Error("Failed to parse mask");this.mask=i}else this.mask=ad(s,8*r.length);this.network=od(r,this.mask)}}contains(e){return ub({network:this.network,mask:this.mask},e)}toString(){const e=ab(this.mask),t=e!==-1?String(e):cb(this.mask);return ob(this.network)+"/"+t}}function hb(n,e){return new cd(n).contains(e)}function fb(n){let e,t;if(n.getComponents().forEach(r=>{(r.name==="ip4"||r.name==="ip6")&&(t=r.value),r.name==="ipcidr"&&(e=r.value)}),e==null||t==null)throw new Error("Invalid multiaddr");return new cd(t,e)}const pb=new Map;function Gs(n){return!!n?.[id]}function K(n){return new sn(n)}function Qs(n){const e=et.getProtocol(n);return{code:e.code,size:e.size??0,name:e.name,resolvable:!!e.resolvable,path:!!e.path}}const gb="libp2p-peer-record",mb=Uint8Array.from([3,1]);var Ss;(function(n){(function(t){let r;t.codec=()=>(r==null&&(r=fe((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.multiaddr!=null&&s.multiaddr.byteLength>0&&(i.uint32(10),i.bytes(s.multiaddr)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={multiaddr:j(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const u=s.uint32();switch(u>>>3){case 1:{a.multiaddr=s.bytes();break}default:{s.skipType(u&7);break}}}return a})),r),t.encode=s=>he(s,t.codec()),t.decode=(s,i)=>de(s,t.codec(),i)})(n.AddressInfo||(n.AddressInfo={}));let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.peerId!=null&&t.peerId.byteLength>0&&(r.uint32(10),r.bytes(t.peerId)),t.seq!=null&&t.seq!==0n&&(r.uint32(16),r.uint64(t.seq)),t.addresses!=null)for(const i of t.addresses)r.uint32(26),n.AddressInfo.codec().encode(i,r);s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={peerId:j(0),seq:0n,addresses:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.peerId=t.bytes();break}case 2:{i.seq=t.uint64();break}case 3:{if(s.limits?.addresses!=null&&i.addresses.length===s.limits.addresses)throw new pt('Decode error - map field "addresses" had too many elements');i.addresses.push(n.AddressInfo.codec().decode(t,t.uint32(),{limits:s.limits?.addresses$}));break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(Ss||(Ss={}));class Be{static createFromProtobuf=e=>{const t=Ss.decode(e),r=Sr(yr(t.peerId)),s=(t.addresses??[]).map(o=>K(o.multiaddr)),i=t.seq;return new Be({peerId:r,multiaddrs:s,seqNumber:i})};static DOMAIN=gb;static CODEC=mb;peerId;multiaddrs;seqNumber;domain=Be.DOMAIN;codec=Be.CODEC;marshaled;constructor(e){const{peerId:t,multiaddrs:r,seqNumber:s}=e;this.peerId=t,this.multiaddrs=r??[],this.seqNumber=s??BigInt(Date.now())}marshal(){return this.marshaled==null&&(this.marshaled=Ss.encode({peerId:this.peerId.toMultihash().bytes,seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map(e=>({multiaddr:e.bytes}))})),this.marshaled}equals(e){return!(!(e instanceof Be)||!this.peerId.equals(e.peerId)||this.seqNumber!==e.seqNumber||!pw(this.multiaddrs,e.multiaddrs))}}function mt(n,e){const t=mn(n,e),r={read:async(s,i)=>{const o=await t.read(i);return s.decode(o)},write:async(s,i,o)=>{await t.write(i.encode(s),o)},writeV:async(s,i,o)=>{await t.writeV(s.map(a=>i.encode(a)),o)},pb:s=>({read:async i=>r.read(s,i),write:async(i,o)=>r.write(i,s,o),writeV:async(i,o)=>r.writeV(i,s,o),unwrap:()=>r}),unwrap:()=>t.unwrap()};return r}const yb=290,wb=1,ld=2e3,bb=100,qr=`${So}-circuit-relay`;BigInt(1<<17);const xs="/libp2p/circuit/relay/0.2.0/hop",cc="/libp2p/circuit/relay/0.2.0/stop",lc=300,Eb=4096,vb=.001;var En;(function(n){(function(r){r.RESERVE="RESERVE",r.CONNECT="CONNECT",r.STATUS="STATUS"})(n.Type||(n.Type={}));let e;(function(r){r[r.RESERVE=0]="RESERVE",r[r.CONNECT=1]="CONNECT",r[r.STATUS=2]="STATUS"})(e||(e={})),function(r){r.codec=()=>Ln(e)}(n.Type||(n.Type={}));let t;n.codec=()=>(t==null&&(t=fe((r,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),r.type!=null&&(s.uint32(8),n.Type.codec().encode(r.type,s)),r.peer!=null&&(s.uint32(18),vn.codec().encode(r.peer,s)),r.reservation!=null&&(s.uint32(26),As.codec().encode(r.reservation,s)),r.limit!=null&&(s.uint32(34),Sn.codec().encode(r.limit,s)),r.status!=null&&(s.uint32(40),Le.codec().encode(r.status,s)),i.lengthDelimited!==!1&&s.ldelim()},(r,s,i={})=>{const o={},a=s==null?r.len:r.pos+s;for(;r.pos<a;){const c=r.uint32();switch(c>>>3){case 1:{o.type=n.Type.codec().decode(r);break}case 2:{o.peer=vn.codec().decode(r,r.uint32(),{limits:i.limits?.peer});break}case 3:{o.reservation=As.codec().decode(r,r.uint32(),{limits:i.limits?.reservation});break}case 4:{o.limit=Sn.codec().decode(r,r.uint32(),{limits:i.limits?.limit});break}case 5:{o.status=Le.codec().decode(r);break}default:{r.skipType(c&7);break}}}return o})),t),n.encode=r=>he(r,n.codec()),n.decode=(r,s)=>de(r,n.codec(),s)})(En||(En={}));var ct;(function(n){(function(r){r.CONNECT="CONNECT",r.STATUS="STATUS"})(n.Type||(n.Type={}));let e;(function(r){r[r.CONNECT=0]="CONNECT",r[r.STATUS=1]="STATUS"})(e||(e={})),function(r){r.codec=()=>Ln(e)}(n.Type||(n.Type={}));let t;n.codec=()=>(t==null&&(t=fe((r,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),r.type!=null&&(s.uint32(8),n.Type.codec().encode(r.type,s)),r.peer!=null&&(s.uint32(18),vn.codec().encode(r.peer,s)),r.limit!=null&&(s.uint32(26),Sn.codec().encode(r.limit,s)),r.status!=null&&(s.uint32(32),Le.codec().encode(r.status,s)),i.lengthDelimited!==!1&&s.ldelim()},(r,s,i={})=>{const o={},a=s==null?r.len:r.pos+s;for(;r.pos<a;){const c=r.uint32();switch(c>>>3){case 1:{o.type=n.Type.codec().decode(r);break}case 2:{o.peer=vn.codec().decode(r,r.uint32(),{limits:i.limits?.peer});break}case 3:{o.limit=Sn.codec().decode(r,r.uint32(),{limits:i.limits?.limit});break}case 4:{o.status=Le.codec().decode(r);break}default:{r.skipType(c&7);break}}}return o})),t),n.encode=r=>he(r,n.codec()),n.decode=(r,s)=>de(r,n.codec(),s)})(ct||(ct={}));var vn;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.id!=null&&t.id.byteLength>0&&(r.uint32(10),r.bytes(t.id)),t.addrs!=null)for(const i of t.addrs)r.uint32(18),r.bytes(i);s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={id:j(0),addrs:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.id=t.bytes();break}case 2:{if(s.limits?.addrs!=null&&i.addrs.length===s.limits.addrs)throw new pt('Decode error - map field "addrs" had too many elements');i.addrs.push(t.bytes());break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(vn||(vn={}));var As;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.expire!=null&&t.expire!==0n&&(r.uint32(8),r.uint64(t.expire)),t.addrs!=null)for(const i of t.addrs)r.uint32(18),r.bytes(i);t.voucher!=null&&(r.uint32(26),Cs.codec().encode(t.voucher,r)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={expire:0n,addrs:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.expire=t.uint64();break}case 2:{if(s.limits?.addrs!=null&&i.addrs.length===s.limits.addrs)throw new pt('Decode error - map field "addrs" had too many elements');i.addrs.push(t.bytes());break}case 3:{i.voucher=Cs.codec().decode(t,t.uint32(),{limits:s.limits?.voucher});break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(As||(As={}));var Sn;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.duration!=null&&(r.uint32(8),r.uint32(t.duration)),t.data!=null&&(r.uint32(16),r.uint64(t.data)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.duration=t.uint32();break}case 2:{i.data=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(Sn||(Sn={}));var Le;(function(n){n.UNUSED="UNUSED",n.OK="OK",n.RESERVATION_REFUSED="RESERVATION_REFUSED",n.RESOURCE_LIMIT_EXCEEDED="RESOURCE_LIMIT_EXCEEDED",n.PERMISSION_DENIED="PERMISSION_DENIED",n.CONNECTION_FAILED="CONNECTION_FAILED",n.NO_RESERVATION="NO_RESERVATION",n.MALFORMED_MESSAGE="MALFORMED_MESSAGE",n.UNEXPECTED_MESSAGE="UNEXPECTED_MESSAGE"})(Le||(Le={}));var uo;(function(n){n[n.UNUSED=0]="UNUSED",n[n.OK=100]="OK",n[n.RESERVATION_REFUSED=200]="RESERVATION_REFUSED",n[n.RESOURCE_LIMIT_EXCEEDED=201]="RESOURCE_LIMIT_EXCEEDED",n[n.PERMISSION_DENIED=202]="PERMISSION_DENIED",n[n.CONNECTION_FAILED=203]="CONNECTION_FAILED",n[n.NO_RESERVATION=204]="NO_RESERVATION",n[n.MALFORMED_MESSAGE=400]="MALFORMED_MESSAGE",n[n.UNEXPECTED_MESSAGE=401]="UNEXPECTED_MESSAGE"})(uo||(uo={}));(function(n){n.codec=()=>Ln(uo)})(Le||(Le={}));var _s;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.relay!=null&&t.relay.byteLength>0&&(r.uint32(10),r.bytes(t.relay)),t.peer!=null&&t.peer.byteLength>0&&(r.uint32(18),r.bytes(t.peer)),t.expiration!=null&&t.expiration!==0n&&(r.uint32(24),r.uint64(t.expiration)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={relay:j(0),peer:j(0),expiration:0n},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.relay=t.bytes();break}case 2:{i.peer=t.bytes();break}case 3:{i.expiration=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(_s||(_s={}));var Cs;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(r.uint32(10),r.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(r.uint32(18),r.bytes(t.payloadType)),t.payload!=null&&(r.uint32(26),_s.codec().encode(t.payload,r)),t.signature!=null&&t.signature.byteLength>0&&(r.uint32(42),r.bytes(t.signature)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={publicKey:j(0),payloadType:j(0),signature:j(0)},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.publicKey=t.bytes();break}case 2:{i.payloadType=t.bytes();break}case 3:{i.payload=_s.codec().decode(t,t.uint32(),{limits:s.limits?.payload});break}case 5:{i.signature=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(Cs||(Cs={}));const se=n=>({match:e=>{const t=e[0];return t==null||t.code!==n||t.value!=null?!1:e.slice(1)}}),U=(n,e)=>({match:t=>{const r=t[0];return r?.code!==n||r.value==null||e!=null&&r.value!==e?!1:t.slice(1)}}),Y=n=>({match:e=>{const t=n.match(e);return t===!1?e:t}}),ke=(...n)=>({match:e=>{let t;for(const r of n){const s=r.match(e);s!==!1&&(t==null||s.length<t.length)&&(t=s)}return t??!1}}),Z=(...n)=>({match:e=>{for(const t of n){const r=t.match(e);if(r===!1)return!1;e=r}return e}});function te(...n){function e(s){if(s==null)return!1;let i=s.getComponents();for(const o of n){const a=o.match(i);if(a===!1)return!1;i=a}return i}function t(s){return e(s)!==!1}function r(s){const i=e(s);return i===!1?!1:i.length===0}return{matchers:n,matches:t,exactMatch:r}}const Sb=U(J),xb=te(Sb),Ys=U(Cr),Xs=U(Rn),Zs=U(Ir),jo=U(_r);te(Ys,Y(U(J)));te(Xs,Y(U(J)));te(Zs,Y(U(J)));te(ke(jo,Zs,Ys,Xs),Y(U(J)));const ud=Z(U(Kt),Y(U(Xo))),dd=Z(Y(U(Ht)),U(qe),Y(U(Xo))),Jo=ke(ud,dd),Wt=ke(Jo,jo,Ys,Xs,Zs),Ab=te(ke(Jo,Z(ke(jo,Zs,Ys,Xs),Y(U(J))))),uc=te(ud),dc=te(dd);te(Jo);const ea=Z(Wt,U(ht)),Tr=Z(Wt,U(vs)),Is=te(Z(ea,Y(U(J))));te(Tr);const ta=Z(Tr,se(ju),Y(U(J))),js=Z(Tr,se(Ju),Y(U(J))),_b=ke(ta,js);te(ta);const Cb=te(js),ho=ke(Wt,ea,Tr,ta,js),hd=ke(Z(ho,se(Zo),Y(U(J)))),hr=te(hd),fd=ke(Z(ho,se(td),Y(U(J))),Z(ho,se(ln),Y(U(Zu)),se(Zo),Y(U(J)))),Ts=te(fd),pd=Z(Tr,se(nd),Y(U(lr)),Y(U(lr)),Y(U(J))),hc=te(pd),gd=Z(js,se(ed),Y(U(lr)),Y(U(lr)),Y(U(J))),fc=te(gd),Ps=ke(hd,fd,Z(ea,Y(U(J))),Z(_b,Y(U(J))),Z(Wt,Y(U(J))),pd,gd,U(J)),md=te(Ps),Ib=Z(Ps,se(Gt),U(J)),fr=te(Ib),Tb=ke(Z(Ps,se(Gt),se(es),Y(U(J))),Z(Ps,se(es),Y(U(J))),Z(se(es),Y(U(J)))),fo=te(Tb),Pb=ke(Z(Wt,U(ht),se(un),Y(U(J))),Z(Wt,se(un),Y(U(J))));te(Pb);const Db=Z(Wt,ke(Z(U(ht,"443"),se(un)),Z(U(ht),se(lo)),Z(U(ht),se(ln),se(un)),Z(se(ln),se(un)),se(ln),se(lo)),Y(U(J)));te(Db);const Lb=ke(Z(U(rd),Y(U(J))));te(Lb);const kb=ke(Z(U(Xu),Y(U(J))));te(kb);function Tt(n){const e=new globalThis.AbortController;function t(){e.abort();for(const i of n)i?.removeEventListener!=null&&i.removeEventListener("abort",t)}for(const i of n){if(i?.aborted===!0){t();break}i?.addEventListener!=null&&i.addEventListener("abort",t)}function r(){for(const i of n)i?.removeEventListener!=null&&i.removeEventListener("abort",t)}const s=e.signal;return s.clear=r,s}class pc extends Error{static name="HadEnoughRelaysError";name="HadEnoughRelaysError"}class Rb extends Error{static name="DoubleRelayError";name="DoubleRelayError"}class Mb extends Error{static name="RelayQueueFullError";name="RelayQueueFullError"}function gc(n){const e=n*BigInt(1e3),t=new Date().getTime();return Number(e-BigInt(t))}class mc{expires;bytes;constructor(e){e?.duration!=null&&e?.duration!==0&&(this.expires=Date.now()+e.duration*1e3),this.bytes=e?.data,this.bytes===0n&&(this.bytes=void 0),this.onData=this.onData.bind(this)}onData(e){this.bytes!=null&&(this.bytes-=BigInt(e.byteLength),this.bytes<0n&&(this.bytes=0n))}getLimits(){if(this.expires==null&&this.bytes==null)return;const e={};if(this.bytes!=null){const t=this;Object.defineProperty(e,"bytes",{get(){return t.bytes}})}if(this.expires!=null){const t=this;Object.defineProperty(e,"seconds",{get(){return Math.round(((t.expires??0)-Date.now())/1e3)}})}return e}}const yd=te(Z(md.matchers[0],se(Gt))),wd=te(se(Gt));function nr(n,e){const t={[Symbol.iterator]:()=>t,next:()=>{const r=n.next(),s=r.value;return r.done===!0||s==null?{done:!0,value:void 0}:{done:!1,value:e(s)}}};return t}function Ei(n){const e=yr(ge.decode(`z${n}`));return Sr(e)}class Mn{map;constructor(e){if(this.map=new Map,e!=null)for(const[t,r]of e.entries())this.map.set(t.toString(),{key:t,value:r})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(e){return this.map.delete(e.toString())}entries(){return nr(this.map.entries(),e=>[e[1].key,e[1].value])}forEach(e){this.map.forEach((t,r)=>{e(t.value,t.key,this)})}get(e){return this.map.get(e.toString())?.value}has(e){return this.map.has(e.toString())}set(e,t){this.map.set(e.toString(),{key:e,value:t})}keys(){return nr(this.map.values(),e=>e.key)}values(){return nr(this.map.values(),e=>e.value)}get size(){return this.map.size}}class dn{set;constructor(e){if(this.set=new Set,e!=null)for(const t of e)this.set.add(t.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(e){this.set.add(e.toString())}clear(){this.set.clear()}delete(e){this.set.delete(e.toString())}entries(){return nr(this.set.entries(),e=>{const t=Ei(e[0]);return[t,t]})}forEach(e){this.set.forEach(t=>{const r=Ei(t);e(r,r,this)})}has(e){return this.set.has(e.toString())}values(){return nr(this.set.values(),e=>Ei(e))}intersection(e){const t=new dn;for(const r of e)this.has(r)&&t.add(r);return t}difference(e){const t=new dn;for(const r of this)e.has(r)||t.add(r);return t}union(e){const t=new dn;for(const r of e)t.add(r);for(const r of this)t.add(r);return t}}const na={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},bd={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},Ed=new globalThis.TextEncoder;function Nb(n,e){const t=na[e];let r=bd[e];for(let s=0;s<n.length;s++)r^=BigInt(n[s]),r=BigInt.asUintN(e,r*t);return r}function Ob(n,e,t){if(t.length===0)throw new Error("The `utf8Buffer` option must have a length greater than zero");const r=na[e];let s=bd[e],i=n;for(;i.length>0;){const o=Ed.encodeInto(i,t);i=i.slice(o.read);for(let a=0;a<o.written;a++)s^=BigInt(t[a]),s=BigInt.asUintN(e,s*r)}return s}function Fb(n,{size:e=32,utf8Buffer:t}={}){if(!na[e])throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if(typeof n=="string"){if(t)return Ob(n,e,t);n=Ed.encode(n)}return Nb(n,e)}const ra={hash:n=>Number(Fb(n,{size:32})),hashV:(n,e)=>Ub(ra.hash(n,e))};function Ub(n){let e=n.toString(16);return e.length%2===1&&(e=`0${e}`),$(e,"base16")}const vd=64;class Rt{fp;h;seed;constructor(e,t,r,s=2){if(s>vd)throw new TypeError("Invalid Fingerprint Size");const i=t.hashV(e,r),o=j(s);for(let a=0;a<o.length;a++)o[a]=i[a];o.length===0&&(o[0]=7),this.fp=o,this.h=t,this.seed=r}hash(){return this.h.hash(this.fp,this.seed)}equals(e){return e?.fp instanceof Uint8Array?Te(this.fp,e.fp):!1}}function Ds(n,e){return Math.floor(Math.random()*(e-n))+n}class Kr{contents;constructor(e){this.contents=new Array(e).fill(null)}has(e){if(!(e instanceof Rt))throw new TypeError("Invalid Fingerprint");return this.contents.some(t=>e.equals(t))}add(e){if(!(e instanceof Rt))throw new TypeError("Invalid Fingerprint");for(let t=0;t<this.contents.length;t++)if(this.contents[t]==null)return this.contents[t]=e,!0;return!0}swap(e){if(!(e instanceof Rt))throw new TypeError("Invalid Fingerprint");const t=Ds(0,this.contents.length-1),r=this.contents[t];return this.contents[t]=e,r}remove(e){if(!(e instanceof Rt))throw new TypeError("Invalid Fingerprint");const t=this.contents.findIndex(r=>e.equals(r));return t>-1?(this.contents[t]=null,!0):!1}}const Bb=500;class yc{bucketSize;filterSize;fingerprintSize;buckets;count;hash;seed;constructor(e){this.filterSize=e.filterSize,this.bucketSize=e.bucketSize??4,this.fingerprintSize=e.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=e.hash??ra,this.seed=e.seed??Ds(0,Math.pow(2,10))}add(e){typeof e=="string"&&(e=$(e));const t=new Rt(e,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(e,this.seed)%this.filterSize,s=(r^t.hash())%this.filterSize;if(this.buckets[r]==null&&(this.buckets[r]=new Kr(this.bucketSize)),this.buckets[s]==null&&(this.buckets[s]=new Kr(this.bucketSize)),this.buckets[r].add(t)||this.buckets[s].add(t))return this.count++,!0;const i=[r,s];let o=i[Ds(0,i.length-1)];this.buckets[o]==null&&(this.buckets[o]=new Kr(this.bucketSize));for(let a=0;a<Bb;a++){const c=this.buckets[o].swap(t);if(c!=null&&(o=(o^c.hash())%this.filterSize,this.buckets[o]==null&&(this.buckets[o]=new Kr(this.bucketSize)),this.buckets[o].add(c)))return this.count++,!0}return!1}has(e){typeof e=="string"&&(e=$(e));const t=new Rt(e,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(e,this.seed)%this.filterSize,s=this.buckets[r]?.has(t)??!1;if(s)return s;const i=(r^t.hash())%this.filterSize;return this.buckets[i]?.has(t)??!1}remove(e){typeof e=="string"&&(e=$(e));const t=new Rt(e,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(e,this.seed)%this.filterSize,s=this.buckets[r]?.remove(t)??!1;if(s)return this.count--,s;const i=(r^t.hash())%this.filterSize,o=this.buckets[i]?.remove(t)??!1;return o&&this.count--,o}get reliable(){return Math.floor(100*(this.count/this.filterSize))<=90}}const $b={1:.5,2:.84,4:.95,8:.98};function zb(n=.001){return n>.002?2:n>1e-5?4:8}function qb(n,e=.001){const t=zb(e),r=$b[t],s=Math.round(n/r),i=Math.min(Math.ceil(Math.log2(1/e)+Math.log2(2*t)),vd);return{filterSize:s,bucketSize:t,fingerprintSize:i}}class Kb{filterSize;bucketSize;fingerprintSize;scale;filterSeries;hash;seed;constructor(e){this.bucketSize=e.bucketSize??4,this.filterSize=e.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=e.fingerprintSize??2,this.scale=e.scale??2,this.hash=e.hash??ra,this.seed=e.seed??Ds(0,Math.pow(2,10)),this.filterSeries=[new yc({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(e){if(typeof e=="string"&&(e=$(e)),this.has(e))return!0;let t=this.filterSeries.find(r=>r.reliable);if(t==null){const r=this.filterSize*Math.pow(this.scale,this.filterSeries.length);t=new yc({filterSize:r,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(t)}return t.add(e)}has(e){typeof e=="string"&&(e=$(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].has(e))return!0;return!1}remove(e){typeof e=="string"&&(e=$(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].remove(e))return!0;return!1}get count(){return this.filterSeries.reduce((e,t)=>e+t.count,0)}}function pr(n,e=.001,t){return new Kb({...qb(n,e)})}class Wb{filter;constructor(e,t){this.filter=pr(e,t)}has(e){return this.filter.has(e.toMultihash().bytes)}add(e){this.filter.add(e.toMultihash().bytes)}remove(e){this.filter.remove?.(e.toMultihash().bytes)}}function Vb(n,e=.001){return new Wb(n,e)}class Hb extends Mn{metric;constructor(e){super();const{name:t,metrics:r}=e;this.metric=r.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){const t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function Gb(n){const{name:e,metrics:t}=n;let r;return t!=null?r=new Hb({name:e,metrics:t}):r=new Mn,r}function wc(n){const{stream:e,remoteAddr:t,logger:r,onDataRead:s,onDataWrite:i}=n,o=r.forComponent("libp2p:stream:converter");let a=!1,c=!1;const u=e.close.bind(e);e.close=async g=>{await u(g),p(!0)};const l=e.abort.bind(e);e.abort=g=>{l(g),p(!0)};const d=e.sink.bind(e);e.sink=async g=>{try{await d(Au(g,m=>Wu(m,f=>i?.(f))))}catch(m){m.type!=="aborted"&&o.error("%s error in sink",t,m)}finally{c=!0,p()}};const h={log:o,sink:e.sink,source:async function*(){try{for await(const g of e.source)s?.(g),yield g}finally{a=!0,p()}}(),remoteAddr:t,timeline:{open:Date.now(),close:void 0},close:e.close,abort:e.abort};function p(g){g===!0&&(a=!0,c=!0),a&&c&&h.timeline.close==null&&(h.timeline.close=Date.now())}return h}class ee extends Event{type;detail;constructor(e,t){super(e),this.type=e,this.detail=t}}let xn=class extends Error{static name="AbortError";name="AbortError";constructor(e="The operation was aborted",...t){super(e,...t)}};async function ft(n,e,t,r){const s=new xn(r?.errorMessage);r?.errorCode!=null&&(s.code=r.errorCode);const i=r?.errorEvent??"error";return t?.aborted===!0?Promise.reject(s):new Promise((o,a)=>{function c(){Si(t,"abort",d),Si(n,e,u),Si(n,i,l)}const u=h=>{try{if(r?.filter?.(h)===!1)return}catch(p){c(),a(p);return}c(),o(h)},l=h=>{if(c(),h instanceof Error){a(h);return}a(h.detail??r?.error??new Error(`The "${r?.errorEvent}" event was emitted but the event had no '.detail' field. Pass an 'error' option to race-event to change this message.`))},d=()=>{c(),a(s)};vi(t,"abort",d),vi(n,e,u),vi(n,i,l)})}function vi(n,e,t){n!=null&&(Sd(n)?n.addListener(e,t):n.addEventListener(e,t))}function Si(n,e,t){n!=null&&(Sd(n)?n.removeListener(e,t):n.removeEventListener(e,t))}function Sd(n){return typeof n.on=="function"&&typeof n.emit=="function"}function Ls(n,e){let t;const r=function(){const s=function(){t=void 0,n()};clearTimeout(t),t=setTimeout(s,e)};return r.start=()=>{},r.stop=()=>{clearTimeout(t)},r}class Qb extends Error{remainingPoints;msBeforeNext;consumedPoints;isFirstInDuration;constructor(e="Rate limit exceeded",t){super(e),this.name="RateLimitError",this.remainingPoints=t.remainingPoints,this.msBeforeNext=t.msBeforeNext,this.consumedPoints=t.consumedPoints,this.isFirstInDuration=t.isFirstInDuration}}let Yb=class extends Error{static name="QueueFullError";constructor(e="The queue was full"){super(e),this.name="QueueFullError"}},Xb=class{deferred;signal;constructor(e){this.signal=e,this.deferred=V(),this.onAbort=this.onAbort.bind(this),this.signal?.addEventListener("abort",this.onAbort)}onAbort(){this.deferred.reject(this.signal?.reason??new Ft)}cleanup(){this.signal?.removeEventListener("abort",this.onAbort)}};function Zb(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}let jb=class{id;fn;options;recipients;status;timeline;controller;constructor(e,t){this.id=Zb(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,r)=>t&&r.signal?.aborted===!0,!0)&&(this.controller.abort(new Ft),this.cleanup())}async join(e={}){const t=new Xb(e.signal);return this.recipients.push(t),e.signal?.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await oe(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{e.cleanup(),e.signal?.removeEventListener("abort",this.onAbort)})}},xd=class extends tt{concurrency;maxSize;queue;pending;sort;constructor(e={}){super(),this.concurrency=e.concurrency??Number.POSITIVE_INFINITY,this.maxSize=e.maxSize??Number.POSITIVE_INFINITY,this.pending=0,e.metricName!=null&&e.metrics?.registerMetricGroup(e.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})}),this.sort=e.sort,this.queue=[],this.emitEmpty=Ls(this.emitEmpty.bind(this),1),this.emitIdle=Ls(this.emitIdle.bind(this),1)}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(const t of this.queue)if(t.status==="queued"){e=t;break}return e==null?!1:(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let t=0;t<this.queue.length;t++)if(this.queue[t]===e){this.queue.splice(t,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")}),!0)}return!1}enqueue(e){this.queue.push(e),this.sort!=null&&this.queue.sort(this.sort)}async add(e,t){if(t?.signal?.throwIfAborted(),this.size===this.maxSize)throw new Yb;const r=new jb(e,t);return this.enqueue(r),this.safeDispatchEvent("add"),this.tryToStartAnother(),r.join(t).then(s=>(this.safeDispatchEvent("completed",{detail:s}),this.safeDispatchEvent("success",{detail:{job:r,result:s}}),s)).catch(s=>{if(r.status==="queued"){for(let i=0;i<this.queue.length;i++)if(this.queue[i]===r){this.queue.splice(i,1);break}}throw this.safeDispatchEvent("error",{detail:s}),this.safeDispatchEvent("failure",{detail:{job:r,error:s}}),s})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new Ft)}),this.clear()}async onEmpty(e){this.size!==0&&await ft(this,"empty",e?.signal)}async onSizeLessThan(e,t){this.size<e||await ft(this,"next",t?.signal,{filter:()=>this.size<e})}async onIdle(e){this.pending===0&&this.size===0||await ft(this,"idle",e?.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){e?.signal?.throwIfAborted();const t=kn({objectMode:!0}),r=c=>{c!=null?this.abort():this.clear(),t.end(c)},s=c=>{c.detail!=null&&t.push(c.detail)},i=c=>{r(c.detail)},o=()=>{r()},a=()=>{r(new Ft("Queue aborted"))};this.addEventListener("completed",s),this.addEventListener("error",i),this.addEventListener("idle",o),e?.signal?.addEventListener("abort",a);try{yield*t}finally{this.removeEventListener("completed",s),this.removeEventListener("error",i),this.removeEventListener("idle",o),e?.signal?.removeEventListener("abort",a),r()}}};class sa extends xd{has(e){return this.find(e)!=null}find(e){return this.queue.find(t=>e.equals(t.options.peerId))}}class Jb extends tt{components;started;running;topologyId;log;discoveryController;filter;queue;constructor(e,t={}){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:discover-relays"),this.components=e,this.started=!1,this.running=!1,this.filter=t.filter,this.discoveryController=new AbortController,this.discoveryController.signal,this.dialPeer=this.dialPeer.bind(this),this.onPeer=this.onPeer.bind(this)}isStarted(){return this.started}async start(){this.topologyId=await this.components.registrar.register(xs,{filter:this.filter,onConnect:e=>{this.log.trace("discovered relay %p queue (length: %d, active %d)",e,this.queue?.size,this.queue?.running),this.safeDispatchEvent("relay:discover",{detail:e})}}),this.started=!0}stop(){this.topologyId!=null&&this.components.registrar.unregister(this.topologyId),this.running&&this.stopDiscovery(),this.started=!1}startDiscovery(){this.running||(this.log("start discovery"),this.running=!0,this.discoveryController=new AbortController,this.discoveryController.signal,this.components.events.addEventListener("peer:discovery",this.onPeer),Promise.resolve().then(async()=>{this.log("searching peer store for relays");const e=await this.components.peerStore.all({filters:[r=>r.protocols.includes(xs)],orders:[()=>Math.random()<.5?1:-1,(r,s)=>{const i=bc(r),o=bc(s);return i>o?-1:o>i?1:0}]});for(const r of e)this.log.trace("found relay peer %p in peer store",r.id),this.safeDispatchEvent("relay:discover",{detail:r.id});this.log("found %d relay peers in peer store",e.length);const t=this.queue=new sa({concurrency:5});this.log("start random walk");for await(const r of this.components.randomWalk.walk({signal:this.discoveryController.signal})){if(this.log.trace("found random peer %p",r.id),t.has(r.id)){this.log.trace("random peer %p was already in queue",r.id);continue}if(this.components.connectionManager.getConnections(r.id)?.length>0){this.log.trace("random peer %p was already connected",r.id);continue}if(!await this.components.connectionManager.isDialable(r.multiaddrs)){this.log.trace("random peer %p was not dialable",r.id,r.multiaddrs.map(s=>s.toString()));continue}t.queued>10&&(this.log.trace("wait for space in queue for %p",r.id),await t.onSizeLessThan(10,{signal:this.discoveryController.signal})),this.log("adding random peer %p to dial queue (length: %d, active %d)",r.id,t.size,t.running),t.add(this.dialPeer,{peerId:r.id,signal:this.discoveryController.signal}).catch(s=>{this.log.error("error opening connection to random peer %p",r.id,s)})}this.log("stop random walk"),await t.onIdle()}).catch(e=>{this.discoveryController.signal.aborted||this.log.error("failed when finding relays on the network",e)}))}stopDiscovery(){this.log("stop discovery"),this.running=!1,this.discoveryController?.abort(),this.queue?.clear(),this.components.events.removeEventListener("peer:discovery",this.onPeer)}onPeer(e){this.log.trace("maybe dialing discovered peer %p - %e",e.detail.id),this.maybeDialPeer(e).catch(t=>{this.log.trace("error dialing discovered peer %p - %e",e.detail.id,t)})}async maybeDialPeer(e){if(this.queue==null)return;const t=e.detail.id,r=e.detail.multiaddrs;if(this.queue.has(t)){this.log.trace("random peer %p was already in queue",t);return}if(this.components.connectionManager.getConnections(t)?.length>0){this.log.trace("random peer %p was already connected",t);return}if(!await this.components.connectionManager.isDialable(r)){this.log.trace("random peer %p was not dialable",t);return}this.queue?.add(this.dialPeer,{peerId:e.detail.id,signal:this.discoveryController.signal}).catch(s=>{this.log.error("error opening connection to discovered peer %p",e.detail.id,s)})}async dialPeer({peerId:e,signal:t}){const r=Tt([AbortSignal.timeout(5e3),t]);try{await this.components.connectionManager.openConnection(e,{signal:r})}finally{r.clear()}}}function bc(n){const e=n.metadata.get("last-dial-success");return e==null?0:new Date(q(e)).getTime()}class e0 extends tt{connectionManager;addressManager;reservationStore;listeningAddrs;log;listenTimeout;reservationId;relay;constructor(e,t={}){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:transport:listener"),this.connectionManager=e.connectionManager,this.addressManager=e.addressManager,this.reservationStore=e.reservationStore,this.listeningAddrs=[],this.listenTimeout=t.listenTimeout??ld,this.reservationStore.addEventListener("relay:removed",this._onRemoveRelayPeer),this.reservationStore.addEventListener("relay:created-reservation",this._onAddRelayPeer)}_onRemoveRelayPeer=e=>{this.log("relay removed %p our relay %p",e.detail.relay,this.relay,this.relay?.equals(e.detail.relay)),this.relay?.equals(e.detail.relay)===!0&&(this.log("relay peer removed %p",e.detail.relay),this.listeningAddrs.forEach(t=>{this.addressManager.removeObservedAddr(t)}),this.listeningAddrs=[],this.safeDispatchEvent("listening"))};_onAddRelayPeer=e=>{const{details:t}=e.detail;t.type!=="configured"&&t.id===this.reservationId&&this.addedRelay(e.detail)};async listen(e){if(wd.exactMatch(e))this.log("searching for circuit relay servers"),this.reservationId=this.reservationStore.reserveRelay();else if(yd.exactMatch(e)){this.log("listen on specific relay server %a",e);const t=AbortSignal.timeout(this.listenTimeout),r=e.decapsulate("/p2p-circuit"),s=await this.connectionManager.openConnection(r,{signal:t});if(!this.reservationStore.hasReservation(s.remotePeer)){this.log("making reservation on peer %p",s.remotePeer);const i=await this.reservationStore.addRelay(s.remotePeer,"configured");this.addedRelay(i)}}else throw new Vi(`Could not listen on p2p-circuit address "${e}"`)}getAddrs(){return[...this.listeningAddrs.values()].flat()}updateAnnounceAddrs(){}async close(){this.reservationStore.cancelReservations(),this.listeningAddrs=[],this.reservationStore.removeEventListener("relay:removed",this._onRemoveRelayPeer),queueMicrotask(()=>{this.safeDispatchEvent("close")})}addedRelay(e){this.log("relay peer added %p",e.relay),this.relay=e.relay,this.listeningAddrs=e.details.reservation.addrs.map(t=>K(t).encapsulate("/p2p-circuit")),this.listeningAddrs.forEach(t=>{this.addressManager.confirmObservedAddr(t,{type:"transport"})}),queueMicrotask(()=>{this.safeDispatchEvent("listening")})}}function t0(n){return new e0(n)}const n0="useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";let r0=(n=21)=>{let e="",t=crypto.getRandomValues(new Uint8Array(n|=0));for(;n--;)e+=n0[t[n]&63];return e};const s0=60*1e3*10,i0=60*1e3*5,o0=30*1e3;class a0 extends tt{peerId;connectionManager;peerStore;events;reserveQueue;reservations;pendingReservations;maxReservationQueueLength;reservationCompletionTimeout;started;log;relayFilter;constructor(e,t){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:transport:reservation-store"),this.peerId=e.peerId,this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.reservations=new Mn,this.pendingReservations=[],this.maxReservationQueueLength=t?.maxReservationQueueLength??bb,this.reservationCompletionTimeout=t?.reservationCompletionTimeout??ld,this.started=!1,this.relayFilter=pr(100),this.reserveQueue=new sa({concurrency:t?.reservationConcurrency??wb,metricName:"libp2p_relay_reservation_queue",metrics:e.metrics}),this.events.addEventListener("connection:close",r=>{[...this.reservations.values()].find(i=>i.connection===r.detail.id)!=null&&this.#n(r.detail.remotePeer).catch(i=>{this.log("could not remove relay %p - %e",r.detail,i)})})}isStarted(){return this.started}start(){this.started=!0}afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[t=>t.tags.has(qr)]});this.log("removing tag from %d old relays",e.length),await Promise.all(e.map(async t=>{await this.peerStore.merge(t.id,{tags:{[qr]:void 0}})})),this.log("redialing %d old relays",e.length),await Promise.all(e.map(async t=>this.addRelay(t.id,"discovered"))),this.#t()}).catch(e=>{this.log.error(e)})}stop(){this.reserveQueue.clear(),this.reservations.forEach(({timeout:e})=>{clearTimeout(e)}),this.reservations.clear(),this.started=!1}reserveRelay(){const e=r0();return this.pendingReservations.push(e),this.#t(),e}async addRelay(e,t){if(this.peerId.equals(e))throw this.log.trace("not trying to use self as relay"),new Vi("Cannot use self as relay");if(this.reserveQueue.size>this.maxReservationQueueLength)throw new Mb("The reservation queue is full");const r=this.reserveQueue.find(e);if(r!=null)return this.log.trace("potential relay peer %p is already in the reservation queue",e),r.join();if(this.relayFilter.has(e.toMultihash().bytes))throw new Vi("The relay was previously invalid");return this.log.trace("try to reserve relay slot with %p",e),this.reserveQueue.add(async()=>{const s=Date.now();try{const i=this.reservations.get(e);if(i!=null){const g=this.connectionManager.getConnections(e);let m=!1;if(g.length===0&&this.log("already have relay reservation with %p but we are no longer connected",e),g.map(f=>f.id).includes(i.connection)&&(this.log("already have relay reservation with %p and the original connection is still open",e),m=!0),m&&gc(i.reservation.expire)>s0)return this.log("already have relay reservation with %p but we are still connected and it does not expire soon",e),{relay:e,details:i};await this.#n(e)}if(t==="discovered"&&this.pendingReservations.length===0)throw new pc("Not making reservation on discovered relay because we do not need any more relays");const o=AbortSignal.timeout(this.reservationCompletionTimeout);const a=await this.connectionManager.openConnection(e,{signal:o});if(fr.matches(a.remoteAddr))throw new Rb("not creating reservation over relayed connection");const c=await this.#e(a,{signal:o}),u=gc(c.expire);this.log("created reservation on relay peer %p, expiry date is %s",e,new Date(Date.now()+u).toString());const l=Math.min(Math.max(u-i0,o0),Math.pow(2,31)-1),d=setTimeout(()=>{this.log("refresh reservation to relay %p",e),this.addRelay(e,t).catch(async g=>{this.log.error("could not refresh reservation to relay %p - %e",e,g),await this.#n(e)}).catch(g=>{this.log.error("could not remove expired reservation to relay %p - %e",e,g)})},l);let h;if(t==="discovered"){const g=this.pendingReservations.pop();if(g==null)throw new pc("Made reservation on relay but did not need any more discovered relays");h={timeout:d,reservation:c,type:t,connection:a.id,id:g}}else h={timeout:d,reservation:c,type:t,connection:a.id};this.reservations.set(e,h),await this.peerStore.merge(e,{tags:{[qr]:{value:1,ttl:u}}}),this.#t();const p={relay:e,details:h};return this.safeDispatchEvent("relay:created-reservation",{detail:p}),p}catch(i){throw t==="discovered"&&i.name==="HadEnoughRelaysError"||this.log.error("could not reserve slot on %p after %dms - %e",e,Date.now()-s,i),(i.name==="DialError"||i.name==="UnsupportedProtocolError")&&this.relayFilter.add(e.toMultihash().bytes),this.#n(e).catch(o=>{this.log.error("could not remove reservation on %p after reserving slot failed - %e",e,o)}),i}},{peerId:e})}hasReservation(e){return this.reservations.has(e)}getReservation(e){return this.reservations.get(e)?.reservation}reservationCount(e){return e==null?this.reservations.size:[...this.reservations.values()].reduce((t,r)=>(r.type===e&&t++,t),0)}cancelReservations(){[...this.reservations.values()].forEach(e=>{clearTimeout(e.timeout)}),this.reservations.clear()}async#e(e,t){t.signal?.throwIfAborted(),this.log("requesting reservation from %p",e.remotePeer);const r=await e.newStream(xs,t),i=mt(r).pb(En);this.log.trace("send RESERVE to %p",e.remotePeer),await i.write({type:En.Type.RESERVE},t);let o;try{this.log.trace("reading response from %p",e.remotePeer),o=await i.read(t)}catch(c){throw r.abort(c),c}finally{r.status!=="closed"&&await r.close(t)}if(this.log.trace("read response %o",o),o.status===Le.OK&&o.reservation!=null){const c=new Set;c.add(e.remoteAddr.toString());for(const u of o.reservation.addrs){let l=K(u);l.getPeerId()==null&&(l=l.encapsulate(`/p2p/${e.remotePeer}`)),l=K(l.toString().replace(`/p2p/${e.remotePeer}/p2p/${e.remotePeer}`,`/p2p/${e.remotePeer}`)),c.add(l.toString())}return o.reservation.addrs=[...c].map(u=>K(u).bytes),o.reservation}const a=`reservation failed with status ${o.status??"undefined"}`;throw this.log.error(a),new Error(a)}async#n(e){const t=this.reservations.get(e);t!=null&&(this.log("removing relay reservation with %p from local store",e),clearTimeout(t.timeout),this.reservations.delete(e),t.type==="discovered"&&this.pendingReservations.push(t.id),await this.peerStore.merge(e,{tags:{[qr]:void 0}}),this.safeDispatchEvent("relay:removed",{detail:{relay:e,details:t}}),this.#t())}#t(){if(this.pendingReservations.length===0){this.log.trace("have discovered enough relays"),this.reserveQueue.clear(),this.safeDispatchEvent("relay:found-enough-relays");return}this.relayFilter=pr(100),this.log("not discovered enough relays %d/%d",this.reservations.size,this.pendingReservations.length),this.safeDispatchEvent("relay:not-enough-relays")}}const c0=n=>{if(n.peer==null)return!1;try{n.peer.addrs.forEach(K)}catch{return!1}return!0},Ec={maxInboundStopStreams:lc,maxOutboundStopStreams:lc};class l0{discovery;registrar;peerStore;connectionManager;transportManager;peerId;upgrader;addressManager;connectionGater;reservationStore;logger;maxInboundStopStreams;maxOutboundStopStreams;started;log;shutdownController;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:circuit-relay:transport"),this.registrar=e.registrar,this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.transportManager=e.transportManager,this.logger=e.logger,this.peerId=e.peerId,this.upgrader=e.upgrader,this.addressManager=e.addressManager,this.connectionGater=e.connectionGater,this.maxInboundStopStreams=t.maxInboundStopStreams??Ec.maxInboundStopStreams,this.maxOutboundStopStreams=t.maxOutboundStopStreams??Ec.maxOutboundStopStreams,this.shutdownController=new AbortController,this.discovery=new Jb(e,{filter:t.discoveryFilter??Vb(Eb,vb)}),this.discovery.addEventListener("relay:discover",r=>{this.reservationStore.addRelay(r.detail,"discovered").catch(s=>{s.name!=="HadEnoughRelaysError"&&s.name!=="RelayQueueFullError"&&this.log.error("could not add discovered relay %p",r.detail,s)})}),this.reservationStore=new a0(e,t),this.reservationStore.addEventListener("relay:not-enough-relays",()=>{this.discovery?.startDiscovery()}),this.reservationStore.addEventListener("relay:found-enough-relays",()=>{this.discovery?.stopDiscovery()}),this.started=!1}[Symbol.toStringTag]="@libp2p/circuit-relay-v2-transport";[Qe]=["@libp2p/transport","@libp2p/circuit-relay-v2-transport"];get[ns](){return this.discovery!=null?["@libp2p/identify"]:[]}[xo]=!0;isStarted(){return this.started}async start(){this.shutdownController=new AbortController,this.shutdownController.signal,await this.registrar.handle(cc,e=>{const t=this.upgrader.createInboundAbortSignal(this.shutdownController.signal);this.onStop(e,t).catch(r=>{this.log.error("error while handling STOP protocol",r),e.stream.abort(r)}).finally(()=>{t.clear()})},{maxInboundStreams:this.maxInboundStopStreams,maxOutboundStreams:this.maxOutboundStopStreams,runOnLimitedConnection:!0}),await Sl(this.discovery,this.reservationStore),this.started=!0}async stop(){this.shutdownController.abort(),await xl(this.discovery,this.reservationStore),await this.registrar.unhandle(cc),this.started=!1}async dial(e,t){if(e.protoCodes().filter(p=>p===yb).length!==1){const p="Invalid circuit relay address";throw this.log.error(p,e),new Yn(p)}const r=e.toString().split("/p2p-circuit"),s=K(r[0]),i=K(r[r.length-1]),o=s.getPeerId(),a=i.getPeerId();if(o==null||a==null){const p=`ircuit relay dial to ${e.toString()} failed as address did not have both relay and destination PeerIDs`;throw this.log.error(`c${p}`),new Yn(`C${p}`)}const c=gt(o),u=gt(a);let d=this.connectionManager.getConnections(c)[0];d==null?(await this.peerStore.merge(c,{multiaddrs:[s]}),t.onProgress?.(new ee("circuit-relay:open-connection")),d=await this.connectionManager.openConnection(c,t)):t.onProgress?.(new ee("circuit-relay:reuse-connection"));let h;try{t.onProgress?.(new ee("circuit-relay:open-hop-stream")),h=await d.newStream(xs,t);const p=mt(h),g=p.pb(En);t.onProgress?.(new ee("circuit-relay:write-connect-message")),await g.write({type:En.Type.CONNECT,peer:{id:u.toMultihash().bytes,addrs:[K(i).bytes]}},t),t.onProgress?.(new ee("circuit-relay:read-connect-response"));const m=await g.read(t);if(m.status!==Le.OK)throw new je(`failed to connect via relay with status ${m?.status?.toString()??"undefined"}`);const f=new mc(m.limit),w=wc({stream:p.unwrap(),remoteAddr:e,localAddr:s.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`),logger:this.logger,onDataRead:f.onData,onDataWrite:f.onData});return this.log("new outbound relayed connection %a",w.remoteAddr),await this.upgrader.upgradeOutbound(w,{...t,limits:f.getLimits()})}catch(p){throw this.log.error("circuit relay dial to destination %p via relay %p failed",u,c,p),h?.abort(p),p}}createListener(e){return t0({peerId:this.peerId,connectionManager:this.connectionManager,addressManager:this.addressManager,reservationStore:this.reservationStore,logger:this.logger})}listenFilter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>yd.exactMatch(t)||wd.exactMatch(t))}dialFilter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>fr.exactMatch(t))}async onStop({connection:e,stream:t},r){if(!this.reservationStore.hasReservation(e.remotePeer))try{this.log("dialed via relay we did not have a reservation on, start listening on that relay address"),await this.transportManager.listen([e.remoteAddr.encapsulate("/p2p-circuit")])}catch(l){this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on",l)}const s=mt(t).pb(ct),i=await s.read({signal:r});if(this.log("new circuit relay v2 stop stream from %p with type %s",e.remotePeer,i.type),i?.type===void 0){this.log.error("type was missing from circuit v2 stop protocol request from %s",e.remotePeer),await s.write({type:ct.Type.STATUS,status:Le.MALFORMED_MESSAGE},{signal:r}),await t.close();return}if(i.type!==ct.Type.CONNECT){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await s.write({type:ct.Type.STATUS,status:Le.UNEXPECTED_MESSAGE},{signal:r}),await t.close();return}if(!c0(i)){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await s.write({type:ct.Type.STATUS,status:Le.MALFORMED_MESSAGE},{signal:r}),await t.close({signal:r});return}const o=Sr(yr(i.peer.id));if(await this.connectionGater.denyInboundRelayedConnection?.(e.remotePeer,o)===!0){this.log.error("connection gater denied inbound relayed connection from %p",e.remotePeer),await s.write({type:ct.Type.STATUS,status:Le.PERMISSION_DENIED},{signal:r}),await t.close({signal:r});return}this.log.trace("sending success response to %p",e.remotePeer),await s.write({type:ct.Type.STATUS,status:Le.OK},{signal:r});const a=new mc(i.limit),c=e.remoteAddr.encapsulate(`/p2p-circuit/p2p/${o.toString()}`);this.addressManager.getAddresses()[0];const u=wc({stream:s.unwrap().unwrap(),remoteAddr:c,logger:this.logger,onDataRead:a.onData,onDataWrite:a.onData});this.log("new inbound relayed connection %a",u.remoteAddr),await this.upgrader.upgradeInbound(u,{limits:a.getLimits(),signal:r}),this.log("%s connection %a upgraded","inbound",u.remoteAddr)}}function u0(n={}){return e=>new l0(e,n)}function d0(n){return n[Symbol.asyncIterator]!=null}function po(n){if(d0(n))return(async()=>{for await(const e of n);})();for(const e of n);}const Wr=globalThis.CustomEvent??Event;async function*Ad(n,e={}){let t=e.concurrency??1/0;t<1&&(t=1/0);const r=e.ordered??!1,s=new EventTarget,i=[];let o=V(),a=V(),c=!1,u,l=!1;s.addEventListener("task-complete",()=>{a.resolve()}),Promise.resolve().then(async()=>{try{for await(const g of n){if(i.length===t&&(o=V(),await o.promise),l)break;const m={done:!1};i.push(m),g().then(f=>{m.done=!0,m.ok=!0,m.value=f,s.dispatchEvent(new Wr("task-complete"))},f=>{m.done=!0,m.err=f,s.dispatchEvent(new Wr("task-complete"))})}c=!0,s.dispatchEvent(new Wr("task-complete"))}catch(g){u=g,s.dispatchEvent(new Wr("task-complete"))}});function d(){return r?i[0]?.done:!!i.find(g=>g.done)}function*h(){for(;i.length>0&&i[0].done;){const g=i[0];if(i.shift(),g.ok)yield g.value;else throw l=!0,o.resolve(),g.err;o.resolve()}}function*p(){for(;d();)for(let g=0;g<i.length;g++)if(i[g].done){const m=i[g];if(i.splice(g,1),g--,m.ok)yield m.value;else throw l=!0,o.resolve(),m.err;o.resolve()}}for(;;){if(d()||(a=V(),await a.promise),u!=null||(r?yield*h():yield*p(),u!=null))throw u;if(c&&i.length===0)break}}const h0="0.1.0",f0="id",p0="id/push",g0="1.0.0",m0="1.0.0",y0=1024*8,w0=32,b0=1e3;var An;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.protocolVersion!=null&&(r.uint32(42),r.string(t.protocolVersion)),t.agentVersion!=null&&(r.uint32(50),r.string(t.agentVersion)),t.publicKey!=null&&(r.uint32(10),r.bytes(t.publicKey)),t.listenAddrs!=null)for(const i of t.listenAddrs)r.uint32(18),r.bytes(i);if(t.observedAddr!=null&&(r.uint32(34),r.bytes(t.observedAddr)),t.protocols!=null)for(const i of t.protocols)r.uint32(26),r.string(i);t.signedPeerRecord!=null&&(r.uint32(66),r.bytes(t.signedPeerRecord)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={listenAddrs:[],protocols:[]},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 5:{i.protocolVersion=t.string();break}case 6:{i.agentVersion=t.string();break}case 1:{i.publicKey=t.bytes();break}case 2:{if(s.limits?.listenAddrs!=null&&i.listenAddrs.length===s.limits.listenAddrs)throw new pt('Decode error - map field "listenAddrs" had too many elements');i.listenAddrs.push(t.bytes());break}case 4:{i.observedAddr=t.bytes();break}case 3:{if(s.limits?.protocols!=null&&i.protocols.length===s.limits.protocols)throw new pt('Decode error - map field "protocols" had too many elements');i.protocols.push(t.string());break}case 8:{i.signedPeerRecord=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(An||(An={}));const $e={protocolPrefix:"ipfs",timeout:5e3,maxInboundStreams:1,maxOutboundStreams:1,maxObservedAddresses:10,maxMessageSize:y0,runOnConnectionOpen:!0,runOnSelfUpdate:!0,runOnLimitedConnection:!0,concurrency:w0};function E0(n){if(n!=null&&n.length>0)try{return K(n)}catch{}}function v0(n,e){return e??n.userAgent}async function _d(n,e,t,r,s){if(t("received identify from %p",r.remotePeer),s==null)throw new je("message was null or undefined");const i={};if(s.listenAddrs.length>0&&(i.addresses=s.listenAddrs.map(c=>({isCertified:!1,multiaddr:K(c)}))),s.protocols.length>0&&(i.protocols=s.protocols),s.publicKey!=null){const c=It(s.publicKey);if(!or(c).equals(r.remotePeer))throw new je("public key did not match remote PeerId");i.publicKey=c}let o;if(s.signedPeerRecord!=null){t.trace("received signedPeerRecord from %p",r.remotePeer);let c=s.signedPeerRecord;const u=await Je.openAndCertify(c,Be.DOMAIN);let l=Be.createFromProtobuf(u.payload);const d=xr(u.publicKey.toCID());if(!l.peerId.equals(d))throw new je("signing key does not match PeerId in the PeerRecord");if(!r.remotePeer.equals(l.peerId))throw new je("signing key does not match remote PeerId");let h;try{h=await n.get(l.peerId)}catch(p){if(p.name!=="NotFoundError")throw p}if(h!=null&&(i.metadata=h.metadata,h.peerRecordEnvelope!=null)){const p=Je.createFromProtobuf(h.peerRecordEnvelope),g=Be.createFromProtobuf(p.payload);g.seqNumber>=l.seqNumber&&(t("sequence number was lower or equal to existing sequence number - stored: %d received: %d",g.seqNumber,l.seqNumber),l=g,c=h.peerRecordEnvelope)}i.peerRecordEnvelope=c,i.addresses=l.multiaddrs.map(p=>({isCertified:!0,multiaddr:p})),o={seq:l.seqNumber,addresses:l.multiaddrs}}else t("%p did not send a signed peer record",r.remotePeer);if(t.trace("patching %p with",r.remotePeer,i),await n.patch(r.remotePeer,i),s.agentVersion!=null||s.protocolVersion!=null){const c={};s.agentVersion!=null&&(c.AgentVersion=$(s.agentVersion)),s.protocolVersion!=null&&(c.ProtocolVersion=$(s.protocolVersion)),t.trace("merging %p metadata",r.remotePeer,c),await n.merge(r.remotePeer,{metadata:c})}const a={peerId:r.remotePeer,protocolVersion:s.protocolVersion,agentVersion:s.agentVersion,publicKey:s.publicKey,listenAddrs:s.listenAddrs.map(c=>K(c)),observedAddr:s.observedAddr==null?void 0:K(s.observedAddr),protocols:s.protocols,signedPeerRecord:o,connection:r};return e.safeDispatchEvent("peer:identify",{detail:a}),a}class Cd{host;protocol;started;timeout;peerId;privateKey;peerStore;registrar;addressManager;maxInboundStreams;maxOutboundStreams;maxMessageSize;maxObservedAddresses;events;runOnLimitedConnection;log;constructor(e,t){this.protocol=t.protocol,this.started=!1,this.peerId=e.peerId,this.privateKey=e.privateKey,this.peerStore=e.peerStore,this.registrar=e.registrar,this.addressManager=e.addressManager,this.events=e.events,this.log=t.log,this.timeout=t.timeout??$e.timeout,this.maxInboundStreams=t.maxInboundStreams??$e.maxInboundStreams,this.maxOutboundStreams=t.maxOutboundStreams??$e.maxOutboundStreams,this.maxMessageSize=t.maxMessageSize??$e.maxMessageSize,this.maxObservedAddresses=t.maxObservedAddresses??$e.maxObservedAddresses,this.runOnLimitedConnection=t.runOnLimitedConnection??$e.runOnLimitedConnection,this.host={protocolVersion:`${t.protocolPrefix??$e.protocolPrefix}/${h0}`,agentVersion:v0(e.nodeInfo,t.agentVersion)}}isStarted(){return this.started}async start(){this.started||(await this.peerStore.merge(this.peerId,{metadata:{AgentVersion:$(this.host.agentVersion),ProtocolVersion:$(this.host.protocolVersion)}}),await this.registrar.handle(this.protocol,e=>{this.handleProtocol(e).catch(t=>{this.log.error(t)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0)}async stop(){await this.registrar.unhandle(this.protocol),this.started=!1}}class S0 extends Cd{connectionManager;concurrency;_push;constructor(e,t={}){super(e,{...t,protocol:`/${t.protocolPrefix??$e.protocolPrefix}/${p0}/${m0}`,log:e.logger.forComponent("libp2p:identify-push")}),this.connectionManager=e.connectionManager,this.concurrency=t.concurrency??$e.concurrency,this._push=Ls(this.sendPushMessage.bind(this),t.debounce??b0),(t.runOnSelfUpdate??$e.runOnSelfUpdate)&&e.events.addEventListener("self:peer:update",r=>{this.push().catch(s=>{this.log.error("error pushing updates to peers - %e",s)})})}[Qe]=["@libp2p/identify-push"];async push(){this._push()}async sendPushMessage(){if(this.isStarted())try{const e=this.addressManager.getAddresses().map(l=>l.decapsulateCode(Qs("p2p").code)),t=new Be({peerId:this.peerId,multiaddrs:e}),r=await Je.seal(t,this.privateKey),s=this.registrar.getProtocols(),i=await this.peerStore.get(this.peerId),o=q(i.metadata.get("AgentVersion")??$(this.host.agentVersion)),a=q(i.metadata.get("ProtocolVersion")??$(this.host.protocolVersion)),c=this;async function*u(){for(const l of c.connectionManager.getConnections())(await c.peerStore.get(l.remotePeer)).protocols.includes(c.protocol)&&(yield async()=>{let h;const p=AbortSignal.timeout(c.timeout);try{h=await l.newStream(c.protocol,{signal:p,runOnLimitedConnection:c.runOnLimitedConnection}),await mt(h,{maxDataLength:c.maxMessageSize}).pb(An).write({listenAddrs:e.map(m=>m.bytes),signedPeerRecord:r.marshal(),protocols:s,agentVersion:o,protocolVersion:a},{signal:p}),await h.close({signal:p})}catch(g){c.log.error("could not push identify update to peer",g),h?.abort(g)}})}await po(Ad(u(),{concurrency:this.concurrency}))}catch(e){this.log.error("error pushing updates to peers - %e",e)}}async handleProtocol(e){const{connection:t,stream:r}=e;try{if(this.peerId.equals(t.remotePeer))throw new Error("received push from ourselves?");const s={signal:AbortSignal.timeout(this.timeout)},o=await mt(r,{maxDataLength:this.maxMessageSize}).pb(An).read(s);await r.close(s),await _d(this.peerStore,this.events,this.log,t,o)}catch(s){this.log.error("received invalid message",s),r.abort(s);return}this.log.trace("handled push from %p",t.remotePeer)}}function x0(n){try{for(const{code:e,value:t}of n.getComponents())if(t!=null&&e===qe)return hb("2000::/3",t)}catch{}return!1}function ia(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var Jt={},vc;function A0(){return vc||(vc=1,function(){var n,e,t,r,s,i,o,a;a=function(c){var u,l,d,h;return u=(c&255<<24)>>>24,l=(c&255<<16)>>>16,d=(c&65280)>>>8,h=c&255,[u,l,d,h].join(".")},o=function(c){var u,l,d,h,p,g;for(u=[],d=h=0;h<=3&&c.length!==0;d=++h){if(d>0){if(c[0]!==".")throw new Error("Invalid IP");c=c.substring(1)}g=e(c),p=g[0],l=g[1],c=c.substring(l),u.push(p)}if(c.length!==0)throw new Error("Invalid IP");switch(u.length){case 1:if(u[0]>4294967295)throw new Error("Invalid IP");return u[0]>>>0;case 2:if(u[0]>255||u[1]>16777215)throw new Error("Invalid IP");return(u[0]<<24|u[1])>>>0;case 3:if(u[0]>255||u[1]>255||u[2]>65535)throw new Error("Invalid IP");return(u[0]<<24|u[1]<<16|u[2])>>>0;case 4:if(u[0]>255||u[1]>255||u[2]>255||u[3]>255)throw new Error("Invalid IP");return(u[0]<<24|u[1]<<16|u[2]<<8|u[3])>>>0;default:throw new Error("Invalid IP")}},t=function(c){return c.charCodeAt(0)},r=t("0"),i=t("a"),s=t("A"),e=function(c){var u,l,d,h,p;for(h=0,u=10,l="9",d=0,c.length>1&&c[d]==="0"&&(c[d+1]==="x"||c[d+1]==="X"?(d+=2,u=16):"0"<=c[d+1]&&c[d+1]<="9"&&(d++,u=8,l="7")),p=d;d<c.length;){if("0"<=c[d]&&c[d]<=l)h=h*u+(t(c[d])-r)>>>0;else if(u===16)if("a"<=c[d]&&c[d]<="f")h=h*u+(10+t(c[d])-i)>>>0;else if("A"<=c[d]&&c[d]<="F")h=h*u+(10+t(c[d])-s)>>>0;else break;else break;if(h>4294967295)throw new Error("too large");d++}if(d===p)throw new Error("empty octet");return[h,d]},n=function(){function c(u,l){var d,h,p;if(typeof u!="string")throw new Error("Missing `net' parameter");if(l||(p=u.split("/",2),u=p[0],l=p[1]),l||(l=32),typeof l=="string"&&l.indexOf(".")>-1){try{this.maskLong=o(l)}catch{throw new Error("Invalid mask: "+l)}for(d=h=32;h>=0;d=--h)if(this.maskLong===4294967295<<32-d>>>0){this.bitmask=d;break}}else if(l||l===0)this.bitmask=parseInt(l,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(o(u)&this.maskLong)>>>0}catch{throw new Error("Invalid net address: "+u)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+l);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return c.prototype.contains=function(u){return typeof u=="string"&&(u.indexOf("/")>0||u.split(".").length!==4)&&(u=new c(u)),u instanceof c?this.contains(u.base)&&this.contains(u.broadcast||u.last):(o(u)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},c.prototype.next=function(u){return u==null&&(u=1),new c(a(this.netLong+this.size*u),this.mask)},c.prototype.forEach=function(u){var l,d,h;for(h=o(this.first),d=o(this.last),l=0;h<=d;)u(a(h),h,l),l++,h++},c.prototype.toString=function(){return this.base+"/"+this.bitmask},c}(),Jt.ip2long=o,Jt.long2ip=a,Jt.Netmask=n}.call(Jt)),Jt}var _0=A0();const C0=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"],I0=C0.map(n=>new _0.Netmask(n));function oa(n){for(const e of I0)if(e.contains(n))return!0;return!1}function T0(n){return/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(n)}function P0(n){const e=n.split(":");if(e.length<2)return!1;const t=e[e.length-1].padStart(4,"0"),r=e[e.length-2].padStart(4,"0"),s=`${parseInt(r.substring(0,2),16)}.${parseInt(r.substring(2),16)}.${parseInt(t.substring(0,2),16)}.${parseInt(t.substring(2),16)}`;return oa(s)}function D0(n){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(n)}function L0(n){const e=n.split(":"),t=e[e.length-1];return oa(t)}function k0(n){return/^::$/.test(n)||/^::1$/.test(n)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(n)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(n)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(n)||/^ff([0-9a-fA-F]{2,2}):/i.test(n)}function Js(n){if(bn(n))return oa(n);if(T0(n))return P0(n);if(D0(n))return L0(n);if(Yu(n))return k0(n)}function Id(n){try{for(const{code:e}of n.getComponents())if(e!==Ht)return e===Kt||e===qe}catch{}return!1}function gr(n){try{if(!Id(n))return!1;const[[,e]]=n.stringTuples();return e==null?!1:Js(e)??!1}catch{}return!0}class R0 extends Cd{constructor(e,t={}){super(e,{...t,protocol:`/${t.protocolPrefix??$e.protocolPrefix}/${f0}/${g0}`,log:e.logger.forComponent("libp2p:identify")}),(t.runOnConnectionOpen??$e.runOnConnectionOpen)&&e.events.addEventListener("connection:open",r=>{const s=r.detail;this.identify(s).catch(i=>{i.name!==_o.name&&this.log.error("error during identify trigged by connection:open",i)})})}[Qe]=["@libp2p/identify"];async _identify(e,t={}){let r;if(t.signal==null){const s=AbortSignal.timeout(this.timeout);t={...t,signal:s}}try{r=await e.newStream(this.protocol,{...t,runOnLimitedConnection:this.runOnLimitedConnection});const i=await mt(r,{maxDataLength:this.maxMessageSize}).pb(An).read(t);return await r.close(t),i}catch(s){throw r?.abort(s),s}}async identify(e,t={}){const r=await this._identify(e,t),{publicKey:s,protocols:i,observedAddr:o}=r;if(s==null)throw new je("public key was missing from identify message");const a=It(s),c=xr(a.toCID());if(!e.remotePeer.equals(c))throw new je("identified peer does not match the expected peer");if(this.peerId.equals(c))throw new je("identified peer is our own peer id?");return this.maybeAddObservedAddress(o),this.log("identify completed for peer %p and protocols %o",c,i),_d(this.peerStore,this.events,this.log,e,r)}maybeAddObservedAddress(e){const t=E0(e);if(t==null)return;if(this.log.trace("our observed address was %a",t),gr(t)){this.log.trace("our observed address was private");return}const r=t.getComponents();if((r[0].code===qe||r[0].code===Ht&&r[1].code===qe)&&!x0(t)){this.log.trace("our observed address was IPv6 but not a global unicast address");return}Is.exactMatch(t)||(this.log.trace("storing the observed address"),this.addressManager.addObservedAddr(t))}async handleProtocol(e){const{connection:t,stream:r}=e,s=AbortSignal.timeout(this.timeout);try{const i=await this.peerStore.get(this.peerId),o=this.addressManager.getAddresses().map(l=>l.decapsulateCode(Qs("p2p").code));let a=i.peerRecordEnvelope;if(o.length>0&&a==null){const l=new Be({peerId:this.peerId,multiaddrs:o});a=(await Je.seal(l,this.privateKey)).marshal().subarray()}let c=t.remoteAddr.bytes;Ab.matches(t.remoteAddr)||(c=void 0),await mt(r).pb(An).write({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:dt(this.privateKey.publicKey),listenAddrs:o.map(l=>l.bytes),signedPeerRecord:a,observedAddr:c,protocols:i.protocols},{signal:s}),await r.close({signal:s})}catch(i){this.log.error("could not respond to identify request",i),r.abort(i)}}}function M0(n={}){return e=>new R0(e,n)}function N0(n={}){return e=>new S0(e,n)}let O0=class{readNext;haveNext;ended;nextResult;error;constructor(){this.ended=!1,this.readNext=V(),this.haveNext=V()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=V(),e}async throw(e){return this.ended=!0,this.error=e,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=V(),await oe(this.readNext.promise,t?.signal,t)}};function F0(){return new O0}let U0=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};function Sc(n,e){const t=F0();n.sink(t).catch(async o=>{await t.end(o)}),n.sink=async o=>{for await(const a of o)await t.push(a);await t.end()};let r=n.source;n.source[Symbol.iterator]!=null?r=n.source[Symbol.iterator]():n.source[Symbol.asyncIterator]!=null&&(r=n.source[Symbol.asyncIterator]());const s=new H;return{read:async o=>{if(o?.signal?.throwIfAborted(),o?.bytes==null){const{done:c,value:u}=await oe(r.next(),o?.signal);return c===!0?null:u}for(;s.byteLength<o.bytes;){const{value:c,done:u}=await oe(r.next(),o?.signal);if(u===!0)throw new U0("unexpected end of input");s.append(c)}const a=s.sublist(0,o.bytes);return s.consume(o.bytes),a},write:async(o,a)=>{a?.signal?.throwIfAborted(),o instanceof Uint8Array?await t.push(o,a):await t.push(o.subarray(),a)},unwrap:()=>{if(s.byteLength>0){const o=n.source;n.source=async function*(){yield*s,yield*o}()}return n}}}const xi=32,B0="1.0.0",$0="ping",z0="ipfs",q0=1e4,K0=2,W0=1;class V0{protocol;components;started;timeout;maxInboundStreams;maxOutboundStreams;runOnLimitedConnection;log;constructor(e,t={}){this.components=e,this.log=e.logger.forComponent("libp2p:ping"),this.started=!1,this.protocol=`/${t.protocolPrefix??z0}/${$0}/${B0}`,this.timeout=t.timeout??q0,this.maxInboundStreams=t.maxInboundStreams??K0,this.maxOutboundStreams=t.maxOutboundStreams??W0,this.runOnLimitedConnection=t.runOnLimitedConnection??!0,this.handleMessage=this.handleMessage.bind(this)}[Symbol.toStringTag]="@libp2p/ping";[Qe]=["@libp2p/ping"];async start(){await this.components.registrar.handle(this.protocol,this.handleMessage,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}isStarted(){return this.started}handleMessage(e){this.log("incoming ping from %p",e.connection.remotePeer);const{stream:t}=e,r=Date.now(),s=Sc(t);let i=!1;Promise.resolve().then(async()=>{for(;;){const o=AbortSignal.timeout(this.timeout);o.addEventListener("abort",()=>{t?.abort(new Co("ping timeout"))});const a=await s.read({bytes:xi,signal:o});await s.write(a,{signal:o}),i=!0}}).catch(o=>{i&&o.name==="UnexpectedEOFError"&&t.readStatus!=="ready"||(this.log.error("incoming ping from %p failed with error - %e",e.connection.remotePeer,o),t?.abort(o))}).finally(()=>{const o=Date.now()-r;this.log("incoming ping from %p complete in %dms",e.connection.remotePeer,o);const a=AbortSignal.timeout(this.timeout);t.close({signal:a}).catch(c=>{this.log.error("error closing ping stream from %p - %e",e.connection.remotePeer,c),t?.abort(c)})})}async ping(e,t={}){this.log("pinging %p",e);const r=Date.now(),s=Vo(xi),i=await this.components.connectionManager.openConnection(e,t);let o;if(t.signal==null){const a=AbortSignal.timeout(this.timeout);t={...t,signal:a}}try{o=await i.newStream(this.protocol,{...t,runOnLimitedConnection:this.runOnLimitedConnection});const a=Sc(o),[,c]=await Promise.all([a.write(s,t),a.read({...t,bytes:xi})]),u=Date.now()-r;if(!Te(s,c.subarray()))throw new Rh(`Received wrong ping ack after ${u}ms`);return this.log("ping %p complete in %dms",i.remotePeer,u),u}catch(a){throw this.log.error("error while pinging %p",i.remotePeer,a),o?.abort(a),a}finally{o!=null&&await o.close(t)}}}function H0(n={}){return e=>new V0(e,n)}var Me;(function(n){(function(r){r.FIN="FIN",r.STOP_SENDING="STOP_SENDING",r.RESET="RESET",r.FIN_ACK="FIN_ACK"})(n.Flag||(n.Flag={}));let e;(function(r){r[r.FIN=0]="FIN",r[r.STOP_SENDING=1]="STOP_SENDING",r[r.RESET=2]="RESET",r[r.FIN_ACK=3]="FIN_ACK"})(e||(e={})),function(r){r.codec=()=>Ln(e)}(n.Flag||(n.Flag={}));let t;n.codec=()=>(t==null&&(t=fe((r,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),r.flag!=null&&(s.uint32(8),n.Flag.codec().encode(r.flag,s)),r.message!=null&&(s.uint32(18),s.bytes(r.message)),i.lengthDelimited!==!1&&s.ldelim()},(r,s,i={})=>{const o={},a=s==null?r.len:r.pos+s;for(;r.pos<a;){const c=r.uint32();switch(c>>>3){case 1:{o.flag=n.Flag.codec().decode(r);break}case 2:{o.message=r.bytes();break}default:{r.skipType(c&7);break}}}return o})),t),n.encode=r=>he(r,n.codec()),n.decode=(r,s)=>de(r,n.codec(),s)})(Me||(Me={}));const G0=["stun:stun.l.google.com:19302","stun:global.stun.twilio.com:3478","stun:stun.cloudflare.com:3478","stun:stun.services.mozilla.com:3478"];Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890");const Q0=2*1024*1024,Y0=30*1e3,Td=16*1024;function X0(n=Td){const e=Ie(n-Ie(n)),t=1+Ie(Object.keys(Me.Flag).length-1),r=1,s=n-e-t-r,i=Ie(s);return e+t+r+i}const Z0=X0(),j0=5e3,J0=5e3,eE=3e4,Pd="/webrtc",go="/webrtc-signaling/0.0.1";var xc=function(n,e,t){if(t||arguments.length===2)for(var r=0,s=e.length,i;r<s;r++)(i||!(r in e))&&(i||(i=Array.prototype.slice.call(e,0,r)),i[r]=e[r]);return n.concat(i||Array.prototype.slice.call(e))},tE=function(){function n(e,t,r){this.name=e,this.version=t,this.os=r,this.type="browser"}return n}(),nE=function(){function n(e){this.version=e,this.type="node",this.name="node",this.os=process.platform}return n}(),rE=function(){function n(e,t,r,s){this.name=e,this.version=t,this.os=r,this.bot=s,this.type="bot-device"}return n}(),sE=function(){function n(){this.type="bot",this.bot=!0,this.name="bot",this.version=null,this.os=null}return n}(),iE=function(){function n(){this.type="react-native",this.name="react-native",this.version=null,this.os=null}return n}(),oE=/alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,aE=/(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,Ac=3,cE=[["aol",/AOLShield\/([0-9\._]+)/],["edge",/Edge\/([0-9\._]+)/],["edge-ios",/EdgiOS\/([0-9\._]+)/],["yandexbrowser",/YaBrowser\/([0-9\._]+)/],["kakaotalk",/KAKAOTALK\s([0-9\.]+)/],["samsung",/SamsungBrowser\/([0-9\.]+)/],["silk",/\bSilk\/([0-9._-]+)\b/],["miui",/MiuiBrowser\/([0-9\.]+)$/],["beaker",/BeakerBrowser\/([0-9\.]+)/],["edge-chromium",/EdgA?\/([0-9\.]+)/],["chromium-webview",/(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["chrome",/(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["phantomjs",/PhantomJS\/([0-9\.]+)(:?\s|$)/],["crios",/CriOS\/([0-9\.]+)(:?\s|$)/],["firefox",/Firefox\/([0-9\.]+)(?:\s|$)/],["fxios",/FxiOS\/([0-9\.]+)/],["opera-mini",/Opera Mini.*Version\/([0-9\.]+)/],["opera",/Opera\/([0-9\.]+)(?:\s|$)/],["opera",/OPR\/([0-9\.]+)(:?\s|$)/],["pie",/^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],["pie",/^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],["netfront",/^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],["ie",/Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],["ie",/MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],["ie",/MSIE\s(7\.0)/],["bb10",/BB10;\sTouch.*Version\/([0-9\.]+)/],["android",/Android\s([0-9\.]+)/],["ios",/Version\/([0-9\._]+).*Mobile.*Safari.*/],["safari",/Version\/([0-9\._]+).*Safari/],["facebook",/FB[AS]V\/([0-9\.]+)/],["instagram",/Instagram\s([0-9\.]+)/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Mobile/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Gecko\)$/],["curl",/^curl\/([0-9\.]+)$/],["searchbot",oE]],_c=[["iOS",/iP(hone|od|ad)/],["Android OS",/Android/],["BlackBerry OS",/BlackBerry|BB10/],["Windows Mobile",/IEMobile/],["Amazon OS",/Kindle/],["Windows 3.11",/Win16/],["Windows 95",/(Windows 95)|(Win95)|(Windows_95)/],["Windows 98",/(Windows 98)|(Win98)/],["Windows 2000",/(Windows NT 5.0)|(Windows 2000)/],["Windows XP",/(Windows NT 5.1)|(Windows XP)/],["Windows Server 2003",/(Windows NT 5.2)/],["Windows Vista",/(Windows NT 6.0)/],["Windows 7",/(Windows NT 6.1)/],["Windows 8",/(Windows NT 6.2)/],["Windows 8.1",/(Windows NT 6.3)/],["Windows 10",/(Windows NT 10.0)/],["Windows ME",/Windows ME/],["Windows CE",/Windows CE|WinCE|Microsoft Pocket Internet Explorer/],["Open BSD",/OpenBSD/],["Sun OS",/SunOS/],["Chrome OS",/CrOS/],["Linux",/(Linux)|(X11)/],["Mac OS",/(Mac_PowerPC)|(Macintosh)/],["QNX",/QNX/],["BeOS",/BeOS/],["OS/2",/OS\/2/]];function lE(n){return typeof document>"u"&&typeof navigator<"u"&&navigator.product==="ReactNative"?new iE:typeof navigator<"u"?dE(navigator.userAgent):fE()}function uE(n){return n!==""&&cE.reduce(function(e,t){var r=t[0],s=t[1];if(e)return e;var i=s.exec(n);return!!i&&[r,i]},!1)}function dE(n){var e=uE(n);if(!e)return null;var t=e[0],r=e[1];if(t==="searchbot")return new sE;var s=r[1]&&r[1].split(".").join("_").split("_").slice(0,3);s?s.length<Ac&&(s=xc(xc([],s,!0),pE(Ac-s.length),!0)):s=[];var i=s.join("."),o=hE(n),a=aE.exec(n);return a&&a[1]?new rE(t,i,o,a[1]):new tE(t,i,o)}function hE(n){for(var e=0,t=_c.length;e<t;e++){var r=_c[e],s=r[0],i=r[1],o=i.exec(n);if(o)return s}return null}function fE(){var n=typeof process<"u"&&process.version;return n?new nE(process.version.slice(1)):null}function pE(n){for(var e=[],t=0;t<n;t++)e.push("0");return e}class Dd extends Error{constructor(e){super(e),this.name="TimeoutError"}}let gE=class extends Error{constructor(e){super(),this.name="AbortError",this.message=e}};const Cc=n=>globalThis.DOMException===void 0?new gE(n):new DOMException(n),Ic=n=>{const e=n.reason===void 0?Cc("This operation was aborted."):n.reason;return e instanceof Error?e:Cc(e)};function aa(n,e){const{milliseconds:t,fallback:r,message:s,customTimers:i={setTimeout,clearTimeout}}=e;let o,a;const u=new Promise((l,d)=>{if(typeof t!="number"||Math.sign(t)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${t}\``);if(e.signal){const{signal:p}=e;p.aborted&&d(Ic(p)),a=()=>{d(Ic(p))},p.addEventListener("abort",a,{once:!0})}if(t===Number.POSITIVE_INFINITY){n.then(l,d);return}const h=new Dd;o=i.setTimeout.call(void 0,()=>{if(r){try{l(r())}catch(p){d(p)}return}typeof n.cancel=="function"&&n.cancel(),s===!1?l():s instanceof Error?d(s):(h.message=s??`Promise timed out after ${t} milliseconds`,d(h))},t),(async()=>{try{l(await n)}catch(p){d(p)}})()}).finally(()=>{u.clear(),a&&e.signal&&e.signal.removeEventListener("abort",a)});return u.clear=()=>{i.clearTimeout.call(void 0,o),o=void 0},u}const Tc=lE(),Ld=Tc!=null&&Tc.name==="firefox",kd=async function*(){},Rd=async n=>{};function mE(n,e,t=eE,r){n.readyState==="open"&&Promise.resolve().then(async()=>{if(n.bufferedAmount>0){r.log("%s drain channel with %d buffered bytes",e,n.bufferedAmount);const s=V();let i=!1;n.bufferedAmountLowThreshold=0;const o=()=>{i||(r.log("%s drain channel closed before drain",e),s.resolve())};n.addEventListener("close",o,{once:!0}),n.addEventListener("bufferedamountlow",()=>{i=!0,n.removeEventListener("close",o),s.resolve()}),await aa(s.promise,{milliseconds:t})}}).then(async()=>{n.readyState==="open"&&n.close()}).catch(s=>{r.log.error("error closing outbound stream",s)})}async function Pc(n){return n=n??{},typeof n=="function"&&(n=await n()),n.iceServers=n.iceServers??G0.map(e=>({urls:[e]})),n}class Dc{log;peerConnection;remoteAddr;timeline;metrics;source=kd();sink=Rd;constructor(e,t){this.log=e.logger.forComponent("libp2p:webrtc:maconn"),this.remoteAddr=t.remoteAddr,this.timeline=t.timeline,this.peerConnection=t.peerConnection;const r=this.peerConnection,s=r.connectionState;this.peerConnection.onconnectionstatechange=()=>{this.log.trace("peer connection state change",r.connectionState,"initial state",s),(r.connectionState==="disconnected"||r.connectionState==="failed"||r.connectionState==="closed")&&(this.timeline.close=Date.now())}}async close(e){this.log.trace("closing connection"),this.peerConnection.close(),this.timeline.close=Date.now(),this.metrics?.increment({close:!0})}abort(e){this.log.error("closing connection due to error",e),this.peerConnection.close(),this.timeline.close=Date.now(),this.metrics?.increment({abort:!0})}}class yE extends qu{channel;incomingData;maxBufferedAmount;bufferedAmountLowEventTimeout;maxMessageSize;receiveFinAck;finAckTimeout;openTimeout;closeController;constructor(e){const t=e.onEnd;switch(e.onEnd=s=>{this.log.trace('readable and writeable ends closed with status "%s"',this.status),Promise.resolve(async()=>{if(!(this.timeline.abort!=null||this.timeline.reset!==null))try{await aa(this.receiveFinAck.promise,{milliseconds:this.finAckTimeout})}catch(i){this.log.error("error receiving FIN_ACK",i)}}).then(()=>{this.incomingData.end(),t?.(s)}).catch(i=>{this.log.error("error ending stream",i)}).finally(()=>{this.channel.close()})},super(e),this.channel=e.channel,this.channel.binaryType="arraybuffer",this.incomingData=kn(),this.bufferedAmountLowEventTimeout=e.bufferedAmountLowEventTimeout??Y0,this.maxBufferedAmount=e.maxBufferedAmount??Q0,this.maxMessageSize=(e.maxMessageSize??Td)-Z0,this.receiveFinAck=V(),this.finAckTimeout=e.closeTimeout??j0,this.openTimeout=e.openTimeout??J0,this.closeController=new AbortController,this.channel.readyState){case"open":this.timeline.open=new Date().getTime();break;case"closed":case"closing":(this.timeline.close===void 0||this.timeline.close===0)&&(this.timeline.close=Date.now());break;case"connecting":break;default:throw this.log.error("unknown datachannel state %s",this.channel.readyState),new Ki("Unknown datachannel state")}this.channel.onopen=s=>{this.timeline.open=new Date().getTime()},this.channel.onclose=s=>{this.log.trace("received onclose event"),this.closeController.abort(),this.receiveFinAck.resolve(),this.close().catch(i=>{this.log.error("error closing stream after channel closed",i)})},this.channel.onerror=s=>{this.log.trace("received onerror event"),this.closeController.abort();const i=s.error;this.abort(i)},this.channel.onmessage=async s=>{const{data:i}=s;i===null||i.byteLength===0||this.incomingData.push(new Uint8Array(i,0,i.byteLength))};const r=this;Promise.resolve().then(async()=>{for await(const s of gs(this.incomingData)){const i=r.processIncomingProtobuf(s);i!=null&&r.sourcePush(new H(i))}}).catch(s=>{this.log.error("error processing incoming data channel messages",s)})}sendNewStream(){}async _sendMessage(e,t=!0){if(this.channel.readyState==="closed"||this.channel.readyState==="closing")throw new Ki(`Invalid datachannel state - ${this.channel.readyState}`);if(this.channel.readyState!=="open"){const r=AbortSignal.timeout(this.openTimeout),s=Tt([this.closeController.signal,r]);try{this.log('channel state is "%s" and not "open", waiting for "open" event before sending data',this.channel.readyState),await ft(this.channel,"open",s)}finally{s.clear()}this.log('channel state is now "%s", sending data',this.channel.readyState)}if(t&&this.channel.bufferedAmount>this.maxBufferedAmount){const r=AbortSignal.timeout(this.bufferedAmountLowEventTimeout),s=Tt([this.closeController.signal,r]);try{this.log('channel buffer is %d, wait for "bufferedamountlow" event',this.channel.bufferedAmount),await ft(this.channel,"bufferedamountlow",s)}catch(i){throw r.aborted?new Co(`Timed out waiting for DataChannel buffer to clear after ${this.bufferedAmountLowEventTimeout}ms`):i}finally{s.clear()}}try{this.log.trace('sending message, channel state "%s"',this.channel.readyState),this.channel.send(e.subarray())}catch(r){this.log.error("error while sending message",r)}}async sendData(e){const t=e.byteLength;for(e=e.sublist();e.byteLength>0;){const r=Math.min(e.byteLength,this.maxMessageSize),s=e.subarray(0,r),i=Me.encode({message:s}),o=ps.single(i);this.log.trace("sending %d/%d bytes on channel",s.byteLength,t),await this._sendMessage(o),e.consume(r)}this.log.trace('finished sending data, channel state "%s"',this.channel.readyState)}async sendReset(){try{await this._sendFlag(Me.Flag.RESET)}catch(e){this.log.error("failed to send reset - %e",e)}finally{this.channel.close()}}async sendCloseWrite(e){if(this.channel.readyState!=="open"){this.receiveFinAck.resolve();return}if(await this._sendFlag(Me.Flag.FIN)){this.log.trace("awaiting FIN_ACK");try{await oe(this.receiveFinAck.promise,e?.signal,{errorMessage:"sending close-write was aborted before FIN_ACK was received",errorName:"FinAckNotReceivedError"})}catch(r){this.log.error("failed to await FIN_ACK",r)}}else this.log.trace("sending FIN failed, not awaiting FIN_ACK");this.receiveFinAck.resolve()}async sendCloseRead(){this.channel.readyState==="open"&&await this._sendFlag(Me.Flag.STOP_SENDING)}processIncomingProtobuf(e){const t=Me.decode(e);if(t.flag!==void 0&&(this.log.trace('incoming flag %s, write status "%s", read status "%s"',t.flag,this.writeStatus,this.readStatus),t.flag===Me.Flag.FIN&&(this.remoteCloseWrite(),this.log.trace("sending FIN_ACK"),this._sendFlag(Me.Flag.FIN_ACK).catch(r=>{this.log.error("error sending FIN_ACK immediately",r)})),t.flag===Me.Flag.RESET&&this.reset(),t.flag===Me.Flag.STOP_SENDING&&this.remoteCloseRead(),t.flag===Me.Flag.FIN_ACK&&(this.log.trace("received FIN_ACK"),this.receiveFinAck.resolve())),this.readStatus==="ready")return t.message}async _sendFlag(e){if(this.channel.readyState!=="open")return this.log.trace('not sending flag %s because channel is "%s" and not "open"',e.toString(),this.channel.readyState),!1;this.log.trace("sending flag %s",e.toString());const t=Me.encode({flag:e}),r=ps.single(t);try{return await this._sendMessage(r,!1),!0}catch(s){this.log.error("could not send flag %s - %e",e.toString(),s)}return!1}}function mo(n){const{channel:e,direction:t,handshake:r}=n;return new yE({id:`${e.id}`,log:n.logger.forComponent(`libp2p:webrtc:stream:${r===!0?"handshake":t}:${e.id}`),...n})}class Md{protocol;peerConnection;bufferedStreams=[];metrics;dataChannelOptions;components;log;constructor(e,t){this.components=e,this.peerConnection=t.peerConnection,this.metrics=t.metrics,this.protocol=t.protocol??Pd,this.dataChannelOptions=t.dataChannelOptions??{},this.log=e.logger.forComponent("libp2p:webrtc:muxerfactory"),this.peerConnection.ondatachannel=({channel:r})=>{if(this.log.trace('incoming early datachannel with channel id %d and label "%s"',r.id),r.label==="init"){this.log.trace("closing early init channel"),r.close();return}const s={},i=mo({channel:r,direction:"inbound",onEnd:o=>{s.onEnd(o)},logger:e.logger,...this.dataChannelOptions});s.stream=i,s.channel=r,s.onEnd=()=>{this.bufferedStreams=this.bufferedStreams.filter(o=>o.stream.id!==i.id)},this.bufferedStreams.push(s)}}createStreamMuxer(e){return new wE(this.components,{...e,peerConnection:this.peerConnection,dataChannelOptions:this.dataChannelOptions,metrics:this.metrics,streams:this.bufferedStreams,protocol:this.protocol})}}class wE{init;streams;protocol;log;peerConnection;dataChannelOptions;metrics;logger;constructor(e,t){this.init=t,this.log=e.logger.forComponent("libp2p:webrtc:muxer"),this.logger=e.logger,this.streams=t.streams.map(r=>r.stream),this.peerConnection=t.peerConnection,this.protocol=t.protocol??Pd,this.metrics=t.metrics,this.dataChannelOptions=t.dataChannelOptions??{},this.peerConnection.ondatachannel=({channel:r})=>{if(this.log.trace("incoming datachannel with channel id %d",r.id),r.label==="init"){this.log.trace("closing init channel"),r.close();return}const s=r.id,i=mo({channel:r,direction:"inbound",onEnd:()=>{this.#e(i,r),this.log("incoming channel %s ended",s)},logger:this.logger,...this.dataChannelOptions});this.streams.push(i),this.metrics?.increment({incoming_stream:!0}),t?.onIncomingStream?.(i)},this.init.streams.length>0&&queueMicrotask(()=>{this.init.streams.forEach(r=>{r.onEnd=()=>{this.log("incoming early channel %s ended with state %s",r.channel.id,r.channel.readyState),this.#e(r.stream,r.channel)},this.metrics?.increment({incoming_stream:!0}),this.init?.onIncomingStream?.(r.stream)})})}#e(e,t){this.log.trace("stream %s %s %s onEnd",e.direction,e.id,e.protocol),mE(t,`${e.direction} ${e.id} ${e.protocol}`,this.dataChannelOptions.drainTimeout,{log:this.log}),this.streams=this.streams.filter(r=>r.id!==e.id),this.metrics?.increment({stream_end:!0}),this.init?.onStreamEnd?.(e)}async close(e){try{await Promise.all(this.streams.map(async t=>t.close(e)))}catch(t){this.abort(t)}}abort(e){for(const t of this.streams)t.abort(e)}source=kd();sink=Rd;newStream(){const e=this.peerConnection.createDataChannel(""),t=e.id;this.log.trace("opened outgoing datachannel with channel id %s",t);const r=mo({channel:e,direction:"outbound",onEnd:()=>{this.#e(r,e),this.log("outgoing channel %s ended",t)},logger:this.logger,...this.dataChannelOptions});return this.streams.push(r),this.metrics?.increment({outgoing_stream:!0}),r}}const Nd=globalThis.RTCPeerConnection,Od=globalThis.RTCSessionDescription,bE=globalThis.RTCIceCandidate;class EE extends Error{constructor(e){super(`WebRTC transport error: ${e}`),this.name="WebRTCTransportError"}}class At extends EE{constructor(e="SDP handshake failed"){super(e),this.name="SDPHandshakeFailedError"}}var He;(function(n){(function(r){r.SDP_OFFER="SDP_OFFER",r.SDP_ANSWER="SDP_ANSWER",r.ICE_CANDIDATE="ICE_CANDIDATE"})(n.Type||(n.Type={}));let e;(function(r){r[r.SDP_OFFER=0]="SDP_OFFER",r[r.SDP_ANSWER=1]="SDP_ANSWER",r[r.ICE_CANDIDATE=2]="ICE_CANDIDATE"})(e||(e={})),function(r){r.codec=()=>Ln(e)}(n.Type||(n.Type={}));let t;n.codec=()=>(t==null&&(t=fe((r,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),r.type!=null&&(s.uint32(8),n.Type.codec().encode(r.type,s)),r.data!=null&&(s.uint32(18),s.string(r.data)),i.lengthDelimited!==!1&&s.ldelim()},(r,s,i={})=>{const o={},a=s==null?r.len:r.pos+s;for(;r.pos<a;){const c=r.uint32();switch(c>>>3){case 1:{o.type=n.Type.codec().decode(r);break}case 2:{o.data=r.string();break}default:{r.skipType(c&7);break}}}return o})),t),n.encode=r=>he(r,n.codec()),n.decode=(r,s)=>de(r,n.codec(),s)})(He||(He={}));const Fd=async(n,e,t)=>{try{const r=V();for(vE(n,r);;){const s=await Promise.race([r.promise,e.read({signal:t.signal}).catch(()=>{})]);if(s==null){t.signal?.throwIfAborted();break}if(s.type!==He.Type.ICE_CANDIDATE)throw new je("ICE candidate message expected");const i=JSON.parse(s.data??"null");if(i===""||i===null){t.onProgress?.(new ee("webrtc:end-of-ice-candidates")),t.log.trace("end-of-candidates received");continue}const o=new bE(i);t.log.trace("%s received new ICE candidate %o",t.direction,i);try{t.onProgress?.(new ee("webrtc:add-ice-candidate",o.candidate)),await n.addIceCandidate(o)}catch(a){t.log.error("%s bad candidate received",t.direction,i,a)}}}catch(r){if(t.log.error("%s error parsing ICE candidate",t.direction,r),t.signal?.aborted===!0&&ca(n)!=="connected")throw r}};function ca(n){return Ld?n.iceConnectionState:n.connectionState}function vE(n,e){n[Ld?"oniceconnectionstatechange":"onconnectionstatechange"]=t=>{switch(ca(n)){case"connected":e.resolve();break;case"failed":case"disconnected":case"closed":e.reject(new wl("RTCPeerConnection was closed"));break}}}async function SE({rtcConfiguration:n,dataChannel:e,signal:t,metrics:r,multiaddr:s,connectionManager:i,transportManager:o,log:a,logger:c,onProgress:u}){const{circuitAddress:l,targetPeer:d}=_E(s);r?.dialerEvents.increment({open:!0}),a.trace("dialing circuit address: %a",l);const h=i.getConnections(d);let p;h.length===0?(u?.(new ee("webrtc:dial-relay")),p=await o.dial(l,{signal:t,onProgress:u})):(u?.(new ee("webrtc:reuse-relay-connection")),p=h[0]),u?.(new ee("webrtc:open-signaling-stream"));const g=await p.newStream(go,{signal:t,runOnLimitedConnection:!0}),m=mt(g).pb(He),f=new Nd(n),w=new Md({logger:c},{peerConnection:f,dataChannelOptions:e});try{const v=f.createDataChannel("init");f.onicecandidate=({candidate:T})=>{const k=JSON.stringify(T?.toJSON()??null);a.trace("initiator sending ICE candidate %o",T),m.write({type:He.Type.ICE_CANDIDATE,data:k},{signal:t}).catch(D=>{a.error("error sending ICE candidate",D)})},f.onicecandidateerror=T=>{a.error("initiator ICE candidate error",T)};const x=await f.createOffer().catch(T=>{throw a.error("could not execute createOffer",T),new At("Failed to set createOffer")});a.trace("initiator send SDP offer %s",x.sdp),u?.(new ee("webrtc:send-sdp-offer")),await m.write({type:He.Type.SDP_OFFER,data:x.sdp},{signal:t}),await f.setLocalDescription(x).catch(T=>{throw a.error("could not execute setLocalDescription",T),new At("Failed to set localDescription")}),u?.(new ee("webrtc:read-sdp-answer")),a.trace("initiator read SDP answer");const L=await m.read({signal:t});if(L.type!==He.Type.SDP_ANSWER)throw new At("Remote should send an SDP answer");a.trace("initiator received SDP answer %s",L.data);const E=new Od({type:"answer",sdp:L.data});return await f.setRemoteDescription(E).catch(T=>{throw a.error("could not execute setRemoteDescription",T),new At("Failed to set remoteDescription")}),a.trace("initiator read candidates until connected"),u?.(new ee("webrtc:read-ice-candidates")),await Fd(f,m,{direction:"initiator",signal:t,log:a,onProgress:u}),a.trace("initiator connected, closing init channel"),v.close(),u?.(new ee("webrtc:close-signaling-stream")),a.trace("closing signaling channel"),await g.close({signal:t}),a.trace("initiator connected to remote address %s",s),{remoteAddress:s,peerConnection:f,muxerFactory:w}}catch(v){throw a.error("outgoing signaling error",v),f.close(),g.abort(v),v}finally{f.onicecandidate=null,f.onicecandidateerror=null}}const Lc=te(md.matchers[0],se(Gt));class la extends tt{transportManager;shutdownController;events;constructor(e,t){super(),this.transportManager=e.transportManager,this.events=e.events,this.shutdownController=t.shutdownController,this.onTransportListening=this.onTransportListening.bind(this)}async listen(){this.events.addEventListener("transport:listening",this.onTransportListening)}onTransportListening(e){e.detail.getAddrs().filter(r=>Lc.exactMatch(r)).map(r=>r.encapsulate("/webrtc")).length>0&&this.safeDispatchEvent("listening")}getAddrs(){return this.transportManager.getListeners().filter(e=>!(e instanceof la)).map(e=>e.getAddrs().filter(t=>Lc.exactMatch(t)).map(t=>t.encapsulate("/webrtc"))).flat()}updateAnnounceAddrs(){}async close(){this.events.removeEventListener("transport:listening",this.onTransportListening),this.shutdownController.abort(),queueMicrotask(()=>{this.safeDispatchEvent("close")})}}async function xE({peerConnection:n,stream:e,signal:t,connection:r,log:s}){s.trace("new inbound signaling stream");const i=mt(e).pb(He);try{n.onicecandidate=({candidate:l})=>{const d=JSON.stringify(l?.toJSON()??null);s.trace("recipient sending ICE candidate %s",d),i.write({type:He.Type.ICE_CANDIDATE,data:d},{signal:t}).catch(h=>{s.error("error sending ICE candidate",h)})},s.trace("recipient read SDP offer");const a=await i.read({signal:t});if(a.type!==He.Type.SDP_OFFER)throw new At(`expected message type SDP_OFFER, received: ${a.type??"undefined"} `);s.trace("recipient received SDP offer %s",a.data);const c=new Od({type:"offer",sdp:a.data});await n.setRemoteDescription(c).catch(l=>{throw s.error("could not execute setRemoteDescription",l),new At("Failed to set remoteDescription")});const u=await n.createAnswer().catch(l=>{throw s.error("could not execute createAnswer",l),new At("Failed to create answer")});s.trace("recipient send SDP answer %s",u.sdp),await i.write({type:He.Type.SDP_ANSWER,data:u.sdp},{signal:t}),await n.setLocalDescription(u).catch(l=>{throw s.error("could not execute setLocalDescription",l),new At("Failed to set localDescription")}),s.trace("recipient read candidates until connected"),await Fd(n,i,{direction:"recipient",signal:t,log:s})}catch(a){if(ca(n)!=="connected")throw s.error("error while handling signaling stream from peer %a",r.remoteAddr,a),n.close(),a;s("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected",r.remoteAddr,a)}const o=K(`/webrtc/p2p/${r.remoteAddr.getPeerId()}`);return s.trace("recipient connected to remote address %s",o),{remoteAddress:o}}class AE{components;init;log;_started=!1;metrics;shutdownController;constructor(e,t={}){this.components=e,this.init=t,this.log=e.logger.forComponent("libp2p:webrtc"),this.shutdownController=new AbortController,this.shutdownController.signal,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total",{label:"event",help:"Total count of WebRTC dialer events by type"}),listenerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total",{label:"event",help:"Total count of WebRTC listener events by type"})})}[xo]=!0;[Symbol.toStringTag]="@libp2p/webrtc";[Qe]=["@libp2p/transport"];[ns]=["@libp2p/identify","@libp2p/circuit-relay-v2-transport"];isStarted(){return this._started}async start(){await this.components.registrar.handle(go,e=>{const t=this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);this._onProtocol(e,t).catch(r=>{this.log.error("failed to handle incoming connect from %p",e.connection.remotePeer,r)}).finally(()=>{t.clear()})},{runOnLimitedConnection:!0}),this._started=!0}async stop(){await this.components.registrar.unhandle(go),this._started=!1}createListener(e){return new la(this.components,{shutdownController:this.shutdownController})}listenFilter(e){return e.filter(fo.exactMatch)}dialFilter(e){return this.listenFilter(e)}async dial(e,t){this.log.trace("dialing address: %a",e);const{remoteAddress:r,peerConnection:s,muxerFactory:i}=await SE({rtcConfiguration:await Pc(this.init.rtcConfiguration),dataChannel:this.init.dataChannel,multiaddr:e,dataChannelOptions:this.init.dataChannel,signal:t.signal,connectionManager:this.components.connectionManager,transportManager:this.components.transportManager,log:this.log,logger:this.components.logger,onProgress:t.onProgress}),o=new Dc(this.components,{peerConnection:s,timeline:{open:Date.now()},remoteAddr:r,metrics:this.metrics?.dialerEvents}),a=await t.upgrader.upgradeOutbound(o,{skipProtection:!0,skipEncryption:!0,muxerFactory:i,onProgress:t.onProgress,signal:t.signal});return this._closeOnShutdown(s,o),a}async _onProtocol({connection:e,stream:t},r){const s=new Nd(await Pc(this.init.rtcConfiguration)),i=new Md(this.components,{peerConnection:s,dataChannelOptions:this.init.dataChannel});try{const{remoteAddress:o}=await xE({peerConnection:s,connection:e,stream:t,signal:r,log:this.log});await t.close({signal:r});const a=new Dc(this.components,{peerConnection:s,timeline:{open:new Date().getTime()},remoteAddr:o,metrics:this.metrics?.listenerEvents});await this.components.upgrader.upgradeInbound(a,{skipEncryption:!0,skipProtection:!0,muxerFactory:i,signal:r}),this._closeOnShutdown(s,a)}catch(o){throw this.log.error("incoming signaling error",o),s.close(),t.abort(o),o}}_closeOnShutdown(e,t){const r=()=>{t.close().catch(s=>{this.log.error("could not close WebRTCMultiaddrConnection",s)})};this.shutdownController.signal.addEventListener("abort",r),e.addEventListener("close",()=>{this.shutdownController.signal.removeEventListener("abort",r)})}}function _E(n){const e=n.getComponents().filter(({name:r})=>r==="p2p").map(({value:r})=>r).pop();if(e==null)throw new z("Destination peer id was missing");return{circuitAddress:K(n.getComponents().filter(({name:r})=>r!=="webrtc")),targetPeer:gt(e)}}const at="/",Ud=new TextEncoder().encode(at),Vr=Ud[0];class De{_buf;constructor(e,t){if(typeof e=="string")this._buf=$(e);else if(e instanceof Uint8Array)this._buf=e;else throw new Error("Invalid key, should be String of Uint8Array");if(t==null&&(t=!0),t&&this.clean(),this._buf.byteLength===0||this._buf[0]!==Vr)throw new Error("Invalid key")}toString(e="utf8"){return q(this._buf,e)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(e){return new De(e.join(at))}static random(){return new De(Math.random().toString().substring(2))}static asKey(e){return e instanceof Uint8Array||typeof e=="string"?new De(e):typeof e.uint8Array=="function"?new De(e.uint8Array()):null}clean(){if((this._buf==null||this._buf.byteLength===0)&&(this._buf=Ud),this._buf[0]!==Vr){const e=new Uint8Array(this._buf.byteLength+1);e.fill(Vr,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===Vr;)this._buf=this._buf.subarray(0,-1)}less(e){const t=this.list(),r=e.list();for(let s=0;s<t.length;s++){if(r.length<s+1)return!1;const i=t[s],o=r[s];if(i<o)return!0;if(i>o)return!1}return t.length<r.length}reverse(){return De.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(at).slice(1)}type(){return CE(this.baseNamespace())}name(){return IE(this.baseNamespace())}instance(e){return new De(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(at)||(e+=at),e+=this.type(),new De(e)}parent(){const e=this.list();return e.length===1?new De(at):new De(e.slice(0,-1).join(at))}child(e){return this.toString()===at?e:e.toString()===at?this:new De(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()===this.toString()?!1:e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()===this.toString()?!1:this.toString().startsWith(e.toString())}isTopLevel(){return this.list().length===1}concat(...e){return De.withNamespaces([...this.namespaces(),...TE(e.map(t=>t.namespaces()))])}}function CE(n){const e=n.split(":");return e.length<2?"":e.slice(0,-1).join(":")}function IE(n){const e=n.split(":");return e[e.length-1]}function TE(n){return[].concat(...n)}function PE(n){return e=>new AE(e,n)}const DE=[ht,_r,Ir,Cr,Rn];function kc(n){return Bd("sni",n)?.value}function Rc(n){const e=Bd("tcp",n)?.value;return e==null?"":`:${e}`}function Bd(n,e){return e.find(t=>t.name===n)}function Mc(n){return n.some(({code:e})=>e===ln)}function We(n,e){const t=$d[n.name];if(t==null)throw new Error(`Can't interpret protocol ${n.name}`);const r=t(n,e);return n.code===qe?`[${r}]`:r}const $d={ip4:(n,e)=>n.value,ip6:(n,e)=>e.length===0?n.value:`[${n.value}]`,tcp:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`tcp://${We(t,e)}:${n.value}`},udp:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`udp://${We(t,e)}:${n.value}`},dnsaddr:(n,e)=>n.value,dns4:(n,e)=>n.value,dns6:(n,e)=>n.value,dns:(n,e)=>n.value,ipfs:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`${We(t,e)}`},p2p:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`${We(t,e)}`},http:(n,e)=>{const t=Mc(e),r=kc(e),s=Rc(e);if(t&&r!=null)return`https://${r}${s}`;const i=t?"https://":"http://",o=e.pop();if(o==null)throw new Error("Unexpected end of multiaddr");let a=We(o,e);return a=a?.replace("tcp://",""),`${i}${a}`},"http-path":(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");const r=We(t,e),s=decodeURIComponent(n.value??"");return`${r}${s}`},tls:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return We(t,e)},sni:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return We(t,e)},https:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");let r=We(t,e);return r=r?.replace("tcp://",""),`https://${r}`},ws:(n,e)=>{const t=Mc(e),r=kc(e),s=Rc(e);if(t&&r!=null)return`wss://${r}${s}`;const i=t?"wss://":"ws://",o=e.pop();if(o==null)throw new Error("Unexpected end of multiaddr");let a=We(o,e);return a=a?.replace("tcp://",""),`${i}${a}`},wss:(n,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");let r=We(t,e);return r=r?.replace("tcp://",""),`wss://${r}`}};function LE(n,e){const r=K(n).getComponents(),s=r.pop();if(s==null)throw new Error("Unexpected end of multiaddr");const i=$d[s.name];if(i==null)throw new Error(`No interpreter found for ${s.name}`);let o=i(s,r)??"";return DE.includes(s.code)&&(o=o.replace(/^.*:\/\//,""),s.value==="443"?o=`https://${o}`:o=`http://${o}`),(o.startsWith("http://")||o.startsWith("https://")||o.startsWith("ws://")||o.startsWith("wss://"))&&(o=new URL(o).toString(),o.endsWith("/")&&(o=o.substring(0,o.length-1))),o}const kE=async n=>{if(n.readyState>=2)throw new Error("socket closed");n.readyState!==1&&await new Promise((e,t)=>{function r(){n.removeEventListener("open",s),n.removeEventListener("error",i)}function s(){r(),e()}function i(o){r(),t(o.error??new Error(`connect ECONNREFUSED ${n.url}`))}n.addEventListener("open",s),n.addEventListener("error",i)})},RE=(n,e)=>(e=e??{},e.closeOnEnd=e.closeOnEnd!==!1,async r=>{for await(const s of r){try{await kE(n)}catch(i){if(i.message==="socket closed")break;throw i}if(n.readyState===n.CLOSING||n.readyState===n.CLOSED)break;n.send(s)}e.closeOnEnd!=null&&n.readyState<=1&&await new Promise((s,i)=>{n.addEventListener("close",o=>{if(o.wasClean||o.code===1006)s();else{const a=Object.assign(new Error("ws error"),{event:o});i(a)}}),setTimeout(()=>{n.close()})})});var en={},zn={},Nc;function ME(){if(Nc)return zn;Nc=1,Object.defineProperty(zn,"__esModule",{value:!0});class n{constructor(){this.pullQueue=[],this.pushQueue=[],this.eventHandlers={},this.isPaused=!1,this.isStopped=!1}push(r){if(this.isStopped)return;const s={value:r,done:!1};if(this.pullQueue.length){const i=this.pullQueue.shift();i&&i.resolve(s)}else this.pushQueue.push(Promise.resolve(s)),this.highWaterMark!==void 0&&this.pushQueue.length>=this.highWaterMark&&!this.isPaused&&(this.isPaused=!0,this.eventHandlers.highWater?this.eventHandlers.highWater():console&&console.warn(`EventIterator queue reached ${this.pushQueue.length} items`))}stop(){if(!this.isStopped){this.isStopped=!0,this.remove();for(const r of this.pullQueue)r.resolve({value:void 0,done:!0});this.pullQueue.length=0}}fail(r){if(!this.isStopped)if(this.isStopped=!0,this.remove(),this.pullQueue.length){for(const s of this.pullQueue)s.reject(r);this.pullQueue.length=0}else{const s=Promise.reject(r);s.catch(()=>{}),this.pushQueue.push(s)}}remove(){Promise.resolve().then(()=>{this.removeCallback&&this.removeCallback()})}[Symbol.asyncIterator](){return{next:r=>{const s=this.pushQueue.shift();return s?(this.lowWaterMark!==void 0&&this.pushQueue.length<=this.lowWaterMark&&this.isPaused&&(this.isPaused=!1,this.eventHandlers.lowWater&&this.eventHandlers.lowWater()),s):this.isStopped?Promise.resolve({value:void 0,done:!0}):new Promise((i,o)=>{this.pullQueue.push({resolve:i,reject:o})})},return:()=>(this.isStopped=!0,this.pushQueue.length=0,this.remove(),Promise.resolve({value:void 0,done:!0}))}}}class e{constructor(r,{highWaterMark:s=100,lowWaterMark:i=1}={}){const o=new n;o.highWaterMark=s,o.lowWaterMark=i,o.removeCallback=r({push:a=>o.push(a),stop:()=>o.stop(),fail:a=>o.fail(a),on:(a,c)=>{o.eventHandlers[a]=c}})||(()=>{}),this[Symbol.asyncIterator]=()=>o[Symbol.asyncIterator](),Object.freeze(this)}}return zn.EventIterator=e,zn.default=e,zn}var Oc;function NE(){if(Oc)return en;Oc=1,Object.defineProperty(en,"__esModule",{value:!0});const n=ME();en.EventIterator=n.EventIterator;function e(t,r,s){return new n.EventIterator(({push:i})=>(this.addEventListener(t,i,r),()=>this.removeEventListener(t,i,r)),s)}return en.subscribe=e,en.default=n.EventIterator,en}var OE=NE();function Fc(n){return n instanceof ArrayBuffer||n?.constructor?.name==="ArrayBuffer"&&typeof n?.byteLength=="number"}const FE=n=>{n.binaryType="arraybuffer";const e=async()=>{await new Promise((i,o)=>{if(r){i();return}if(s!=null){o(s);return}const a=l=>{n.removeEventListener("open",c),n.removeEventListener("error",u),l()},c=()=>{a(i)},u=l=>{a(()=>{o(l.error??new Error(`connect ECONNREFUSED ${n.url}`))})};n.addEventListener("open",c),n.addEventListener("error",u)})},t=async function*(){const i=new OE.EventIterator(({push:o,stop:a,fail:c})=>{const u=d=>{let h=null;typeof d.data=="string"&&(h=$(d.data)),Fc(d.data)&&(h=new Uint8Array(d.data)),d.data instanceof Uint8Array&&(h=d.data),h!=null&&o(h)},l=d=>{c(d.error??new Error("Socket error"))};return n.addEventListener("message",u),n.addEventListener("error",l),n.addEventListener("close",a),()=>{n.removeEventListener("message",u),n.removeEventListener("error",l),n.removeEventListener("close",a)}},{highWaterMark:1/0});await e();for await(const o of i)yield Fc(o)?new Uint8Array(o):o}();let r=n.readyState===1,s;return n.addEventListener("open",()=>{r=!0,s=null}),n.addEventListener("close",()=>{r=!1,s=null}),n.addEventListener("error",i=>{r||(s=i.error??new Error(`connect ECONNREFUSED ${n.url}`))}),Object.assign(t,{connected:e})},UE=(n,e)=>{e=e??{};const t=FE(n);let r=e.remoteAddress,s=e.remotePort;if(n.url!=null)try{const o=new URL(n.url);r=o.hostname,s=parseInt(o.port,10)}catch{}if(r==null||s==null)throw new Error("Remote connection did not have address and/or port");return{sink:RE(n,e),source:t,connected:async()=>{await t.connected()},close:async()=>{(n.readyState===n.CONNECTING||n.readyState===n.OPEN)&&await new Promise(o=>{n.addEventListener("close",()=>{o()}),n.close()})},destroy:()=>{n.terminate!=null?n.terminate():n.close()},remoteAddress:r,remotePort:s,socket:n}},BE=WebSocket,$E={"http:":"ws:","https:":"wss:"},Uc="ws:",zE=(n,e)=>{if(n.startsWith("//")&&(n=`${e?.protocol??Uc}${n}`),n.startsWith("/")&&e!=null){const r=e.protocol??Uc,s=e.host,i=e.port!=null&&s?.endsWith(`:${e.port}`)!==!0?`:${e.port}`:"";n=`${r}//${s}${i}${n}`}const t=new URL(n);for(const[r,s]of Object.entries($E))t.protocol===r&&(t.protocol=s);return t};function qE(n,e){const t=typeof window>"u"?void 0:window.location;e=e??{};const r=zE(n,t),s=new BE(r.toString(),e.websocket);return UE(s,e)}function zd(n){return n.filter(e=>Ts.exactMatch(e)||hr.exactMatch(e))}function KE(){throw new Error("WebSocket Servers can not be created in the browser!")}const WE=500;function VE(n,e,t){const r=t.logger.forComponent("libp2p:websockets:maconn"),s=t.metrics,i=t.metricPrefix??"",o={log:r,async sink(a){try{await n.sink(async function*(){for await(const c of a)c instanceof Uint8Array?yield c:yield c.subarray()}())}catch(c){c.type!=="aborted"&&r.error(c)}},source:n.source,remoteAddr:e,timeline:{open:Date.now()},async close(a={}){const c=Date.now();if(a.signal==null){const l=AbortSignal.timeout(WE);a={...a,signal:l}}const u=()=>{const{host:l,port:d}=o.remoteAddr.toOptions();r("timeout closing stream to %s:%s after %dms, destroying it manually",l,d,Date.now()-c),this.abort(new Ft("Socket close timeout"))};a.signal?.addEventListener("abort",u);try{await n.close()}catch(l){r.error("error closing WebSocket gracefully",l),this.abort(l)}finally{a.signal?.removeEventListener("abort",u),o.timeline.close=Date.now()}},abort(a){const{host:c,port:u}=o.remoteAddr.toOptions();r("timeout closing stream to %s:%s due to error",c,u,a),n.destroy(),o.timeline.close=Date.now(),s?.increment({[`${i}error`]:!0})}};return n.socket.addEventListener("close",()=>{s?.increment({[`${i}close`]:!0}),o.timeline.close==null&&(o.timeline.close=Date.now())},{once:!0}),o}class HE{log;init;logger;metrics;components;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:websockets"),this.logger=e.logger,this.components=e,this.init=t,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total",{label:"event",help:"Total count of WebSockets dialer events by type"})})}[xo]=!0;[Symbol.toStringTag]="@libp2p/websockets";[Qe]=["@libp2p/transport"];async dial(e,t){this.log("dialing %s",e),t=t??{};const r=await this._connect(e,t),s=VE(r,e,{logger:this.logger,metrics:this.metrics?.dialerEvents});this.log("new outbound connection %s",s.remoteAddr);const i=await t.upgrader.upgradeOutbound(s,t);return this.log("outbound connection %s upgraded",s.remoteAddr),i}async _connect(e,t){t?.signal?.throwIfAborted();const r=e.toOptions();this.log("dialing %s:%s",r.host,r.port);const s=V(),i=qE(LE(e),this.init);i.socket.addEventListener("error",()=>{const o=new wl(`Could not connect to ${e.toString()}`);this.log.error("connection error:",o),this.metrics?.dialerEvents.increment({error:!0}),s.reject(o)});try{t.onProgress?.(new ee("websockets:open-connection")),await oe(Promise.race([i.connected(),s.promise]),t.signal)}catch(o){throw t.signal?.aborted&&this.metrics?.dialerEvents.increment({abort:!0}),i.close().catch(a=>{this.log.error("error closing raw socket",a)}),o}return this.log("connected %s",e),this.metrics?.dialerEvents.increment({connect:!0}),i}createListener(e){return KE({logger:this.logger,events:this.components.events,metrics:this.components.metrics},{...this.init,...e})}listenFilter(e){return e=Array.isArray(e)?e:[e],this.init?.filter!=null?this.init?.filter(e):zd(e)}dialFilter(e){return this.listenFilter(e)}}function GE(n={}){return e=>new HE(e,n)}function ks(n){if(typeof n!="object"||n===null)return!1;const e=Object.getPrototypeOf(n);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(Symbol.toStringTag in n)&&!(Symbol.iterator in n)}const{hasOwnProperty:qd}=Object.prototype,{propertyIsEnumerable:QE}=Object,_n=(n,e,t)=>{Object.defineProperty(n,e,{value:t,writable:!0,enumerable:!0,configurable:!0})},YE=void 0,Bc={concatArrays:!1,ignoreUndefined:!1},ei=n=>{const e=[];for(const t in n)qd.call(n,t)&&e.push(t);if(Object.getOwnPropertySymbols){const t=Object.getOwnPropertySymbols(n);for(const r of t)QE.call(n,r)&&e.push(r)}return e};function Nn(n){return Array.isArray(n)?XE(n):ks(n)?ZE(n):n}function XE(n){const e=n.slice(0,0);return ei(n).forEach(t=>{_n(e,t,Nn(n[t]))}),e}function ZE(n){const e=Object.getPrototypeOf(n)===null?Object.create(null):{};return ei(n).forEach(t=>{_n(e,t,Nn(n[t]))}),e}const Kd=(n,e,t,r)=>(t.forEach(s=>{typeof e[s]>"u"&&r.ignoreUndefined||(s in n&&n[s]!==Object.getPrototypeOf(n)?_n(n,s,yo(n[s],e[s],r)):_n(n,s,Nn(e[s])))}),n),jE=(n,e,t)=>{let r=n.slice(0,0),s=0;return[n,e].forEach(i=>{const o=[];for(let a=0;a<i.length;a++)qd.call(i,a)&&(o.push(String(a)),i===n?_n(r,s++,i[a]):_n(r,s++,Nn(i[a])));r=Kd(r,i,ei(i).filter(a=>!o.includes(a)),t)}),r};function yo(n,e,t){return t.concatArrays&&Array.isArray(n)&&Array.isArray(e)?jE(n,e,t):!ks(e)||!ks(n)?Nn(e):Kd(n,e,ei(e),t)}function Wd(...n){const e=yo(Nn(Bc),this!==YE&&this||{},Bc);let t={_:{}};for(const r of n)if(r!==void 0){if(!ks(r))throw new TypeError("`"+r+"` is not an Option Object");t=yo(t,{_:r},e)}return t._}var Ai={exports:{}},$c;function JE(){return $c||($c=1,function(n){var e=Object.prototype.hasOwnProperty,t="~";function r(){}Object.create&&(r.prototype=Object.create(null),new r().__proto__||(t=!1));function s(c,u,l){this.fn=c,this.context=u,this.once=l||!1}function i(c,u,l,d,h){if(typeof l!="function")throw new TypeError("The listener must be a function");var p=new s(l,d||c,h),g=t?t+u:u;return c._events[g]?c._events[g].fn?c._events[g]=[c._events[g],p]:c._events[g].push(p):(c._events[g]=p,c._eventsCount++),c}function o(c,u){--c._eventsCount===0?c._events=new r:delete c._events[u]}function a(){this._events=new r,this._eventsCount=0}a.prototype.eventNames=function(){var u=[],l,d;if(this._eventsCount===0)return u;for(d in l=this._events)e.call(l,d)&&u.push(t?d.slice(1):d);return Object.getOwnPropertySymbols?u.concat(Object.getOwnPropertySymbols(l)):u},a.prototype.listeners=function(u){var l=t?t+u:u,d=this._events[l];if(!d)return[];if(d.fn)return[d.fn];for(var h=0,p=d.length,g=new Array(p);h<p;h++)g[h]=d[h].fn;return g},a.prototype.listenerCount=function(u){var l=t?t+u:u,d=this._events[l];return d?d.fn?1:d.length:0},a.prototype.emit=function(u,l,d,h,p,g){var m=t?t+u:u;if(!this._events[m])return!1;var f=this._events[m],w=arguments.length,v,x;if(f.fn){switch(f.once&&this.removeListener(u,f.fn,void 0,!0),w){case 1:return f.fn.call(f.context),!0;case 2:return f.fn.call(f.context,l),!0;case 3:return f.fn.call(f.context,l,d),!0;case 4:return f.fn.call(f.context,l,d,h),!0;case 5:return f.fn.call(f.context,l,d,h,p),!0;case 6:return f.fn.call(f.context,l,d,h,p,g),!0}for(x=1,v=new Array(w-1);x<w;x++)v[x-1]=arguments[x];f.fn.apply(f.context,v)}else{var L=f.length,E;for(x=0;x<L;x++)switch(f[x].once&&this.removeListener(u,f[x].fn,void 0,!0),w){case 1:f[x].fn.call(f[x].context);break;case 2:f[x].fn.call(f[x].context,l);break;case 3:f[x].fn.call(f[x].context,l,d);break;case 4:f[x].fn.call(f[x].context,l,d,h);break;default:if(!v)for(E=1,v=new Array(w-1);E<w;E++)v[E-1]=arguments[E];f[x].fn.apply(f[x].context,v)}}return!0},a.prototype.on=function(u,l,d){return i(this,u,l,d,!1)},a.prototype.once=function(u,l,d){return i(this,u,l,d,!0)},a.prototype.removeListener=function(u,l,d,h){var p=t?t+u:u;if(!this._events[p])return this;if(!l)return o(this,p),this;var g=this._events[p];if(g.fn)g.fn===l&&(!h||g.once)&&(!d||g.context===d)&&o(this,p);else{for(var m=0,f=[],w=g.length;m<w;m++)(g[m].fn!==l||h&&!g[m].once||d&&g[m].context!==d)&&f.push(g[m]);f.length?this._events[p]=f.length===1?f[0]:f:o(this,p)}return this},a.prototype.removeAllListeners=function(u){var l;return u?(l=t?t+u:u,this._events[l]&&o(this,l)):(this._events=new r,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=t,a.EventEmitter=a,n.exports=a}(Ai)),Ai.exports}var ev=JE();const tv=ia(ev);function nv(n,e,t){let r=0,s=n.length;for(;s>0;){const i=Math.trunc(s/2);let o=r+i;t(n[o],e)<=0?(r=++o,s-=i+1):s=i}return r}let rv=class{#e=[];enqueue(e,t){t={priority:0,...t};const r={priority:t.priority,id:t.id,run:e};if(this.size===0||this.#e[this.size-1].priority>=t.priority){this.#e.push(r);return}const s=nv(this.#e,r,(i,o)=>o.priority-i.priority);this.#e.splice(s,0,r)}setPriority(e,t){const r=this.#e.findIndex(i=>i.id===e);if(r===-1)throw new ReferenceError(`No promise function with the id "${e}" exists in the queue.`);const[s]=this.#e.splice(r,1);this.enqueue(s.run,{priority:t,id:e})}dequeue(){return this.#e.shift()?.run}filter(e){return this.#e.filter(t=>t.priority===e.priority).map(t=>t.run)}get size(){return this.#e.length}};class sv extends tv{#e;#n;#t=0;#f;#a;#p=0;#s;#c;#r;#g;#i=0;#l;#o;#m;#b=1n;timeout;constructor(e){if(super(),e={carryoverConcurrencyCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:rv,...e},!(typeof e.intervalCap=="number"&&e.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${e.intervalCap?.toString()??""}\` (${typeof e.intervalCap})`);if(e.interval===void 0||!(Number.isFinite(e.interval)&&e.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${e.interval?.toString()??""}\` (${typeof e.interval})`);this.#e=e.carryoverConcurrencyCount,this.#n=e.intervalCap===Number.POSITIVE_INFINITY||e.interval===0,this.#f=e.intervalCap,this.#a=e.interval,this.#r=new e.queueClass,this.#g=e.queueClass,this.concurrency=e.concurrency,this.timeout=e.timeout,this.#m=e.throwOnTimeout===!0,this.#o=e.autoStart===!1}get#E(){return this.#n||this.#t<this.#f}get#v(){return this.#i<this.#l}#S(){this.#i--,this.#u(),this.emit("next")}#x(){this.#w(),this.#y(),this.#c=void 0}get#A(){const e=Date.now();if(this.#s===void 0){const t=this.#p-e;if(t<0)this.#t=this.#e?this.#i:0;else return this.#c===void 0&&(this.#c=setTimeout(()=>{this.#x()},t)),!0}return!1}#u(){if(this.#r.size===0)return this.#s&&clearInterval(this.#s),this.#s=void 0,this.emit("empty"),this.#i===0&&this.emit("idle"),!1;if(!this.#o){const e=!this.#A;if(this.#E&&this.#v){const t=this.#r.dequeue();return t?(this.emit("active"),t(),e&&this.#y(),!0):!1}}return!1}#y(){this.#n||this.#s!==void 0||(this.#s=setInterval(()=>{this.#w()},this.#a),this.#p=Date.now()+this.#a)}#w(){this.#t===0&&this.#i===0&&this.#s&&(clearInterval(this.#s),this.#s=void 0),this.#t=this.#e?this.#i:0,this.#d()}#d(){for(;this.#u(););}get concurrency(){return this.#l}set concurrency(e){if(!(typeof e=="number"&&e>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);this.#l=e,this.#d()}async#_(e){return new Promise((t,r)=>{e.addEventListener("abort",()=>{r(e.reason)},{once:!0})})}setPriority(e,t){this.#r.setPriority(e,t)}async add(e,t={}){return t.id??=(this.#b++).toString(),t={timeout:this.timeout,throwOnTimeout:this.#m,...t},new Promise((r,s)=>{this.#r.enqueue(async()=>{this.#i++,this.#t++;try{t.signal?.throwIfAborted();let i=e({signal:t.signal});t.timeout&&(i=aa(Promise.resolve(i),{milliseconds:t.timeout})),t.signal&&(i=Promise.race([i,this.#_(t.signal)]));const o=await i;r(o),this.emit("completed",o)}catch(i){if(i instanceof Dd&&!t.throwOnTimeout){r();return}s(i),this.emit("error",i)}finally{this.#S()}},t),this.emit("add"),this.#u()})}async addAll(e,t){return Promise.all(e.map(async r=>this.add(r,t)))}start(){return this.#o?(this.#o=!1,this.#d(),this):this}pause(){this.#o=!0}clear(){this.#r=new this.#g}async onEmpty(){this.#r.size!==0&&await this.#h("empty")}async onSizeLessThan(e){this.#r.size<e||await this.#h("next",()=>this.#r.size<e)}async onIdle(){this.#i===0&&this.#r.size===0||await this.#h("idle")}async#h(e,t){return new Promise(r=>{const s=()=>{t&&!t()||(this.off(e,s),r())};this.on(e,s)})}get size(){return this.#r.size}sizeBy(e){return this.#r.filter(e).length}get pending(){return this.#i}get isPaused(){return this.#o}}function Vd(n){const e=[Pt.A];return n==null?e:Array.isArray(n)?n.length===0?e:n:[n]}const Hd=60;function Gd(n){return{Status:n.Status??0,TC:n.TC??n.flag_tc??!1,RD:n.RD??n.flag_rd??!1,RA:n.RA??n.flag_ra??!1,AD:n.AD??n.flag_ad??!1,CD:n.CD??n.flag_cd??!1,Question:(n.Question??n.questions??[]).map(e=>({name:e.name,type:Pt[e.type]})),Answer:(n.Answer??n.answers??[]).map(e=>({name:e.name,type:Pt[e.type],TTL:e.TTL??e.ttl??Hd,data:e.data instanceof Uint8Array?q(e.data):e.data}))}}const iv=4;function zc(n,e={}){const t=new sv({concurrency:e.queryConcurrency??iv});return async(r,s={})=>{const i=new URLSearchParams;i.set("name",r),Vd(s.types).forEach(a=>{i.append("type",Pt[a])}),s.onProgress?.(new ee("dns:query",{detail:r}));const o=await t.add(async()=>{const a=await fetch(`${n}?${i}`,{headers:{accept:"application/dns-json"},signal:s?.signal});if(a.status!==200)throw new Error(`Unexpected HTTP status: ${a.status} - ${a.statusText}`);const c=Gd(await a.json());return s.onProgress?.(new ee("dns:response",{detail:c})),c},{signal:s.signal});if(o==null)throw new Error("No DNS response received");return o}}function ov(){return[zc("https://cloudflare-dns.com/dns-query"),zc("https://dns.google/resolve")]}var _i,qc;function av(){return qc||(qc=1,_i=function(n){if(!n)throw Error("hashlru must have a max value, of type number, greater than 0");var e=0,t=Object.create(null),r=Object.create(null);function s(i,o){t[i]=o,e++,e>=n&&(e=0,r=t,t=Object.create(null))}return{has:function(i){return t[i]!==void 0||r[i]!==void 0},remove:function(i){t[i]!==void 0&&(t[i]=void 0),r[i]!==void 0&&(r[i]=void 0)},get:function(i){var o=t[i];if(o!==void 0)return o;if((o=r[i])!==void 0)return s(i,o),o},set:function(i,o){t[i]!==void 0?t[i]=o:s(i,o)},clear:function(){t=Object.create(null),r=Object.create(null)}}}),_i}var cv=av();const lv=ia(cv);class uv{lru;constructor(e){this.lru=lv(e)}get(e,t){let r=!0;const s=[];for(const i of t){const o=this.getAnswers(e,i);if(o.length===0){r=!1;break}s.push(...o)}if(r)return Gd({answers:s})}getAnswers(e,t){const r=`${e.toLowerCase()}-${t}`,s=this.lru.get(r);if(s!=null){const i=s.filter(o=>o.expires>Date.now()).map(({expires:o,value:a})=>({...a,TTL:Math.round((o-Date.now())/1e3),type:Pt[a.type]}));return i.length===0&&this.lru.remove(r),i}return[]}add(e,t){const r=`${e.toLowerCase()}-${t.type}`,s=this.lru.get(r)??[];s.push({expires:Date.now()+(t.TTL??Hd)*1e3,value:t}),this.lru.set(r,s)}remove(e,t){const r=`${e.toLowerCase()}-${t}`;this.lru.remove(r)}clear(){this.lru.clear()}}function dv(n){return new uv(n)}const hv=1e3;class fv{resolvers;cache;constructor(e){this.resolvers={},this.cache=dv(e.cacheSize??hv),Object.entries(e.resolvers??{}).forEach(([t,r])=>{Array.isArray(r)||(r=[r]),t.endsWith(".")||(t=`${t}.`),this.resolvers[t]=r}),this.resolvers["."]==null&&(this.resolvers["."]=ov())}async query(e,t={}){const r=Vd(t.types),s=t.cached!==!1?this.cache.get(e,r):void 0;if(s!=null)return t.onProgress?.(new ee("dns:cache",{detail:s})),s;const i=`${e.split(".").pop()}.`,o=(this.resolvers[i]??this.resolvers["."]).sort(()=>Math.random()>.5?-1:1),a=[];for(const c of o){if(t.signal?.aborted===!0)break;try{const u=await c(e,{...t,types:r});for(const l of u.Answer)this.cache.add(e,l);return u}catch(u){a.push(u),t.onProgress?.(new ee("dns:error",{detail:u}))}}throw a.length===1?a[0]:new AggregateError(a,`DNS lookup of ${e} ${r} failed`)}}var Pt;(function(n){n[n.A=1]="A",n[n.CNAME=5]="CNAME",n[n.TXT=16]="TXT",n[n.AAAA=28]="AAAA"})(Pt||(Pt={}));function pv(n={}){return new fv(n)}class gv{dns;canResolve(e){return e.getComponents().some(({name:t})=>t==="dnsaddr")}async resolve(e,t){const r=e.getComponents().find(c=>c.name==="dnsaddr")?.value;if(r==null)return[e];const i=await this.getDNS(t).query(`_dnsaddr.${r}`,{signal:t?.signal,types:[Pt.TXT]}),o=e.getComponents().find(c=>c.name==="p2p")?.value,a=[];for(const c of i.Answer){const u=c.data.replace(/["']/g,"").trim().split("=")[1];u!=null&&(o!=null&&!u.includes(o)||a.push(K(u)))}return a}getDNS(e){return e.dns!=null?e.dns:(this.dns==null&&(this.dns=pv()),this.dns)}}const ua=new gv,mv={addresses:{listen:[],announce:[],noAnnounce:[],announceFilter:n=>n},connectionManager:{resolvers:{dnsaddr:ua}},transportManager:{faultTolerance:rr.FATAL_ALL}};async function yv(n){const e=Wd(mv,n);if(e.connectionProtector===null&&globalThis.process?.env?.LIBP2P_FORCE_PNET!=null)throw new z("Private network is enforced, but no protector was provided");return e}const Cn=1e3,In=Cn*60,Tn=In*60,Vt=Tn*24,wv=Vt*7,bv=Vt*365.25;function Qd(n,e){try{if(typeof n=="string"&&n.length>0)return Ev(n);if(typeof n=="number"&&isFinite(n))return e?.long?Sv(n):vv(n);throw new Error("Value is not a string or number.")}catch(t){const r=xv(t)?`${t.message}. value=${JSON.stringify(n)}`:"An unknown error has occured.";throw new Error(r)}}function Ev(n){if(n=String(n),n.length>100)throw new Error("Value exceeds the maximum length of 100 characters.");const e=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(n);if(!e)return NaN;const t=parseFloat(e[1]),r=(e[2]||"ms").toLowerCase();switch(r){case"years":case"year":case"yrs":case"yr":case"y":return t*bv;case"weeks":case"week":case"w":return t*wv;case"days":case"day":case"d":return t*Vt;case"hours":case"hour":case"hrs":case"hr":case"h":return t*Tn;case"minutes":case"minute":case"mins":case"min":case"m":return t*In;case"seconds":case"second":case"secs":case"sec":case"s":return t*Cn;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:throw new Error(`The unit ${r} was matched, but no matching case exists.`)}}function vv(n){const e=Math.abs(n);return e>=Vt?`${Math.round(n/Vt)}d`:e>=Tn?`${Math.round(n/Tn)}h`:e>=In?`${Math.round(n/In)}m`:e>=Cn?`${Math.round(n/Cn)}s`:`${n}ms`}function Sv(n){const e=Math.abs(n);return e>=Vt?Hr(n,e,Vt,"day"):e>=Tn?Hr(n,e,Tn,"hour"):e>=In?Hr(n,e,In,"minute"):e>=Cn?Hr(n,e,Cn,"second"):`${n} ms`}function Hr(n,e,t,r){const s=e>=t*1.5;return`${Math.round(n/t)} ${r}${s?"s":""}`}function xv(n){return typeof n=="object"&&n!==null&&"message"in n}function Av(n){t.debug=t,t.default=t,t.coerce=c,t.disable=i,t.enable=s,t.enabled=o,t.humanize=Qd,t.destroy=u,Object.keys(n).forEach(l=>{t[l]=n[l]}),t.names=[],t.skips=[],t.formatters={};function e(l){let d=0;for(let h=0;h<l.length;h++)d=(d<<5)-d+l.charCodeAt(h),d|=0;return t.colors[Math.abs(d)%t.colors.length]}t.selectColor=e;function t(l){let d,h=null,p,g;function m(...f){if(!m.enabled)return;const w=m,v=Number(new Date),x=v-(d||v);w.diff=x,w.prev=d,w.curr=v,d=v,f[0]=t.coerce(f[0]),typeof f[0]!="string"&&f.unshift("%O");let L=0;f[0]=f[0].replace(/%([a-zA-Z%])/g,(T,k)=>{if(T==="%%")return"%";L++;const D=t.formatters[k];if(typeof D=="function"){const y=f[L];T=D.call(w,y),f.splice(L,1),L--}return T}),t.formatArgs.call(w,f),(w.log||t.log).apply(w,f)}return m.namespace=l,m.useColors=t.useColors(),m.color=t.selectColor(l),m.extend=r,m.destroy=t.destroy,Object.defineProperty(m,"enabled",{enumerable:!0,configurable:!1,get:()=>h!==null?h:(p!==t.namespaces&&(p=t.namespaces,g=t.enabled(l)),g),set:f=>{h=f}}),typeof t.init=="function"&&t.init(m),m}function r(l,d){const h=t(this.namespace+(typeof d>"u"?":":d)+l);return h.log=this.log,h}function s(l){t.save(l),t.namespaces=l,t.names=[],t.skips=[];let d;const h=(typeof l=="string"?l:"").split(/[\s,]+/),p=h.length;for(d=0;d<p;d++)h[d]&&(l=h[d].replace(/\*/g,".*?"),l[0]==="-"?t.skips.push(new RegExp("^"+l.substr(1)+"$")):t.names.push(new RegExp("^"+l+"$")))}function i(){const l=[...t.names.map(a),...t.skips.map(a).map(d=>"-"+d)].join(",");return t.enable(""),l}function o(l){if(l[l.length-1]==="*")return!0;let d,h;for(d=0,h=t.skips.length;d<h;d++)if(t.skips[d].test(l))return!1;for(d=0,h=t.names.length;d<h;d++)if(t.names[d].test(l))return!0;return!1}function a(l){return l.toString().substring(2,l.toString().length-2).replace(/\.\*\?$/,"*")}function c(l){return l instanceof Error?l.stack??l.message:l}function u(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return t.setupFormatters(t.formatters),t.enable(t.load()),t}var _v={};const Rs=kv(),Cv=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function Iv(){return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/(edge|trident)\/(\d+)/)!=null?!1:typeof document<"u"&&document.documentElement?.style?.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/firefox\/(\d+)/)!=null&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/applewebkit\/(\d+)/)}function Tv(n){if(n[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+n[0]+(this.useColors?"%c ":" ")+"+"+Qd(this.diff),!this.useColors)return;const e="color: "+this.color;n.splice(1,0,e,"color: inherit");let t=0,r=0;n[0].replace(/%[a-zA-Z%]/g,s=>{s!=="%%"&&(t++,s==="%c"&&(r=t))}),n.splice(r,0,e)}const Pv=console.debug??console.log??(()=>{});function Dv(n){try{n?Rs?.setItem("debug",n):Rs?.removeItem("debug")}catch{}}function Lv(){let n;try{n=Rs?.getItem("debug")}catch{}return!n&&typeof globalThis.process<"u"&&"env"in globalThis.process&&(n=_v.DEBUG),n}function kv(){try{return localStorage}catch{}}function Rv(n){n.j=function(e){try{return JSON.stringify(e)}catch(t){return"[UnexpectedJSONParseError]: "+t.message}}}const Ue=Av({formatArgs:Tv,save:Dv,load:Lv,useColors:Iv,setupFormatters:Rv,colors:Cv,storage:Rs,log:Pv});Ue.formatters.b=n=>n==null?"undefined":ge.baseEncode(n);Ue.formatters.t=n=>n==null?"undefined":_t.baseEncode(n);Ue.formatters.m=n=>n==null?"undefined":Dl.baseEncode(n);Ue.formatters.p=n=>n==null?"undefined":n.toString();Ue.formatters.c=n=>n==null?"undefined":n.toString();Ue.formatters.k=n=>n==null?"undefined":n.toString();Ue.formatters.a=n=>n==null?"undefined":n.toString();Ue.formatters.e=n=>n==null?"undefined":Kc(n.stack)??Kc(n.message)??n.toString();function Mv(n){const e=()=>{};return e.enabled=!1,e.color="",e.diff=0,e.log=()=>{},e.namespace=n,e.destroy=()=>!0,e.extend=()=>e,e}function Yd(){return{forComponent(n){return Nv(n)}}}function Nv(n){let e=Mv(`${n}:trace`);return Ue.enabled(`${n}:trace`)&&Ue.names.map(t=>t.toString()).find(t=>t.includes(":trace"))!=null&&(e=Ue(`${n}:trace`)),Object.assign(Ue(n),{error:Ue(`${n}:error`),trace:e})}function Kc(n){if(n!=null&&(n=n.trim(),n.length!==0))return n}function Ov(n){return n[Symbol.asyncIterator]!=null}function wo(n){if(Ov(n))return(async()=>{const t=[];for await(const r of n)t.push(r);return t})();const e=[];for(const t of n)e.push(t);return e}class Fv extends Error{static name="QueueFullError";constructor(e="The queue was full"){super(e),this.name="QueueFullError"}}class Uv{deferred;signal;constructor(e){this.signal=e,this.deferred=Promise.withResolvers(),this.onAbort=this.onAbort.bind(this),this.signal?.addEventListener("abort",this.onAbort)}onAbort(){this.deferred.reject(this.signal?.reason??new xn)}cleanup(){this.signal?.removeEventListener("abort",this.onAbort)}}function Bv(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}class $v{id;fn;options;recipients;status;timeline;controller;constructor(e,t){this.id=Bv(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,r)=>t&&r.signal?.aborted===!0,!0)&&(this.controller.abort(new xn),this.cleanup())}async join(e={}){const t=new Uv(e.signal);return this.recipients.push(t),e.signal?.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await oe(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{e.cleanup(),e.signal?.removeEventListener("abort",this.onAbort)})}}function Wc(n,e){let t;const r=function(){const s=function(){t=void 0,n()};clearTimeout(t),t=setTimeout(s,e)};return r.start=()=>{},r.stop=()=>{clearTimeout(t)},r}class Vc extends tt{concurrency;maxSize;queue;pending;sort;autoStart;constructor(e={}){super(),this.concurrency=e.concurrency??Number.POSITIVE_INFINITY,this.maxSize=e.maxSize??Number.POSITIVE_INFINITY,this.pending=0,this.autoStart=e.autoStart??!0,this.sort=e.sort,this.queue=[],this.emitEmpty=Wc(this.emitEmpty.bind(this),1),this.emitIdle=Wc(this.emitIdle.bind(this),1)}[Symbol.asyncIterator](){return this.toGenerator()}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(const t of this.queue)if(t.status==="queued"){e=t;break}return e==null?!1:(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let t=0;t<this.queue.length;t++)if(this.queue[t]===e){this.queue.splice(t,1);break}this.pending--,this.safeDispatchEvent("next"),this.autoStart&&this.tryToStartAnother()}),!0)}return!1}enqueue(e){this.queue.push(e),this.sort!=null&&this.queue.sort(this.sort)}start(){this.autoStart===!1&&(this.autoStart=!0,this.tryToStartAnother())}pause(){this.autoStart=!1}async add(e,t){if(t?.signal?.throwIfAborted(),this.size===this.maxSize)throw new Fv;const r=new $v(e,t);return this.enqueue(r),this.safeDispatchEvent("add"),this.autoStart&&this.tryToStartAnother(),r.join(t).then(s=>(this.safeDispatchEvent("success",{detail:{job:r,result:s}}),s)).catch(s=>{if(r.status==="queued"){for(let i=0;i<this.queue.length;i++)if(this.queue[i]===r){this.queue.splice(i,1);break}}throw this.safeDispatchEvent("failure",{detail:{job:r,error:s}}),s})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new xn)}),this.clear()}async onEmpty(e){this.size!==0&&await ft(this,"empty",e?.signal)}async onSizeLessThan(e,t){this.size<e||await ft(this,"next",t?.signal,{filter:()=>this.size<e})}async onIdle(e){this.pending===0&&this.size===0||await ft(this,"idle",e?.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){e?.signal?.throwIfAborted();const t=kn({objectMode:!0}),r=c=>{c!=null?this.abort():this.clear(),t.end(c)},s=c=>{c.detail!=null&&t.push(c.detail.result)},i=c=>{r(c.detail.error)},o=()=>{r()},a=()=>{r(new xn("Queue aborted"))};this.addEventListener("success",s),this.addEventListener("failure",i),this.addEventListener("idle",o),e?.signal?.addEventListener("abort",a);try{yield*t}finally{this.removeEventListener("success",s),this.removeEventListener("failure",i),this.removeEventListener("idle",o),e?.signal?.removeEventListener("abort",a),r()}}}const Xd="lock:worker:request-read",Zd="lock:worker:abort-read-request",jd="lock:worker:release-read",Jd="lock:master:grant-read",eh="lock:master:error-read",th="lock:worker:request-write",nh="lock:worker:abort-write-request",rh="lock:worker:release-write",sh="lock:master:grant-write",ih="lock:master:error-write",oh="lock:worker:finalize",ah="mortice",zv={singleProcess:!1},Hc=(n,e,t,r,s,i,o,a,c)=>u=>{if(u.data==null)return;const l={type:u.data.type,name:u.data.name,identifier:u.data.identifier};l.type===s&&n.safeDispatchEvent(t,{detail:{name:l.name,identifier:l.identifier,handler:async()=>{e.postMessage({type:c,name:l.name,identifier:l.identifier}),await new Promise(d=>{const h=p=>{if(p?.data==null)return;const g={type:p.data.type,name:p.data.name,identifier:p.data.identifier};g.type===a&&g.identifier===l.identifier&&(e.removeEventListener("message",h),d())};e.addEventListener("message",h)})},onError:d=>{e.postMessage({type:o,name:l.name,identifier:l.identifier,error:{message:d.message,name:d.name,stack:d.stack}})}}}),l.type===i&&n.safeDispatchEvent(r,{detail:{name:l.name,identifier:l.identifier}}),l.type===oh&&n.safeDispatchEvent("finalizeRequest",{detail:{name:l.name}})},qv=(n=10)=>Math.random().toString().substring(2,n+2);class Kv{name;channel;constructor(e){this.name=e,this.channel=new BroadcastChannel(ah)}readLock(e){return this.sendRequest(Xd,Zd,Jd,eh,jd,e)}writeLock(e){return this.sendRequest(th,nh,sh,ih,rh,e)}finalize(){this.channel.postMessage({type:oh,name:this.name}),this.channel.close()}async sendRequest(e,t,r,s,i,o){o?.signal?.throwIfAborted();const a=qv();return this.channel.postMessage({type:e,identifier:a,name:this.name}),new Promise((c,u)=>{const l=()=>{this.channel.postMessage({type:t,identifier:a,name:this.name})};o?.signal?.addEventListener("abort",l,{once:!0});const d=h=>{if(h.data?.identifier===a&&(h.data?.type===r&&(this.channel.removeEventListener("message",d),o?.signal?.removeEventListener("abort",l),c(()=>{this.channel.postMessage({type:i,identifier:a,name:this.name})})),h.data.type===s)){this.channel.removeEventListener("message",d),o?.signal?.removeEventListener("abort",l);const p=new Error;h.data.error!=null&&(p.message=h.data.error.message,p.name=h.data.error.name,p.stack=h.data.error.stack),u(p)}};this.channel.addEventListener("message",d)})}}const Wv=n=>{if(n=Object.assign({},zv,n),!!globalThis.document||n.singleProcess){const t=new BroadcastChannel(ah),r=new tt;return t.addEventListener("message",Hc(r,t,"requestReadLock","abortReadLockRequest",Xd,Zd,eh,jd,Jd)),t.addEventListener("message",Hc(r,t,"requestWriteLock","abortWriteLockRequest",th,nh,ih,rh,sh)),r}return new Kv(n.name)},Mt=new Map;let qn;function ch(n){return typeof n?.readLock=="function"&&typeof n?.writeLock=="function"}function Vv(n){if(qn==null&&(qn=Wv(n),!ch(qn))){const e=qn;e.addEventListener("requestReadLock",t=>{const r=t.detail.name,s=t.detail.identifier,i=Mt.get(r);if(i==null)return;const o=new AbortController,a=c=>{c.detail.name!==r||c.detail.identifier!==s||o.abort()};e.addEventListener("abortReadLockRequest",a),i.readLock({signal:o.signal}).then(async c=>{await t.detail.handler().finally(()=>{c()})}).catch(c=>{t.detail.onError(c)}).finally(()=>{e.removeEventListener("abortReadLockRequest",a)})}),e.addEventListener("requestWriteLock",t=>{const r=t.detail.name,s=t.detail.identifier,i=Mt.get(r);if(i==null)return;const o=new AbortController,a=c=>{c.detail.name!==r||c.detail.identifier!==s||o.abort()};e.addEventListener("abortWriteLockRequest",a),i.writeLock({signal:o.signal}).then(async c=>{await t.detail.handler().finally(()=>{c()})}).catch(c=>{t.detail.onError(c)}).finally(()=>{e.removeEventListener("abortWriteLockRequest",a)})}),e.addEventListener("finalizeRequest",t=>{const r=t.detail.name,s=Mt.get(r);s?.finalize()})}return qn}async function Ci(n,e){let t,r;const s=new Promise((o,a)=>{t=o,r=a}),i=()=>{r(new xn)};return e?.signal?.addEventListener("abort",i,{once:!0}),n.add(async()=>{await new Promise(o=>{t(()=>{e?.signal?.removeEventListener("abort",i),o()})})},{signal:e?.signal}).catch(o=>{r(o)}),s}const Hv=(n,e)=>{let t=Mt.get(n);if(t!=null)return t;const r=Vv(e);if(ch(r))return t=r,Mt.set(n,t),t;const s=new Vc({concurrency:1});let i;return t={async readLock(o){if(i!=null)return Ci(i,o);i=new Vc({concurrency:e.concurrency,autoStart:!1});const a=i,c=Ci(i,o);return s.add(async()=>{a.start(),await a.onIdle().then(()=>{i===a&&(i=null)})}),c},async writeLock(o){return i=null,Ci(s,o)},finalize:()=>{Mt.delete(n)},queue:s},Mt.set(n,t),e.autoFinalize===!0&&s.addEventListener("idle",()=>{t.finalize()},{once:!0}),t},Gv={name:"lock",concurrency:1/0,singleProcess:!1,autoFinalize:!1};function Qv(n){const e=Object.assign({},Gv,n);return Hv(e.name,e)}const Yv=36e5,Xv=216e5;var Nt;(function(n){(function(t){let r;t.codec=()=>(r==null&&(r=fe((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&s.value.byteLength>0&&(i.uint32(18),i.bytes(s.value)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={key:"",value:j(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const u=s.uint32();switch(u>>>3){case 1:{a.key=s.string();break}case 2:{a.value=s.bytes();break}default:{s.skipType(u&7);break}}}return a})),r),t.encode=s=>he(s,t.codec()),t.decode=(s,i)=>de(s,t.codec(),i)})(n.Peer$metadataEntry||(n.Peer$metadataEntry={})),function(t){let r;t.codec=()=>(r==null&&(r=fe((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&(i.uint32(18),Ns.codec().encode(s.value,i)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={key:""},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const u=s.uint32();switch(u>>>3){case 1:{a.key=s.string();break}case 2:{a.value=Ns.codec().decode(s,s.uint32(),{limits:o.limits?.value});break}default:{s.skipType(u&7);break}}}return a})),r),t.encode=s=>he(s,t.codec()),t.decode=(s,i)=>de(s,t.codec(),i)}(n.Peer$tagsEntry||(n.Peer$tagsEntry={}));let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.addresses!=null)for(const i of t.addresses)r.uint32(10),Ms.codec().encode(i,r);if(t.protocols!=null)for(const i of t.protocols)r.uint32(18),r.string(i);if(t.publicKey!=null&&(r.uint32(34),r.bytes(t.publicKey)),t.peerRecordEnvelope!=null&&(r.uint32(42),r.bytes(t.peerRecordEnvelope)),t.metadata!=null&&t.metadata.size!==0)for(const[i,o]of t.metadata.entries())r.uint32(50),n.Peer$metadataEntry.codec().encode({key:i,value:o},r);if(t.tags!=null&&t.tags.size!==0)for(const[i,o]of t.tags.entries())r.uint32(58),n.Peer$tagsEntry.codec().encode({key:i,value:o},r);t.updated!=null&&(r.uint32(64),r.uint64Number(t.updated)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={addresses:[],protocols:[],metadata:new Map,tags:new Map},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{if(s.limits?.addresses!=null&&i.addresses.length===s.limits.addresses)throw new pt('Decode error - map field "addresses" had too many elements');i.addresses.push(Ms.codec().decode(t,t.uint32(),{limits:s.limits?.addresses$}));break}case 2:{if(s.limits?.protocols!=null&&i.protocols.length===s.limits.protocols)throw new pt('Decode error - map field "protocols" had too many elements');i.protocols.push(t.string());break}case 4:{i.publicKey=t.bytes();break}case 5:{i.peerRecordEnvelope=t.bytes();break}case 6:{if(s.limits?.metadata!=null&&i.metadata.size===s.limits.metadata)throw new Oa('Decode error - map field "metadata" had too many elements');const c=n.Peer$metadataEntry.codec().decode(t,t.uint32());i.metadata.set(c.key,c.value);break}case 7:{if(s.limits?.tags!=null&&i.tags.size===s.limits.tags)throw new Oa('Decode error - map field "tags" had too many elements');const c=n.Peer$tagsEntry.codec().decode(t,t.uint32(),{limits:{value:s.limits?.tags$value}});i.tags.set(c.key,c.value);break}case 8:{i.updated=t.uint64Number();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(Nt||(Nt={}));var Ms;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.multiaddr!=null&&t.multiaddr.byteLength>0&&(r.uint32(10),r.bytes(t.multiaddr)),t.isCertified!=null&&(r.uint32(16),r.bool(t.isCertified)),t.observed!=null&&(r.uint32(24),r.uint64Number(t.observed)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={multiaddr:j(0)},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.multiaddr=t.bytes();break}case 2:{i.isCertified=t.bool();break}case 3:{i.observed=t.uint64Number();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(Ms||(Ms={}));var Ns;(function(n){let e;n.codec=()=>(e==null&&(e=fe((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.value!=null&&t.value!==0&&(r.uint32(8),r.uint32(t.value)),t.expiry!=null&&(r.uint32(16),r.uint64(t.expiry)),s.lengthDelimited!==!1&&r.ldelim()},(t,r,s={})=>{const i={value:0},o=r==null?t.len:t.pos+r;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.value=t.uint32();break}case 2:{i.expiry=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),n.encode=t=>he(t,n.codec()),n.decode=(t,r)=>de(t,n.codec(),r)})(Ns||(Ns={}));function Zv(n,e){if(n.publicKey!=null||e.publicKey==null)return n;let t;n.type==="RSA"&&(t=n.toMultihash());const r=It(e.publicKey,t);return or(r)}function jv(n,e,t){const r=Nt.decode(e);return Hn(n,r,t)}function Hn(n,e,t){const r=new Map,s=BigInt(Date.now());for(const[i,o]of e.tags.entries())o.expiry!=null&&o.expiry<s||r.set(i,o);return{...e,id:Zv(n,e),addresses:e.addresses.filter(({observed:i})=>i!=null&&i>Date.now()-t).map(({multiaddr:i,isCertified:o})=>({multiaddr:K(i),isCertified:o??!1})),metadata:e.metadata,peerRecordEnvelope:e.peerRecordEnvelope??void 0,tags:r}}function Jv(n,e){return e1(n.addresses,e.addresses)&&t1(n.protocols,e.protocols)&&n1(n.publicKey,e.publicKey)&&r1(n.peerRecordEnvelope,e.peerRecordEnvelope)&&s1(n.metadata,e.metadata)&&i1(n.tags,e.tags)}function e1(n,e){return uh(n,e,(t,r)=>!(t.isCertified!==r.isCertified||!Te(t.multiaddr,r.multiaddr)))}function t1(n,e){return uh(n,e,(t,r)=>t===r)}function n1(n,e){return lh(n,e)}function r1(n,e){return lh(n,e)}function s1(n,e){return dh(n,e,(t,r)=>Te(t,r))}function i1(n,e){return dh(n,e,(t,r)=>t.value===r.value&&t.expiry===r.expiry)}function lh(n,e){return n==null&&e==null?!0:n!=null&&e!=null?Te(n,e):!1}function uh(n,e,t){if(n.length!==e.length)return!1;for(let r=0;r<n.length;r++)if(!t(n[r],e[r]))return!1;return!0}function dh(n,e,t){if(n.size!==e.size)return!1;for(const[r,s]of n.entries()){const i=e.get(r);if(i==null||!t(s,i))return!1}return!0}const hh="/peers/";function Gr(n){if(!Qn(n)||n.type==null)throw new z("Invalid PeerId");const e=n.toCID().toString();return new De(`${hh}${e}`)}async function o1(n,e,t,r,s){const i=new Map;for(const o of t){if(o==null)continue;if(o.multiaddr instanceof Uint8Array&&(o.multiaddr=K(o.multiaddr)),!Gs(o.multiaddr))throw new z("Multiaddr was invalid");if(!await e(n,o.multiaddr,s))continue;const a=o.isCertified??!1,c=o.multiaddr.toString(),u=i.get(c);u!=null?o.isCertified=u.isCertified||a:i.set(c,{multiaddr:o.multiaddr,isCertified:a})}return[...i.values()].sort((o,a)=>o.multiaddr.toString().localeCompare(a.multiaddr.toString())).map(({isCertified:o,multiaddr:a})=>{const c=a.getPeerId();return n.equals(c)&&(a=a.decapsulate(K(`/p2p/${n}`))),{isCertified:o,multiaddr:a.bytes}})}async function Ii(n,e,t,r){if(e==null)throw new z("Invalid PeerData");if(e.publicKey!=null&&n.publicKey!=null&&!e.publicKey.equals(n.publicKey))throw new z("publicKey bytes do not match peer id publicKey bytes");const s=r.existingPeer?.peer;if(s!=null&&!n.equals(s.id))throw new z("peer id did not match existing peer id");let i=s?.addresses??[],o=new Set(s?.protocols??[]),a=s?.metadata??new Map,c=s?.tags??new Map,u=s?.peerRecordEnvelope;if(t==="patch"){if((e.multiaddrs!=null||e.addresses!=null)&&(i=[],e.multiaddrs!=null&&i.push(...e.multiaddrs.map(h=>({isCertified:!1,multiaddr:h}))),e.addresses!=null&&i.push(...e.addresses)),e.protocols!=null&&(o=new Set(e.protocols)),e.metadata!=null){const h=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);a=Qr(h,{validate:Gc})}if(e.tags!=null){const h=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags);c=Qr(h,{validate:Qc,map:Yc})}e.peerRecordEnvelope!=null&&(u=e.peerRecordEnvelope)}if(t==="merge"){if(e.multiaddrs!=null&&i.push(...e.multiaddrs.map(h=>({isCertified:!1,multiaddr:h}))),e.addresses!=null&&i.push(...e.addresses),e.protocols!=null&&(o=new Set([...o,...e.protocols])),e.metadata!=null){const h=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);for(const[p,g]of h)g==null?a.delete(p):a.set(p,g);a=Qr([...a.entries()],{validate:Gc})}if(e.tags!=null){const h=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags),p=new Map(c);for(const[g,m]of h)m==null?p.delete(g):p.set(g,m);c=Qr([...p.entries()],{validate:Qc,map:Yc})}e.peerRecordEnvelope!=null&&(u=e.peerRecordEnvelope)}let l;s?.id.publicKey!=null?l=dt(s.id.publicKey):e.publicKey!=null?l=dt(e.publicKey):n.publicKey!=null&&(l=dt(n.publicKey));const d={addresses:await o1(n,r.addressFilter??(async()=>!0),i,r.existingPeer?.peerPB.addresses,r),protocols:[...o.values()].sort((h,p)=>h.localeCompare(p)),metadata:a,tags:c,publicKey:l,peerRecordEnvelope:u};return d.addresses.forEach(h=>{h.observed=r.existingPeer?.peerPB.addresses?.find(p=>Te(p.multiaddr,p.multiaddr))?.observed??Date.now()}),n.type!=="RSA"&&delete d.publicKey,d}function Qr(n,e){const t=new Map;for(const[r,s]of n)s!=null&&e.validate(r,s);for(const[r,s]of n.sort(([i],[o])=>i.localeCompare(o)))s!=null&&t.set(r,e.map?.(r,s)??s);return t}function Gc(n,e){if(typeof n!="string")throw new z("Metadata key must be a string");if(!(e instanceof Uint8Array))throw new z("Metadata value must be a Uint8Array")}function Qc(n,e){if(typeof n!="string")throw new z("Tag name must be a string");if(e.value!=null){if(parseInt(`${e.value}`,10)!==e.value)throw new z("Tag value must be an integer");if(e.value<0||e.value>100)throw new z("Tag value must be between 0-100")}if(e.ttl!=null){if(parseInt(`${e.ttl}`,10)!==e.ttl)throw new z("Tag ttl must be an integer");if(e.ttl<0)throw new z("Tag ttl must be between greater than 0")}}function Yc(n,e){let t;e.expiry!=null&&(t=e.expiry),e.ttl!=null&&(t=BigInt(Date.now()+Number(e.ttl)));const r={value:e.value??0};return t!=null&&(r.expiry=t),r}function fh(n){const e=n.toString().split("/")[2],t=re.parse(e,_t);return xr(t)}function Ti(n,e,t){const r=fh(n);return jv(r,e,t)}function a1(n,e){return{prefix:hh,filters:(n.filters??[]).map(t=>({key:r,value:s})=>t(Ti(r,s,e))),orders:(n.orders??[]).map(t=>(r,s)=>t(Ti(r.key,r.value,e),Ti(s.key,s.value,e)))}}class c1{peerId;datastore;locks;addressFilter;log;maxAddressAge;maxPeerAge;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.peerId=e.peerId,this.datastore=e.datastore,this.addressFilter=t.addressFilter,this.locks=Gb({name:"libp2p_peer_store_locks",metrics:e.metrics}),this.maxAddressAge=t.maxAddressAge??Yv,this.maxPeerAge=t.maxPeerAge??Xv}getLock(e){let t=this.locks.get(e);return t==null&&(t={refs:0,lock:Qv({name:e.toString(),singleProcess:!0})},this.locks.set(e,t)),t.refs++,t}maybeRemoveLock(e,t){t.refs--,t.refs===0&&(t.lock.finalize(),this.locks.delete(e))}async getReadLock(e,t){const r=this.getLock(e);try{const s=await r.lock.readLock(t);return()=>{s(),this.maybeRemoveLock(e,r)}}catch(s){throw this.maybeRemoveLock(e,r),s}}async getWriteLock(e,t){const r=this.getLock(e);try{const s=await r.lock.writeLock(t);return()=>{s(),this.maybeRemoveLock(e,r)}}catch(s){throw this.maybeRemoveLock(e,r),s}}async has(e,t){try{return await this.load(e,t),!0}catch(r){if(r.name!=="NotFoundError")throw r}return!1}async delete(e,t){this.peerId.equals(e)||await this.datastore.delete(Gr(e),t)}async load(e,t){const r=Gr(e),s=await this.datastore.get(r,t),i=Nt.decode(s);if(this.#t(e,i))throw await this.datastore.delete(r,t),new Wi;return Hn(e,i,this.peerId.equals(e)?1/0:this.maxAddressAge)}async save(e,t,r){const s=await this.#e(e,r),i=await Ii(e,t,"patch",{...r,addressFilter:this.addressFilter});return this.#n(e,i,s)}async patch(e,t,r){const s=await this.#e(e,r),i=await Ii(e,t,"patch",{...r,addressFilter:this.addressFilter,existingPeer:s});return this.#n(e,i,s)}async merge(e,t,r){const s=await this.#e(e,r),i=await Ii(e,t,"merge",{addressFilter:this.addressFilter,existingPeer:s});return this.#n(e,i,s)}async*all(e){for await(const{key:t,value:r}of this.datastore.query(a1(e??{},this.maxAddressAge),e)){const s=fh(t);if(s.equals(this.peerId))continue;const i=Nt.decode(r);if(this.#t(s,i)){await this.datastore.delete(t,e);continue}yield Hn(s,i,this.peerId.equals(s)?1/0:this.maxAddressAge)}}async#e(e,t){try{const r=Gr(e),s=await this.datastore.get(r,t),i=Nt.decode(s);if(this.#t(e,i))throw await this.datastore.delete(r,t),new Wi;return{peerPB:i,peer:Hn(e,i,this.maxAddressAge)}}catch(r){r.name!=="NotFoundError"&&this.log.error("invalid peer data found in peer store - %e",r)}}async#n(e,t,r,s){t.updated=Date.now();const i=Nt.encode(t);return await this.datastore.put(Gr(e),i,s),{peer:Hn(e,t,this.maxAddressAge),previous:r?.peer,updated:r==null||!Jv(t,r.peerPB)}}#t(e,t){if(t.updated==null)return!0;if(this.peerId.equals(e))return!1;const r=t.updated<Date.now()-this.maxPeerAge,s=Date.now()-this.maxAddressAge,i=t.addresses.filter(o=>o.observed!=null&&o.observed>s);return r&&i.length===0}}class l1{store;events;peerId;log;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.events=e.events,this.peerId=e.peerId,this.store=new c1(e,t)}[Symbol.toStringTag]="@libp2p/peer-store";async forEach(e,t){for await(const r of this.store.all(t))e(r)}async all(e){return wo(this.store.all(e))}async delete(e,t){const r=await this.store.getReadLock(e,t);try{await this.store.delete(e,t)}finally{r()}}async has(e,t){const r=await this.store.getReadLock(e,t);try{return await this.store.has(e,t)}finally{this.log.trace("has release read lock"),r?.()}}async get(e,t){const r=await this.store.getReadLock(e,t);try{return await this.store.load(e,t)}finally{r?.()}}async getInfo(e,t){const r=await this.get(e,t);return{id:r.id,multiaddrs:r.addresses.map(({multiaddr:s})=>s)}}async save(e,t,r){const s=await this.store.getWriteLock(e,r);try{const i=await this.store.save(e,t,r);return this.#e(e,i),i.peer}finally{s?.()}}async patch(e,t,r){const s=await this.store.getWriteLock(e,r);try{const i=await this.store.patch(e,t,r);return this.#e(e,i),i.peer}finally{s?.()}}async merge(e,t,r){const s=await this.store.getWriteLock(e,r);try{const i=await this.store.merge(e,t,r);return this.#e(e,i),i.peer}finally{s?.()}}async consumePeerRecord(e,t,r){const s=Qn(t)?t:Qn(t?.expectedPeer)?t.expectedPeer:void 0,i=Qn(t)||t===void 0?r:t,o=await Je.openAndCertify(e,Be.DOMAIN,i),a=xr(o.publicKey.toCID());if(s?.equals(a)===!1)return this.log("envelope peer id was not the expected peer id - expected: %p received: %p",s,a),!1;const c=Be.createFromProtobuf(o.payload);let u;try{u=await this.get(a,i)}catch(l){if(l.name!=="NotFoundError")throw l}if(u?.peerRecordEnvelope!=null){const l=Je.createFromProtobuf(u.peerRecordEnvelope),d=Be.createFromProtobuf(l.payload);if(d.seqNumber>=c.seqNumber)return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",d.seqNumber,c.seqNumber),!1}return await this.patch(c.peerId,{peerRecordEnvelope:e,addresses:c.multiaddrs.map(l=>({isCertified:!0,multiaddr:l}))},i),!0}#e(e,t){t.updated&&(this.peerId.equals(e)?this.events.safeDispatchEvent("self:peer:update",{detail:t}):this.events.safeDispatchEvent("peer:update",{detail:t}))}}function u1(n,e={}){return new l1(n,e)}class Os extends Error{static name="NotFoundError";static code="ERR_NOT_FOUND";name=Os.name;code=Os.code;constructor(e="Not Found"){super(e)}}function d1(n){return n[Symbol.asyncIterator]!=null}function tn(n,e){let t=0;if(d1(n))return async function*(){for await(const c of n)await e(c,t++)&&(yield c)}();const r=Ku(n),{value:s,done:i}=r.next();if(i===!0)return function*(){}();const o=e(s,t++);if(typeof o.then=="function")return async function*(){await o&&(yield s);for(const c of r)await e(c,t++)&&(yield c)}();const a=e;return function*(){o===!0&&(yield s);for(const c of r)a(c,t++)&&(yield c)}()}function h1(n){return n[Symbol.asyncIterator]!=null}function Xc(n,e){return h1(n)?async function*(){yield*(await wo(n)).sort(e)}():function*(){yield*wo(n).sort(e)}()}function f1(n){return n[Symbol.asyncIterator]!=null}function Zc(n,e){return f1(n)?async function*(){let t=0;if(!(e<1)){for await(const r of n)if(yield r,t++,t===e)return}}():function*(){let t=0;if(!(e<1)){for(const r of n)if(yield r,t++,t===e)return}}()}class p1{put(e,t,r){return Promise.reject(new Error(".put is not implemented"))}get(e,t){return Promise.reject(new Error(".get is not implemented"))}has(e,t){return Promise.reject(new Error(".has is not implemented"))}delete(e,t){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(e,t={}){for await(const{key:r,value:s}of e)await this.put(r,s,t),yield r}async*getMany(e,t={}){for await(const r of e)yield{key:r,value:await this.get(r,t)}}async*deleteMany(e,t={}){for await(const r of e)await this.delete(r,t),yield r}batch(){let e=[],t=[];return{put(r,s){e.push({key:r,value:s})},delete(r){t.push(r)},commit:async r=>{await po(this.putMany(e,r)),e=[],await po(this.deleteMany(t,r)),t=[]}}}async*_all(e,t){throw new Error("._all is not implemented")}async*_allKeys(e,t){throw new Error("._allKeys is not implemented")}query(e,t){let r=this._all(e,t);if(e.prefix!=null){const s=e.prefix;r=tn(r,i=>i.key.toString().startsWith(s))}if(Array.isArray(e.filters)&&(r=e.filters.reduce((s,i)=>tn(s,i),r)),Array.isArray(e.orders)&&(r=e.orders.reduce((s,i)=>Xc(s,i),r)),e.offset!=null){let s=0;const i=e.offset;r=tn(r,()=>s++>=i)}return e.limit!=null&&(r=Zc(r,e.limit)),r}queryKeys(e,t){let r=this._allKeys(e,t);if(e.prefix!=null){const s=e.prefix;r=tn(r,i=>i.toString().startsWith(s))}if(Array.isArray(e.filters)&&(r=e.filters.reduce((s,i)=>tn(s,i),r)),Array.isArray(e.orders)&&(r=e.orders.reduce((s,i)=>Xc(s,i),r)),e.offset!=null){const s=e.offset;let i=0;r=tn(r,()=>i++>=s)}return e.limit!=null&&(r=Zc(r,e.limit)),r}}class g1 extends p1{data;constructor(){super(),this.data=new Map}put(e,t,r){return r?.signal?.throwIfAborted(),this.data.set(e.toString(),t),e}get(e,t){t?.signal?.throwIfAborted();const r=this.data.get(e.toString());if(r==null)throw new Os;return r}has(e,t){return t?.signal?.throwIfAborted(),this.data.has(e.toString())}delete(e,t){t?.signal?.throwIfAborted(),this.data.delete(e.toString())}*_all(e,t){t?.signal?.throwIfAborted();for(const[r,s]of this.data.entries())yield{key:new De(r),value:s},t?.signal?.throwIfAborted()}*_allKeys(e,t){t?.signal?.throwIfAborted();for(const r of this.data.keys())yield new De(r),t?.signal?.throwIfAborted()}}class m1 extends Map{metric;constructor(e){super();const{name:t,metrics:r}=e;this.metric=r.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){const t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function yt(n){const{name:e,metrics:t}=n;let r;return t!=null?r=new m1({name:e,metrics:t}):r=new Map,r}const jc=864e13,y1=448,Pi=449,w1=53,b1=54,E1=55,v1=56;class S1{log;mappings;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:dns-mappings"),this.mappings=yt({name:"libp2p_address_manager_dns_mappings",metrics:e.metrics})}has(e){const t=this.findHost(e);for(const r of this.mappings.values())if(r.domain===t)return!0;return!1}add(e,t){t.forEach(r=>{this.log("add DNS mapping %s to %s",r,e);const s=Js(r)===!0;this.mappings.set(r,{domain:e,verified:s,expires:s?jc-Date.now():0,lastVerified:s?jc-Date.now():void 0})})}remove(e){const t=this.findHost(e);let r=!1;for(const[s,i]of this.mappings.entries())i.domain===t&&(this.log("removing %s to %s DNS mapping %e",s,i.domain,new Error("where")),this.mappings.delete(s),r=r||i.verified);return r}getAll(e){const t=[];for(let r=0;r<e.length;r++){const i=e[r].multiaddr.stringTuples(),o=i[0][1];if(o!=null)for(const[a,c]of this.mappings.entries()){if(o!==a)continue;this.maybeAddSNITuple(i,c.domain)&&(e.splice(r,1),r--,t.push({multiaddr:K(`/${i.map(l=>[Qs(l[0]).name,l[1]].join("/")).join("/")}`),verified:c.verified,type:"dns-mapping",expires:c.expires,lastVerified:c.lastVerified}))}}return t}maybeAddSNITuple(e,t){for(let r=0;r<e.length;r++)if(e[r][0]===y1&&e[r+1]?.[0]!==Pi)return e.splice(r+1,0,[Pi,t]),!0;return!1}confirm(e,t){const r=this.findHost(e);let s=!1;for(const[i,o]of this.mappings.entries())o.domain===r&&(this.log("marking %s to %s DNS mapping as verified",i,o.domain),s=o.verified,o.verified=!0,o.expires=Date.now()+t,o.lastVerified=Date.now());return s}unconfirm(e,t){const r=this.findHost(e);let s=!1;for(const[i,o]of this.mappings.entries())o.domain===r&&(this.log("removing verification of %s to %s DNS mapping",i,o.domain),s=s||o.verified,o.verified=!1,o.expires=Date.now()+t);return s}findHost(e){for(const t of e.stringTuples())if(t[0]===Pi||t[0]===w1||t[0]===b1||t[0]===E1||t[0]===v1)return t[1]}}const Di=4,Li=41,ki=6,x1=273;class A1{log;mappings;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:ip-mappings"),this.mappings=yt({name:"libp2p_address_manager_ip_mappings",metrics:e.metrics})}has(e){const t=e.stringTuples();for(const r of this.mappings.values())for(const s of r)if(s.externalIp===t[0][1])return!0;return!1}add(e,t,r,s=t,i="tcp"){const o=`${e}-${t}-${i}`,a=this.mappings.get(o)??[],c={internalIp:e,internalPort:t,externalIp:r,externalPort:s,externalFamily:bn(r)?4:6,protocol:i,verified:!1,expires:0};a.push(c),this.mappings.set(o,a)}remove(e){const t=e.stringTuples(),r=t[0][1]??"",s=t[1][0]===ki?"tcp":"udp",i=parseInt(t[1][1]??"0");let o=!1;for(const[a,c]of this.mappings.entries()){for(let u=0;u<c.length;u++){const l=c[u];l.externalIp===r&&l.externalPort===i&&l.protocol===s&&(this.log("removing %s:%s to %s:%s %s IP mapping",l.externalIp,l.externalPort,r,i,s),o=o||l.verified,c.splice(u,1),u--)}c.length===0&&this.mappings.delete(a)}return o}getAll(e){const t=[];for(const{multiaddr:r}of e){const s=r.stringTuples();let i;if((s[0][0]===Di||s[0][0]===Li)&&s[1][0]===ki?i=`${s[0][1]}-${s[1][1]}-tcp`:(s[0][0]===Di||s[0][0]===Li)&&s[1][0]===x1&&(i=`${s[0][1]}-${s[1][1]}-udp`),i==null)continue;const o=this.mappings.get(i);if(o!=null)for(const a of o)s[0][0]=a.externalFamily===4?Di:Li,s[0][1]=a.externalIp,s[1][1]=`${a.externalPort}`,t.push({multiaddr:K(`/${s.map(c=>[Qs(c[0]).name,c[1]].join("/")).join("/")}`),verified:a.verified,type:"ip-mapping",expires:a.expires,lastVerified:a.lastVerified})}return t}confirm(e,t){const s=e.stringTuples()[0][1];let i=!1;for(const o of this.mappings.values())for(const a of o)a.externalIp===s&&(this.log("marking %s to %s IP mapping as verified",a.internalIp,a.externalIp),i=a.verified,a.verified=!0,a.expires=Date.now()+t,a.lastVerified=Date.now());return i}unconfirm(e,t){const r=e.stringTuples(),s=r[0][1]??"",i=r[1][0]===ki?"tcp":"udp",o=parseInt(r[1][1]??"0");let a=!1;for(const c of this.mappings.values())for(let u=0;u<c.length;u++){const l=c[u];l.externalIp===s&&l.externalPort===o&&l.protocol===i&&(this.log("removing verification of %s:%s to %s:%s %s IP mapping",l.externalIp,l.externalPort,s,o,i),a=a||l.verified,l.verified=!1,l.expires=Date.now()+t)}return a}}function _1(n){try{for(const{code:e,value:t}of n.getComponents())if(e!==Ht&&t!=null){if(e===Kt)return t.startsWith("169.254.");if(e===qe)return t.toLowerCase().startsWith("fe80")}}catch{}return!1}const C1={maxObservedAddresses:10};class I1{log;addresses;maxObservedAddresses;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=yt({name:"libp2p_address_manager_observed_addresses",metrics:e.metrics}),this.maxObservedAddresses=t.maxObservedAddresses??C1.maxObservedAddresses}has(e){return this.addresses.has(e.toString())}removePrefixed(e){for(const t of this.addresses.keys())t.toString().startsWith(e)&&this.addresses.delete(t)}add(e){this.addresses.size!==this.maxObservedAddresses&&(gr(e)||_1(e)||(this.log("adding observed address %a",e),this.addresses.set(e.toString(),{verified:!1,expires:0})))}getAll(){return Array.from(this.addresses).map(([e,t])=>({multiaddr:K(e),verified:t.verified,type:"observed",expires:t.expires,lastVerified:t.lastVerified}))}remove(e){const t=this.addresses.get(e.toString())?.verified??!1;return this.log("removing observed address %a",e),this.addresses.delete(e.toString()),t}confirm(e,t){const r=e.toString(),s=this.addresses.get(r)??{verified:!1,expires:Date.now()+t,lastVerified:Date.now()},i=s.verified;return s.verified=!0,s.expires=Date.now()+t,s.lastVerified=Date.now(),this.log("marking observed address %a as verified",r),this.addresses.set(r,s),i}}const T1=[Kt,qe,_r,Cr,Rn,Ir];function Jc(n){try{for(const{code:e}of n.getComponents())if(e!==Ht)return T1.includes(e)}catch{}return!1}const P1={maxObservedAddresses:10};class D1{log;addresses;maxObservedAddresses;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=yt({name:"libp2p_address_manager_transport_addresses",metrics:e.metrics}),this.maxObservedAddresses=t.maxObservedAddresses??P1.maxObservedAddresses}get(e,t){if(gr(e))return{multiaddr:e,verified:!0,type:"transport",expires:Date.now()+t,lastVerified:Date.now()};const r=this.toKey(e);let s=this.addresses.get(r);return s==null&&(s={verified:!Jc(e),expires:0},this.addresses.set(r,s)),{multiaddr:e,verified:s.verified,type:"transport",expires:s.expires,lastVerified:s.lastVerified}}has(e){const t=this.toKey(e);return this.addresses.has(t)}remove(e){const t=this.toKey(e),r=this.addresses.get(t)?.verified??!1;return this.log("removing observed address %a",e),this.addresses.delete(t),r}confirm(e,t){const r=this.toKey(e),s=this.addresses.get(r)??{verified:!1,expires:0,lastVerified:0},i=s.verified;return s.verified=!0,s.expires=Date.now()+t,s.lastVerified=Date.now(),this.addresses.set(r,s),i}unconfirm(e,t){const r=this.toKey(e),s=this.addresses.get(r)??{verified:!1,expires:0},i=s.verified;return s.verified=!1,s.expires=Date.now()+t,this.addresses.set(r,s),i}toKey(e){if(Jc(e)){const t=e.toOptions();return`${t.host}-${t.port}-${t.transport}`}return e.toString()}}const el=6e4,tl={addressVerificationTTL:el*10,addressVerificationRetry:el*5},L1=n=>n;function Ri(n,e){const t=n.getPeerId();return t!=null&&gt(t).equals(e)&&(n=n.decapsulate(K(`/p2p/${e.toString()}`))),n}class k1{log;components;listen;announce;appendAnnounce;announceFilter;observed;dnsMappings;ipMappings;transportAddresses;observedAddressFilter;addressVerificationTTL;addressVerificationRetry;constructor(e,t={}){const{listen:r=[],announce:s=[],appendAnnounce:i=[]}=t;this.components=e,this.log=e.logger.forComponent("libp2p:address-manager"),this.listen=r.map(o=>o.toString()),this.announce=new Set(s.map(o=>o.toString())),this.appendAnnounce=new Set(i.map(o=>o.toString())),this.observed=new I1(e,t),this.dnsMappings=new S1(e,t),this.ipMappings=new A1(e,t),this.transportAddresses=new D1(e,t),this.announceFilter=t.announceFilter??L1,this.observedAddressFilter=pr(1024),this.addressVerificationTTL=t.addressVerificationTTL??tl.addressVerificationTTL,this.addressVerificationRetry=t.addressVerificationRetry??tl.addressVerificationRetry,this._updatePeerStoreAddresses=Ls(this._updatePeerStoreAddresses.bind(this),1e3),e.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),e.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}[Symbol.toStringTag]="@libp2p/address-manager";_updatePeerStoreAddresses(){const e=this.getAddresses().map(t=>t.getPeerId()===this.components.peerId.toString()?t.decapsulate(`/p2p/${this.components.peerId.toString()}`):t);this.components.peerStore.patch(this.components.peerId,{multiaddrs:e}).catch(t=>{this.log.error("error updating addresses",t)})}getListenAddrs(){return Array.from(this.listen).map(e=>K(e))}getAnnounceAddrs(){return Array.from(this.announce).map(e=>K(e))}getAppendAnnounceAddrs(){return Array.from(this.appendAnnounce).map(e=>K(e))}getObservedAddrs(){return this.observed.getAll().map(e=>e.multiaddr)}addObservedAddr(e){const t=e.stringTuples(),r=`${t[0][1]}:${t[1][1]}`;this.observedAddressFilter.has(r)||(this.observedAddressFilter.add(r),e=Ri(e,this.components.peerId),!this.ipMappings.has(e)&&(this.dnsMappings.has(e)||this.observed.add(e)))}confirmObservedAddr(e,t){e=Ri(e,this.components.peerId);let r=!0;(t?.type==="transport"||this.transportAddresses.has(e))&&!this.transportAddresses.confirm(e,t?.ttl??this.addressVerificationTTL)&&r&&(r=!1),(t?.type==="dns-mapping"||this.dnsMappings.has(e))&&!this.dnsMappings.confirm(e,t?.ttl??this.addressVerificationTTL)&&r&&(r=!1),(t?.type==="ip-mapping"||this.ipMappings.has(e))&&!this.ipMappings.confirm(e,t?.ttl??this.addressVerificationTTL)&&r&&(r=!1),(t?.type==="observed"||this.observed.has(e))&&(this.maybeUpgradeToIPMapping(e)?(this.ipMappings.confirm(e,t?.ttl??this.addressVerificationTTL),r=!1):!this.observed.confirm(e,t?.ttl??this.addressVerificationTTL)&&r&&(r=!1)),r||this._updatePeerStoreAddresses()}removeObservedAddr(e,t){e=Ri(e,this.components.peerId),this.observed.has(e)&&this.observed.remove(e),this.transportAddresses.has(e)&&this.transportAddresses.unconfirm(e,t?.ttl??this.addressVerificationRetry),this.dnsMappings.has(e)&&this.dnsMappings.unconfirm(e,t?.ttl??this.addressVerificationRetry),this.ipMappings.has(e)&&this.ipMappings.unconfirm(e,t?.ttl??this.addressVerificationRetry)}getAddresses(){const e=new Set,t=this.getAddressesWithMetadata().filter(r=>{if(!r.verified)return!1;const s=r.multiaddr.toString();return e.has(s)?!1:(e.add(s),!0)}).map(r=>r.multiaddr);return this.announceFilter(t.map(r=>{const s=K(r);return s.getComponents().pop()?.value===this.components.peerId.toString()?s:s.encapsulate(`/p2p/${this.components.peerId.toString()}`)}))}getAddressesWithMetadata(){const e=this.getAnnounceAddrs();if(e.length>0)return this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(e)}),e.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()}));let t=[];t=t.concat(this.components.transportManager.getAddrs().map(s=>this.transportAddresses.get(s,this.addressVerificationTTL)));const r=this.getAppendAnnounceAddrs();return r.length>0&&(this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(r)}),t=t.concat(r.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()})))),t=t.concat(this.observed.getAll()),t=t.concat(this.ipMappings.getAll(t)),t=t.concat(this.dnsMappings.getAll(t)),t}addDNSMapping(e,t){this.dnsMappings.add(e,t)}removeDNSMapping(e){this.dnsMappings.remove(K(`/dns/${e}`))&&this._updatePeerStoreAddresses()}addPublicAddressMapping(e,t,r,s=t,i="tcp"){this.ipMappings.add(e,t,r,s,i),this.observed.removePrefixed(`/ip${bn(r)?4:6}/${r}/${i}/${s}`)}removePublicAddressMapping(e,t,r,s=t,i="tcp"){this.ipMappings.remove(K(`/ip${bn(r)?4:6}/${r}/${i}/${s}`))&&this._updatePeerStoreAddresses()}maybeUpgradeToIPMapping(e){if(this.ipMappings.has(e))return!1;const t=e.toOptions();if(t.family===6||t.host==="127.0.0.1"||Js(t.host)===!0)return!1;const r=this.components.transportManager.getListeners(),s=[i=>hr.exactMatch(i)||Ts.exactMatch(i),i=>Is.exactMatch(i),i=>Cb.exactMatch(i)];for(const i of s){if(!i(e))continue;const o=r.filter(u=>u.getAddrs().filter(l=>l.toOptions().family===4&&i(l)).length>0);if(o.length!==1)continue;const a=o[0].getAddrs().filter(u=>u.toOptions().host!=="127.0.0.1").pop();if(a==null)continue;const c=a.toOptions();return this.observed.remove(e),this.ipMappings.add(c.host,c.port,t.host,t.port,t.transport),!0}return!1}}var nl;(function(n){n.NOT_STARTED_YET="The libp2p node is not started yet",n.NOT_FOUND="Not found"})(nl||(nl={}));class R1 extends Error{constructor(e="Missing service"){super(e),this.name="MissingServiceError"}}class M1 extends Error{constructor(e="Unmet service dependencies"){super(e),this.name="UnmetServiceDependenciesError"}}class Mi extends Error{constructor(e="No content routers available"){super(e),this.name="NoContentRoutersError"}}class rl extends Error{constructor(e="No peer routers available"){super(e),this.name="NoPeerRoutersError"}}class N1 extends Error{constructor(e="Should not try to find self"){super(e),this.name="QueriedForSelfError"}}class O1 extends Error{constructor(e="Unhandled protocol error"){super(e),this.name="UnhandledProtocolError"}}class F1 extends Error{constructor(e="Duplicate protocol handler error"){super(e),this.name="DuplicateProtocolHandlerError"}}class sl extends Error{constructor(e="Dial denied error"){super(e),this.name="DialDeniedError"}}class U1 extends Error{constructor(e="No transport was configured to listen on this address"){super(e),this.name="UnsupportedListenAddressError"}}class B1 extends Error{constructor(e="Configured listen addresses could not be listened on"){super(e),this.name="UnsupportedListenAddressesError"}}class $1 extends Error{constructor(e="No valid addresses"){super(e),this.name="NoValidAddressesError"}}class z1 extends Error{constructor(e="Connection intercepted"){super(e),this.name="ConnectionInterceptedError"}}class q1 extends Error{constructor(e="Connection denied"){super(e),this.name="ConnectionDeniedError"}}class Yr extends Error{constructor(e="Stream is not multiplexed"){super(e),this.name="MuxerUnavailableError"}}class Xr extends Error{constructor(e="Encryption failed"){super(e),this.name="EncryptionFailedError"}}class K1 extends Error{constructor(e="Transport unavailable"){super(e),this.name="TransportUnavailableError"}}class W1 extends Error{constructor(e="Max recursive depth reached"){super(e),this.name="RecursionLimitError"}}class V1{components={};_started=!1;constructor(e={}){this.components={};for(const[t,r]of Object.entries(e))this.components[t]=r;this.components.logger==null&&(this.components.logger=Yd())}isStarted(){return this._started}async _invokeStartableMethod(e){await Promise.all(Object.values(this.components).filter(t=>To(t)).map(async t=>{await t[e]?.()}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const H1=["metrics","connectionProtector","dns"],G1=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function Q1(n={}){const e=new V1(n);return new Proxy(e,{get(r,s,i){if(typeof s=="string"&&!G1.includes(s)){const o=e.components[s];if(o==null&&!H1.includes(s))throw new R1(`${s} not set`);return o}return Reflect.get(r,s,i)},set(r,s,i){return typeof s=="string"?e.components[s]=i:Reflect.set(r,s,i),!0}})}function Y1(n){const e={};for(const t of Object.values(n.components))for(const r of X1(t))e[r]=!0;for(const t of Object.values(n.components))for(const r of Z1(t))if(e[r]!==!0)throw new M1(`Service "${j1(t)}" required capability "${r}" but it was not provided by any component, you may need to add additional configuration when creating your node.`)}function X1(n){return Array.isArray(n?.[Qe])?n[Qe]:[]}function Z1(n){return Array.isArray(n?.[ns])?n[ns]:[]}function j1(n){return n?.[Symbol.toStringTag]??n?.toString()??"unknown"}const J1=4,eS=41;function tS(n={}){return{denyDialPeer:async()=>!1,denyDialMultiaddr:async e=>{if(hr.matches(e))return!1;const t=e.stringTuples();return t[0][0]===J1||t[0][0]===eS?!!Js(`${t[0][1]}`):!1},denyInboundConnection:async()=>!1,denyOutboundConnection:async()=>!1,denyInboundEncryptedConnection:async()=>!1,denyOutboundEncryptedConnection:async()=>!1,denyInboundUpgradedConnection:async()=>!1,denyOutboundUpgradedConnection:async()=>!1,filterMultiaddrForPeer:async()=>!0,...n}}const il=()=>{const n=new Error("Delay aborted");return n.name="AbortError",n},nS=new WeakMap;function rS({clearTimeout:n,setTimeout:e}={}){return(t,{value:r,signal:s}={})=>{if(s?.aborted)return Promise.reject(il());let i,o,a;const c=n??clearTimeout,u=()=>{c(i),a(il())},l=()=>{s&&s.removeEventListener("abort",u)},d=new Promise((h,p)=>{o=()=>{l(),h(r)},a=p,i=(e??setTimeout)(o,t)});return s&&s.addEventListener("abort",u,{once:!0}),nS.set(d,()=>{c(i),i=null,o()}),d}}const sS=rS();class iS{memoryStorage;points;duration;blockDuration;execEvenly;execEvenlyMinDelayMs;keyPrefix;constructor(e={}){this.points=e.points??4,this.duration=e.duration??1,this.blockDuration=e.blockDuration??0,this.execEvenly=e.execEvenly??!1,this.execEvenlyMinDelayMs=e.execEvenlyMinDelayMs??this.duration*1e3/this.points,this.keyPrefix=e.keyPrefix??"rlflx",this.memoryStorage=new oS}async consume(e,t=1,r={}){const s=this.getKey(e),i=this._getKeySecDuration(r);let o=this.memoryStorage.incrby(s,t,i);if(o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o.consumedPoints>this.points)throw this.blockDuration>0&&o.consumedPoints<=this.points+t&&(o=this.memoryStorage.set(s,o.consumedPoints,this.blockDuration)),new Qb("Rate limit exceeded",o);if(this.execEvenly&&o.msBeforeNext>0&&!o.isFirstInDuration){let a=Math.ceil(o.msBeforeNext/(o.remainingPoints+2));a<this.execEvenlyMinDelayMs&&(a=o.consumedPoints*this.execEvenlyMinDelayMs),await sS(a)}return o}penalty(e,t=1,r={}){const s=this.getKey(e),i=this._getKeySecDuration(r),o=this.memoryStorage.incrby(s,t,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}reward(e,t=1,r={}){const s=this.getKey(e),i=this._getKeySecDuration(r),o=this.memoryStorage.incrby(s,-t,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}block(e,t){const r=t*1e3,s=this.points+1;return this.memoryStorage.set(this.getKey(e),s,t),{remainingPoints:0,msBeforeNext:r===0?-1:r,consumedPoints:s,isFirstInDuration:!1}}set(e,t,r=0){const s=(r>=0?r:this.duration)*1e3;return this.memoryStorage.set(this.getKey(e),t,r),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:t,isFirstInDuration:!1}}get(e){const t=this.memoryStorage.get(this.getKey(e));return t!=null&&(t.remainingPoints=Math.max(this.points-t.consumedPoints,0)),t}delete(e){this.memoryStorage.delete(this.getKey(e))}_getKeySecDuration(e){return e?.customDuration!=null&&e.customDuration>=0?e.customDuration:this.duration}getKey(e){return this.keyPrefix.length>0?`${this.keyPrefix}:${e}`:e}parseKey(e){return e.substring(this.keyPrefix.length)}}class oS{storage;constructor(){this.storage=new Map}incrby(e,t,r){const s=this.storage.get(e);if(s!=null){const i=s.expiresAt!=null?s.expiresAt.getTime()-new Date().getTime():-1;return s.expiresAt==null||i>0?(s.value+=t,{remainingPoints:0,msBeforeNext:i,consumedPoints:s.value,isFirstInDuration:!1}):this.set(e,t,r)}return this.set(e,t,r)}set(e,t,r){const s=r*1e3,i=this.storage.get(e);i!=null&&clearTimeout(i.timeoutId);const o={value:t,expiresAt:s>0?new Date(Date.now()+s):void 0};return this.storage.set(e,o),s>0&&(o.timeoutId=setTimeout(()=>{this.storage.delete(e)},s),o.timeoutId.unref!=null&&o.timeoutId.unref()),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:o.value,isFirstInDuration:!0}}get(e){const t=this.storage.get(e);if(t!=null)return{remainingPoints:0,msBeforeNext:t.expiresAt!=null?t.expiresAt.getTime()-new Date().getTime():-1,consumedPoints:t.value,isFirstInDuration:!1}}delete(e){const t=this.storage.get(e);return t!=null?(t.timeoutId!=null&&clearTimeout(t.timeoutId),this.storage.delete(e),!0):!1}}function ph(n){if(Qn(n))return{peerId:n,multiaddrs:[]};let e=Array.isArray(n)?n:[n],t;if(e.length>0){const r=e[0].getPeerId();t=r==null?void 0:gt(r),e.forEach(s=>{if(!Gs(s))throw new Ao("Invalid multiaddr");const i=s.getPeerId();if(i==null){if(t!=null)throw new z("Multiaddrs must all have the same peer id or have no peer id")}else{const o=gt(i);if(t?.equals(o)!==!0)throw new z("Multiaddrs must all have the same peer id or have no peer id")}})}return e=e.filter(r=>!xb.exactMatch(r)),{peerId:t,multiaddrs:e}}const aS=["/ipfs/id/1.0.0","/ipfs/id/push/1.0.0","/libp2p/autonat/1.0.0","/libp2p/dcutr"];async function cS(n,e){const t=n?.streams?.map(s=>s.protocol)??[],r=e?.closableProtocols??aS;if(!(t.filter(s=>s!=null&&!r.includes(s)).length>0))try{await n?.close(e)}catch(s){n?.abort(s)}}function bo(n){try{let e;typeof n=="string"?e=K(n):e=n;const t=new Set([...e.getComponents().map(r=>r.name)]);if(!t.has("ipcidr")){const s=t.has("ip6")?"/ipcidr/128":"/ipcidr/32";e=e.encapsulate(s)}return fb(e)}catch{throw new Error(`Can't convert to IpNet, Invalid multiaddr format: ${n}`)}}class lS{connectionManager;peerStore;allow;events;log;constructor(e,t={}){this.allow=(t.allow??[]).map(r=>bo(r)),this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager:connection-pruner"),this.maybePruneConnections=this.maybePruneConnections.bind(this)}start(){this.events.addEventListener("connection:open",this.maybePruneConnections)}stop(){this.events.removeEventListener("connection:open",this.maybePruneConnections)}maybePruneConnections(){this._maybePruneConnections().catch(e=>{this.log.error("error while pruning connections %e",e)})}async _maybePruneConnections(){const e=this.connectionManager.getConnections(),t=e.length,r=this.connectionManager.getMaxConnections();if(this.log("checking max connections limit %d/%d",t,r),t<=r)return;const s=new Mn;for(const c of e){const u=c.remotePeer;if(!s.has(u)){s.set(u,0);try{const l=await this.peerStore.get(u);s.set(u,[...l.tags.values()].reduce((d,h)=>d+h.value,0))}catch(l){l.name!=="NotFoundError"&&this.log.error("error loading peer tags",l)}}}const i=this.sortConnections(e,s),o=Math.max(t-r,0),a=[];for(const c of i)if(this.log("too many connections open - closing a connection to %p",c.remotePeer),this.allow.some(l=>l.contains(c.remoteAddr.nodeAddress().address))||a.push(c),a.length===o)break;await Promise.all(a.map(async c=>{await cS(c,{signal:AbortSignal.timeout(1e3)})})),this.events.safeDispatchEvent("connection:prune",{detail:a})}sortConnections(e,t){return e.sort((r,s)=>{const i=r.timeline.open,o=s.timeline.open;return i<o?1:i>o?-1:0}).sort((r,s)=>r.direction==="outbound"&&s.direction==="inbound"?1:r.direction==="inbound"&&s.direction==="outbound"?-1:0).sort((r,s)=>r.streams.length>s.streams.length?1:r.streams.length<s.streams.length?-1:0).sort((r,s)=>{const i=t.get(r.remotePeer)??0,o=t.get(s.remotePeer)??0;return i>o?1:i<o?-1:0})}}const gh=1e4,uS=1e4,ol=1e4,mh=25,dS=5,hS=10,fS=5,pS="last-dial-failure",gS="last-dial-success",yh=500,mS=32,yS=100,wh=50;class wS extends xd{constructor(e={}){super({...e,sort:(t,r)=>t.options.priority>r.options.priority?-1:t.options.priority<r.options.priority?1:0})}}function bS(n){return/^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(n)||/^::1$/.test(n)}function al(n){if(!Id(n))return!1;const{address:e}=n.nodeAddress();return bS(e)}function ES(n,e){const t=Is.exactMatch(n.multiaddr),r=Is.exactMatch(e.multiaddr);if(t&&!r)return-1;if(!t&&r)return 1;const s=Ts.exactMatch(n.multiaddr),i=Ts.exactMatch(e.multiaddr);if(s&&!i)return-1;if(!s&&i)return 1;const o=hr.exactMatch(n.multiaddr),a=hr.exactMatch(e.multiaddr);if(o&&!a)return-1;if(!o&&a)return 1;const c=fo.exactMatch(n.multiaddr),u=fo.exactMatch(e.multiaddr);if(c&&!u)return-1;if(!c&&u)return 1;const l=hc.exactMatch(n.multiaddr),d=hc.exactMatch(e.multiaddr);if(l&&!d)return-1;if(!l&&d)return 1;const h=fc.exactMatch(n.multiaddr),p=fc.exactMatch(e.multiaddr);return h&&!p?-1:!h&&p?1:0}function vS(n,e){const t=al(n.multiaddr),r=al(e.multiaddr);return t&&!r?1:!t&&r?-1:0}function SS(n,e){const t=gr(n.multiaddr),r=gr(e.multiaddr);return t&&!r?1:!t&&r?-1:0}function xS(n,e){return n.isCertified&&!e.isCertified?-1:!n.isCertified&&e.isCertified?1:0}function AS(n,e){const t=fr.exactMatch(n.multiaddr),r=fr.exactMatch(e.multiaddr);return t&&!r?1:!t&&r?-1:0}function _S(n){return n.sort(ES).sort(xS).sort(AS).sort(SS).sort(vS)}async function bh(n,e,t){const r=t.depth??0;if(r>(t.maxRecursiveDepth??mS))throw new W1("Max recursive depth reached");let s=!1;const i=[];for(const o of Object.values(e))if(o.canResolve(n)){s=!0;const a=await o.resolve(n,t);for(const c of a)i.push(...await bh(c,e,{...t,depth:r+1}))}return s===!1&&i.push(n),i}const Kn={maxParallelDials:wh,maxDialQueueLength:yh,maxPeerAddrsToDial:mh,dialTimeout:gh,resolvers:{dnsaddr:ua}};class CS{queue;components;addressSorter;maxPeerAddrsToDial;maxDialQueueLength;dialTimeout;shutDownController;connections;log;resolvers;constructor(e,t={}){this.addressSorter=t.addressSorter,this.maxPeerAddrsToDial=t.maxPeerAddrsToDial??Kn.maxPeerAddrsToDial,this.maxDialQueueLength=t.maxDialQueueLength??Kn.maxDialQueueLength,this.dialTimeout=t.dialTimeout??Kn.dialTimeout,this.connections=t.connections??new Mn,this.log=e.logger.forComponent("libp2p:connection-manager:dial-queue"),this.components=e,this.resolvers=t.resolvers??Kn.resolvers,this.shutDownController=new AbortController,this.shutDownController.signal,this.queue=new wS({concurrency:t.maxParallelDials??Kn.maxParallelDials,metricName:"libp2p_dial_queue",metrics:e.metrics}),this.queue.addEventListener("error",r=>{r.detail?.name!==Ft.name&&this.log.error("error in dial queue - %e",r.detail)})}start(){this.shutDownController=new AbortController,this.shutDownController.signal}stop(){this.shutDownController.abort(),this.queue.abort()}async dial(e,t={}){const{peerId:r,multiaddrs:s}=ph(e),i=Array.from(this.connections.values()).flat().find(a=>t.force===!0||a.limits!=null?!1:a.remotePeer.equals(r)?!0:s.find(c=>c.equals(a.remoteAddr)));if(i?.status==="open")return this.log("already connected to %a",i.remoteAddr),t.onProgress?.(new ee("dial-queue:already-connected")),i;const o=this.queue.queue.find(a=>{if(r?.equals(a.options.peerId)===!0)return!0;const c=a.options.multiaddrs;if(c==null)return!1;for(const u of s)if(c.has(u.toString()))return!0;return!1});if(o!=null){this.log("joining existing dial target for %p",r);for(const a of s)o.options.multiaddrs.add(a.toString());return t.onProgress?.(new ee("dial-queue:already-in-dial-queue")),o.join(t)}if(this.queue.size>=this.maxDialQueueLength)throw new Yn("Dial queue is full");return this.log("creating dial target for %p",r,s.map(a=>a.toString())),t.onProgress?.(new ee("dial-queue:add-to-dial-queue")),this.queue.add(async a=>{a.onProgress?.(new ee("dial-queue:start-dial"));const c=Tt([this.shutDownController.signal,a.signal]);try{return await this.dialPeer(a,c)}finally{c.clear()}},{peerId:r,priority:t.priority??Eh,multiaddrs:new Set(s.map(a=>a.toString())),signal:t.signal??AbortSignal.timeout(this.dialTimeout),onProgress:t.onProgress})}async dialPeer(e,t){const r=e.peerId,s=e.multiaddrs,i=new Set;let o=e.multiaddrs.size===0,a=0,c=0;const u=[];for(this.log("starting dial to %p",r);o||s.size>0;){c++,o=!1;const l=[],d=new Set(e.multiaddrs);s.clear(),this.log("calculating addrs to dial %p from %s",r,[...d]);const h=await this.calculateMultiaddrs(r,d,{...e,signal:t});for(const p of h){if(i.has(p.multiaddr.toString())){this.log.trace("skipping previously failed multiaddr %a while dialing %p",p.multiaddr,r);continue}l.push(p)}this.log("%s dial to %p with %s",c===1?"starting":"continuing",r,l.map(p=>p.multiaddr.toString())),e?.onProgress?.(new ee("dial-queue:calculated-addresses",l));for(const p of l){if(a===this.maxPeerAddrsToDial)throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others",a,e.peerId),new Yn("Peer had more than maxPeerAddrsToDial");a++;try{const g=await this.components.transportManager.dial(p.multiaddr,{...e,signal:t});this.log("dial to %a succeeded",p.multiaddr);try{await this.components.peerStore.merge(g.remotePeer,{multiaddrs:[g.remoteAddr],metadata:{[gS]:$(Date.now().toString())}})}catch(m){this.log.error("could not update last dial failure key for %p",r,m)}return g}catch(g){if(this.log.error("dial failed to %a",p.multiaddr,g),i.add(p.multiaddr.toString()),r!=null)try{await this.components.peerStore.merge(r,{metadata:{[pS]:$(Date.now().toString())}})}catch(m){this.log.error("could not update last dial failure key for %p",r,m)}if(t.aborted)throw new Co(g.message);u.push(g)}}}throw u.length===1?u[0]:new AggregateError(u,"All multiaddr dials failed")}async calculateMultiaddrs(e,t=new Set,r={}){const s=[...t].map(d=>({multiaddr:K(d),isCertified:!1}));if(e!=null){if(this.components.peerId.equals(e))throw new Yn("Tried to dial self");if(await this.components.connectionGater.denyDialPeer?.(e)===!0)throw new sl("The dial request is blocked by gater.allowDialPeer");if(s.length===0){this.log("loading multiaddrs for %p",e);try{const d=await this.components.peerStore.get(e);s.push(...d.addresses),this.log("loaded multiaddrs for %p",e,s.map(({multiaddr:h})=>h.toString()))}catch(d){if(d.name!=="NotFoundError")throw d}}if(s.length===0){this.log("looking up multiaddrs for %p in the peer routing",e);try{const d=await this.components.peerRouting.findPeer(e,r);this.log("found multiaddrs for %p in the peer routing",e,s.map(({multiaddr:h})=>h.toString())),s.push(...d.multiaddrs.map(h=>({multiaddr:h,isCertified:!1})))}catch(d){d.name==="NoPeerRoutersError"?this.log("no peer routers configured",e):this.log.error("looking up multiaddrs for %p in the peer routing failed - %e",e,d)}}}let i=(await Promise.all(s.map(async d=>{const h=await bh(d.multiaddr,this.resolvers,{dns:this.components.dns,log:this.log,...r});return h.length===1&&h[0].equals(d.multiaddr)?d:h.map(p=>({multiaddr:p,isCertified:!1}))}))).flat();if(e!=null){const d=`/p2p/${e.toString()}`;i=i.map(h=>h.multiaddr.getComponents().pop()?.name!=="p2p"?{multiaddr:h.multiaddr.encapsulate(d),isCertified:h.isCertified}:h)}const o=i.filter(d=>{if(this.components.transportManager.dialTransportForMultiaddr(d.multiaddr)==null)return!1;const h=d.multiaddr.getPeerId();return e!=null&&h!=null?e.equals(h):!0}),a=new Map;for(const d of o){const h=d.multiaddr.toString(),p=a.get(h);if(p!=null){p.isCertified=p.isCertified||d.isCertified||!1;continue}a.set(h,d)}const c=[...a.values()];if(c.length===0)throw new $1("The dial request has no valid addresses");const u=[];for(const d of c)this.components.connectionGater.denyDialMultiaddr!=null&&await this.components.connectionGater.denyDialMultiaddr(d.multiaddr)||u.push(d);const l=this.addressSorter==null?_S(u):u.sort(this.addressSorter);if(l.length===0)throw new sl("The connection gater denied all addresses in the dial request");return this.log.trace("addresses for %p before filtering",e??"unknown peer",i.map(({multiaddr:d})=>d.toString())),this.log.trace("addresses for %p after filtering",e??"unknown peer",l.map(({multiaddr:d})=>d.toString())),l}async isDialable(e,t={}){Array.isArray(e)||(e=[e]);try{const r=await this.calculateMultiaddrs(void 0,new Set(e.map(s=>s.toString())),t);return t.runOnLimitedConnection===!1?r.find(s=>!fr.matches(s.multiaddr))!=null:!0}catch(r){this.log.trace("error calculating if multiaddr(s) were dialable",r)}return!1}}var Ni={},Oi,cl;function IS(){if(cl)return Oi;cl=1;function n(e,t){typeof t=="boolean"&&(t={forever:t}),this._originalTimeouts=JSON.parse(JSON.stringify(e)),this._timeouts=e,this._options=t||{},this._maxRetryTime=t&&t.maxRetryTime||1/0,this._fn=null,this._errors=[],this._attempts=1,this._operationTimeout=null,this._operationTimeoutCb=null,this._timeout=null,this._operationStart=null,this._timer=null,this._options.forever&&(this._cachedTimeouts=this._timeouts.slice(0))}return Oi=n,n.prototype.reset=function(){this._attempts=1,this._timeouts=this._originalTimeouts.slice(0)},n.prototype.stop=function(){this._timeout&&clearTimeout(this._timeout),this._timer&&clearTimeout(this._timer),this._timeouts=[],this._cachedTimeouts=null},n.prototype.retry=function(e){if(this._timeout&&clearTimeout(this._timeout),!e)return!1;var t=new Date().getTime();if(e&&t-this._operationStart>=this._maxRetryTime)return this._errors.push(e),this._errors.unshift(new Error("RetryOperation timeout occurred")),!1;this._errors.push(e);var r=this._timeouts.shift();if(r===void 0)if(this._cachedTimeouts)this._errors.splice(0,this._errors.length-1),r=this._cachedTimeouts.slice(-1);else return!1;var s=this;return this._timer=setTimeout(function(){s._attempts++,s._operationTimeoutCb&&(s._timeout=setTimeout(function(){s._operationTimeoutCb(s._attempts)},s._operationTimeout),s._options.unref&&s._timeout.unref()),s._fn(s._attempts)},r),this._options.unref&&this._timer.unref(),!0},n.prototype.attempt=function(e,t){this._fn=e,t&&(t.timeout&&(this._operationTimeout=t.timeout),t.cb&&(this._operationTimeoutCb=t.cb));var r=this;this._operationTimeoutCb&&(this._timeout=setTimeout(function(){r._operationTimeoutCb()},r._operationTimeout)),this._operationStart=new Date().getTime(),this._fn(this._attempts)},n.prototype.try=function(e){console.log("Using RetryOperation.try() is deprecated"),this.attempt(e)},n.prototype.start=function(e){console.log("Using RetryOperation.start() is deprecated"),this.attempt(e)},n.prototype.start=n.prototype.try,n.prototype.errors=function(){return this._errors},n.prototype.attempts=function(){return this._attempts},n.prototype.mainError=function(){if(this._errors.length===0)return null;for(var e={},t=null,r=0,s=0;s<this._errors.length;s++){var i=this._errors[s],o=i.message,a=(e[o]||0)+1;e[o]=a,a>=r&&(t=i,r=a)}return t},Oi}var ll;function TS(){return ll||(ll=1,function(n){var e=IS();n.operation=function(t){var r=n.timeouts(t);return new e(r,{forever:t&&(t.forever||t.retries===1/0),unref:t&&t.unref,maxRetryTime:t&&t.maxRetryTime})},n.timeouts=function(t){if(t instanceof Array)return[].concat(t);var r={retries:10,factor:2,minTimeout:1*1e3,maxTimeout:1/0,randomize:!1};for(var s in t)r[s]=t[s];if(r.minTimeout>r.maxTimeout)throw new Error("minTimeout is greater than maxTimeout");for(var i=[],o=0;o<r.retries;o++)i.push(this.createTimeout(o,r));return t&&t.forever&&!i.length&&i.push(this.createTimeout(o,r)),i.sort(function(a,c){return a-c}),i},n.createTimeout=function(t,r){var s=r.randomize?Math.random()+1:1,i=Math.round(s*Math.max(r.minTimeout,1)*Math.pow(r.factor,t));return i=Math.min(i,r.maxTimeout),i},n.wrap=function(t,r,s){if(r instanceof Array&&(s=r,r=null),!s){s=[];for(var i in t)typeof t[i]=="function"&&s.push(i)}for(var o=0;o<s.length;o++){var a=s[o],c=t[a];t[a]=function(l){var d=n.operation(r),h=Array.prototype.slice.call(arguments,1),p=h.pop();h.push(function(g){d.retry(g)||(g&&(arguments[0]=d.mainError()),p.apply(this,arguments))}),d.attempt(function(){l.apply(t,h)})}.bind(t,c),t[a].options=r}}}(Ni)),Ni}var Fi,ul;function PS(){return ul||(ul=1,Fi=TS()),Fi}var DS=PS();const LS=ia(DS),kS=Object.prototype.toString,RS=n=>kS.call(n)==="[object Error]",MS=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Load failed","Network request failed","fetch failed","terminated"]);function NS(n){return n&&RS(n)&&n.name==="TypeError"&&typeof n.message=="string"?n.message==="Load failed"?n.stack===void 0:MS.has(n.message):!1}class OS extends Error{constructor(e){super(),e instanceof Error?(this.originalError=e,{message:e}=e):(this.originalError=new Error(e),this.originalError.stack=this.stack),this.name="AbortError",this.message=e}}const dl=(n,e,t)=>{const r=t.retries-(e-1);return n.attemptNumber=e,n.retriesLeft=r,n};async function FS(n,e){return new Promise((t,r)=>{e={...e},e.onFailedAttempt??=()=>{},e.shouldRetry??=()=>!0,e.retries??=10;const s=LS.operation(e),i=()=>{s.stop(),r(e.signal?.reason)};e.signal&&!e.signal.aborted&&e.signal.addEventListener("abort",i,{once:!0});const o=()=>{e.signal?.removeEventListener("abort",i),s.stop()};s.attempt(async a=>{try{const c=await n(a);o(),t(c)}catch(c){try{if(!(c instanceof Error))throw new TypeError(`Non-error was thrown: "${c}". You should only throw errors.`);if(c instanceof OS)throw c.originalError;if(c instanceof TypeError&&!NS(c))throw c;if(dl(c,a,e),await e.shouldRetry(c)||(s.stop(),r(c)),await e.onFailedAttempt(c),!s.retry(c))throw s.mainError()}catch(u){dl(u,a,e),o(),r(u)}}})})}class US{log;queue;started;peerStore;retries;retryInterval;backoffFactor;connectionManager;events;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:reconnect-queue"),this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.queue=new sa({concurrency:t.maxParallelReconnects??fS,metricName:"libp2p_reconnect_queue",metrics:e.metrics}),this.started=!1,this.retries=t.retries??5,this.backoffFactor=t.backoffFactor,this.retryInterval=t.retryInterval,this.events=e.events,e.events.addEventListener("peer:disconnect",r=>{this.maybeReconnect(r.detail).catch(s=>{this.log.error("failed to maybe reconnect to %p - %e",r.detail,s)})})}async maybeReconnect(e){if(!this.started)return;const t=await this.peerStore.get(e);hl(t)&&(this.queue.has(e)||this.queue.add(async r=>{await FS(async s=>{if(this.started)try{await this.connectionManager.openConnection(e,{signal:r?.signal})}catch(i){throw this.log("reconnecting to %p attempt %d of %d failed - %e",e,s,this.retries,i),i}},{signal:r?.signal,retries:this.retries,factor:this.backoffFactor,minTimeout:this.retryInterval})},{peerId:e}).catch(async r=>{this.log.error("failed to reconnect to %p - %e",e,r);const s={};[...t.tags.keys()].forEach(i=>{i.startsWith(So)&&(s[i]=void 0)}),await this.peerStore.merge(e,{tags:s}),this.events.safeDispatchEvent("peer:reconnect-failure",{detail:e})}).catch(async r=>{this.log.error("failed to remove keep-alive tag from %p - %e",e,r)}))}start(){this.started=!0}async afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[t=>hl(t)]});await Promise.all(e.map(async t=>{await this.connectionManager.openConnection(t.id).catch(r=>{this.log.error(r)})}))}).catch(e=>{this.log.error(e)})}stop(){this.started=!1,this.queue.abort()}}function hl(n){for(const e of n.tags.keys())if(e.startsWith(So))return!0;return!1}const Eh=50,Ui={maxConnections:yS,inboundConnectionThreshold:dS,maxIncomingPendingConnections:hS};class BS{started;connections;allow;deny;maxIncomingPendingConnections;incomingPendingConnections;outboundPendingConnections;maxConnections;dialQueue;reconnectQueue;connectionPruner;inboundConnectionRateLimiter;peerStore;metrics;events;log;peerId;constructor(e,t={}){if(this.maxConnections=t.maxConnections??Ui.maxConnections,this.maxConnections<1)throw new z("Connection Manager maxConnections must be greater than 0");this.connections=new Mn,this.started=!1,this.peerId=e.peerId,this.peerStore=e.peerStore,this.metrics=e.metrics,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.allow=(t.allow??[]).map(r=>bo(r)),this.deny=(t.deny??[]).map(r=>bo(r)),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=t.maxIncomingPendingConnections??Ui.maxIncomingPendingConnections,this.outboundPendingConnections=0,this.inboundConnectionRateLimiter=new iS({points:t.inboundConnectionThreshold??Ui.inboundConnectionThreshold,duration:1}),this.connectionPruner=new lS({connectionManager:this,peerStore:e.peerStore,events:e.events,logger:e.logger},{allow:t.allow?.map(r=>K(r))}),this.dialQueue=new CS(e,{addressSorter:t.addressSorter,maxParallelDials:t.maxParallelDials??wh,maxDialQueueLength:t.maxDialQueueLength??yh,maxPeerAddrsToDial:t.maxPeerAddrsToDial??mh,dialTimeout:t.dialTimeout??gh,resolvers:t.resolvers??{dnsaddr:ua},connections:this.connections}),this.reconnectQueue=new US({events:e.events,peerStore:e.peerStore,logger:e.logger,connectionManager:this},{retries:t.reconnectRetries,retryInterval:t.reconnectRetryInterval,backoffFactor:t.reconnectBackoffFactor,maxParallelReconnects:t.maxParallelReconnects})}[Symbol.toStringTag]="@libp2p/connection-manager";async start(){this.metrics?.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const e={inbound:0,"inbound pending":this.incomingPendingConnections,outbound:0,"outbound pending":this.outboundPendingConnections};for(const t of this.connections.values())for(const r of t)e[r.direction]++;return e}}),this.metrics?.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const e={};for(const t of this.connections.values())for(const r of t)for(const s of r.streams){const i=`${s.direction} ${s.protocol??"unnegotiated"}`;e[i]=(e[i]??0)+1}return e}}),this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const e={};for(const r of this.connections.values())for(const s of r){const i={};for(const o of s.streams){const a=`${o.direction} ${o.protocol??"unnegotiated"}`;i[a]=(i[a]??0)+1}for(const[o,a]of Object.entries(i))e[o]=e[o]??[],e[o].push(a)}const t={};for(let[r,s]of Object.entries(e)){s=s.sort((o,a)=>o-a);const i=Math.floor(s.length*.9);t[r]=s[i]}return t}}),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),await Sl(this.dialQueue,this.reconnectQueue,this.connectionPruner),this.started=!0,this.log("started")}async stop(){this.events.removeEventListener("connection:open",this.onConnect),this.events.removeEventListener("connection:close",this.onDisconnect),await xl(this.reconnectQueue,this.dialQueue,this.connectionPruner);const e=[];for(const t of this.connections.values())for(const r of t)e.push((async()=>{try{await r.close()}catch(s){this.log.error(s)}})());this.log("closing %d connections",e.length),await Promise.all(e),this.connections.clear(),this.log("stopped")}getMaxConnections(){return this.maxConnections}setMaxConnections(e){if(this.maxConnections<1)throw new z("Connection Manager maxConnections must be greater than 0");let t=!1;e<this.maxConnections&&(t=!0),this.maxConnections=e,t&&this.connectionPruner.maybePruneConnections()}onConnect(e){this._onConnect(e).catch(t=>{this.log.error(t)})}async _onConnect(e){const{detail:t}=e;if(!this.started){await t.close();return}if(t.status!=="open")return;const r=t.remotePeer,s=!this.connections.has(r),i=this.connections.get(r)??[];i.push(t),this.connections.set(r,i),r.publicKey!=null&&r.type==="RSA"&&await this.peerStore.patch(r,{publicKey:r.publicKey}),s&&this.events.safeDispatchEvent("peer:connect",{detail:t.remotePeer})}onDisconnect(e){const{detail:t}=e,r=t.remotePeer,i=(this.connections.get(r)??[]).filter(o=>o.id!==t.id);this.connections.set(r,i),i.length===0&&(this.log("onDisconnect remove all connections for peer %p",r),this.connections.delete(r),this.events.safeDispatchEvent("peer:disconnect",{detail:t.remotePeer}))}getConnections(e){if(e!=null)return this.connections.get(e)??[];let t=[];for(const r of this.connections.values())t=t.concat(r);return t}getConnectionsMap(){return this.connections}async openConnection(e,t={}){if(!this.started)throw new ts("Not started");this.outboundPendingConnections++;try{t.signal?.throwIfAborted();const{peerId:r}=ph(e);if(this.peerId.equals(r))throw new bl("Can not dial self");if(r!=null&&t.force!==!0){this.log("dial %p",r);const a=this.getConnections(r).find(c=>c.limits==null);if(a!=null)return this.log("had an existing non-limited connection to %p",r),t.onProgress?.(new ee("dial-queue:already-connected")),a}const s=await this.dialQueue.dial(e,{...t,priority:t.priority??Eh});if(s.status!=="open")throw new yl("Remote closed connection during opening");let i=this.connections.get(s.remotePeer);i==null&&(i=[],this.connections.set(s.remotePeer,i));let o=!1;for(const a of i)if(a.id===s.id&&(o=!0),t.force!==!0&&a.id!==s.id&&a.remoteAddr.equals(s.remoteAddr))return s.abort(new Ao("Duplicate multiaddr connection")),a;return o||i.push(s),s}finally{this.outboundPendingConnections--}}async closeConnections(e,t={}){const r=this.connections.get(e)??[];await Promise.all(r.map(async s=>{try{await s.close(t)}catch(i){s.abort(i)}}))}async acceptIncomingConnection(e){if(this.deny.some(s=>s.contains(e.remoteAddr.nodeAddress().address)))return this.log("connection from %a refused - connection remote address was in deny list",e.remoteAddr),!1;if(this.allow.some(s=>s.contains(e.remoteAddr.nodeAddress().address)))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",e.remoteAddr),!1;if(e.remoteAddr.isThinWaistAddress()){const s=e.remoteAddr.nodeAddress().address;try{await this.inboundConnectionRateLimiter.consume(s,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",e.remoteAddr,s),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",e.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){const e={queued:"queued",running:"active",errored:"error",complete:"success"};return this.dialQueue.queue.queue.map(t=>({id:t.id,status:e[t.status],peerId:t.options.peerId,multiaddrs:[...t.options.multiaddrs].map(r=>K(r))}))}async isDialable(e,t={}){return this.dialQueue.isDialable(e,t)}}class Bi{movingAverage;variance;deviation;forecast;timeSpan;previousTime;constructor(e){this.timeSpan=e,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(e,t){return 1-Math.exp(-(e-t)/this.timeSpan)}push(e,t=Date.now()){if(this.previousTime!=null){const r=this.alpha(t,this.previousTime),s=e-this.movingAverage,i=r*s;this.movingAverage=r*e+(1-r)*this.movingAverage,this.variance=(1-r)*(this.variance+s*i),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+r*s}else this.movingAverage=e;this.previousTime=t}}const $S=1.2,zS=2,qS=5e3,KS=6e4,WS=5e3;class VS{success;failure;next;metric;timeoutMultiplier;failureMultiplier;minTimeout;maxTimeout;constructor(e={}){const t=e.interval??WS;this.success=new Bi(t),this.failure=new Bi(t),this.next=new Bi(t),this.failureMultiplier=e.failureMultiplier??zS,this.timeoutMultiplier=e.timeoutMultiplier??$S,this.minTimeout=e.minTimeout??qS,this.maxTimeout=e.maxTimeout??KS,e.metricName!=null&&(this.metric=e.metrics?.registerMetricGroup(e.metricName))}getTimeoutSignal(e={}){let t=Math.round(this.next.movingAverage*(e.timeoutFactor??this.timeoutMultiplier));t<this.minTimeout&&(t=this.minTimeout),t>this.maxTimeout&&(t=this.maxTimeout);const r=AbortSignal.timeout(t),s=Tt([e.signal,r]);return s.start=Date.now(),s.timeout=t,s}cleanUp(e){const t=Date.now()-e.start;e.aborted?(this.failure.push(t),this.next.push(t*this.failureMultiplier),this.metric?.update({failureMovingAverage:this.failure.movingAverage,failureDeviation:this.failure.deviation,failureForecast:this.failure.forecast,failureVariance:this.failure.variance,failure:t})):(this.success.push(t),this.next.push(t),this.metric?.update({successMovingAverage:this.success.movingAverage,successDeviation:this.success.deviation,successForecast:this.success.forecast,successVariance:this.success.variance,success:t}))}}class HS{readNext;haveNext;ended;nextResult;error;constructor(){this.ended=!1,this.readNext=V(),this.haveNext=V()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=V(),e}async throw(e){return this.ended=!0,this.error=e,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=V(),await oe(this.readNext.promise,t?.signal,t)}}function GS(){return new HS}class QS extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"}function YS(n,e){const t=GS();n.sink(t).catch(async o=>{await t.end(o)}),n.sink=async o=>{for await(const a of o)await t.push(a);await t.end()};let r=n.source;n.source[Symbol.iterator]!=null?r=n.source[Symbol.iterator]():n.source[Symbol.asyncIterator]!=null&&(r=n.source[Symbol.asyncIterator]());const s=new H;return{read:async o=>{if(o?.signal?.throwIfAborted(),o?.bytes==null){const{done:c,value:u}=await oe(r.next(),o?.signal);return c===!0?null:u}for(;s.byteLength<o.bytes;){const{value:c,done:u}=await oe(r.next(),o?.signal);if(u===!0)throw new QS("unexpected end of input");s.append(c)}const a=s.sublist(0,o.bytes);return s.consume(o.bytes),a},write:async(o,a)=>{a?.signal?.throwIfAborted(),o instanceof Uint8Array?await t.push(o,a):await t.push(o.subarray(),a)},unwrap:()=>{if(s.byteLength>0){const o=n.source;n.source=async function*(){yield*s,yield*o}()}return n}}}const XS=1e4,ZS="1.0.0",jS="ping",JS="ipfs",fl=32,ex=!0;class tx{protocol;components;log;heartbeatInterval;pingIntervalMs;abortController;timeout;abortConnectionOnPingFailure;constructor(e,t={}){this.components=e,this.protocol=`/${t.protocolPrefix??JS}/${jS}/${ZS}`,this.log=e.logger.forComponent("libp2p:connection-monitor"),this.pingIntervalMs=t.pingInterval??XS,this.abortConnectionOnPingFailure=t.abortConnectionOnPingFailure??ex,this.timeout=new VS({...t.pingTimeout??{},metrics:e.metrics,metricName:"libp2p_connection_monitor_ping_time_milliseconds"})}[Symbol.toStringTag]="@libp2p/connection-monitor";[Qe]=["@libp2p/connection-monitor"];start(){this.abortController=new AbortController,this.abortController.signal,this.heartbeatInterval=setInterval(()=>{this.components.connectionManager.getConnections().forEach(e=>{Promise.resolve().then(async()=>{let t=Date.now();try{const r=this.timeout.getTimeoutSignal({signal:this.abortController?.signal}),s=await e.newStream(this.protocol,{signal:r,runOnLimitedConnection:!0}),i=YS(s);t=Date.now(),await Promise.all([i.write(Vo(fl),{signal:r}),i.read({bytes:fl,signal:r})]),e.rtt=Date.now()-t,await i.unwrap().close({signal:r})}catch(r){if(r.name!=="UnsupportedProtocolError")throw r;e.rtt=(Date.now()-t)/2}}).catch(t=>{this.log.error("error during heartbeat",t),this.abortConnectionOnPingFailure?(this.log.error("aborting connection due to ping failure"),e.abort(t)):this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag")})})},this.pingIntervalMs)}stop(){this.abortController?.abort(),this.heartbeatInterval!=null&&clearInterval(this.heartbeatInterval)}}class nx{routers;started;components;constructor(e,t){this.routers=t.routers??[],this.started=!1,this.components=e,this.findProviders=e.metrics?.traceFunction("libp2p.contentRouting.findProviders",this.findProviders.bind(this),{optionsIndex:1,getAttributesFromArgs:([r],s)=>({...s,cid:r.toString()}),getAttributesFromYieldedValue:(r,s)=>({...s,providers:[...Array.isArray(s.providers)?s.providers:[],r.id.toString()]})})??this.findProviders,this.provide=e.metrics?.traceFunction("libp2p.contentRouting.provide",this.provide.bind(this),{optionsIndex:1,getAttributesFromArgs:([r],s)=>({...s,cid:r.toString()})})??this.provide,this.cancelReprovide=e.metrics?.traceFunction("libp2p.contentRouting.cancelReprovide",this.cancelReprovide.bind(this),{optionsIndex:1,getAttributesFromArgs:([r],s)=>({...s,cid:r.toString()})})??this.cancelReprovide,this.put=e.metrics?.traceFunction("libp2p.contentRouting.put",this.put.bind(this),{optionsIndex:2,getAttributesFromArgs:([r])=>({key:q(r,"base36")})})??this.put,this.get=e.metrics?.traceFunction("libp2p.contentRouting.get",this.get.bind(this),{optionsIndex:1,getAttributesFromArgs:([r])=>({key:q(r,"base36")})})??this.get}[Symbol.toStringTag]="@libp2p/content-routing";isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(e,t={}){if(this.routers.length===0)throw new Mi("No content routers available");const r=this,s=new dn;for await(const i of ms(...r.routers.filter(o=>o.findProviders instanceof Function).map(o=>o.findProviders(e,t))))i!=null&&(i.multiaddrs.length>0&&await this.components.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},t),!s.has(i.id)&&(s.add(i.id),yield i))}async provide(e,t={}){if(this.routers.length===0)throw new Mi("No content routers available");await Promise.all(this.routers.filter(r=>r.provide instanceof Function).map(async r=>{await r.provide(e,t)}))}async cancelReprovide(e,t={}){if(this.routers.length===0)throw new Mi("No content routers available");await Promise.all(this.routers.filter(r=>r.cancelReprovide instanceof Function).map(async r=>{await r.cancelReprovide(e,t)}))}async put(e,t,r){if(!this.isStarted())throw new ts;await Promise.all(this.routers.filter(s=>s.put instanceof Function).map(async s=>{await s.put(e,t,r)}))}async get(e,t){if(!this.isStarted())throw new ts;return Promise.any(this.routers.filter(r=>r.get instanceof Function).map(async r=>r.get(e,t)))}}class rx{log;peerId;peerStore;routers;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-routing"),this.peerId=e.peerId,this.peerStore=e.peerStore,this.routers=t.routers??[],this.findPeer=e.metrics?.traceFunction("libp2p.peerRouting.findPeer",this.findPeer.bind(this),{optionsIndex:1,getAttributesFromArgs:([r],s)=>({...s,peer:r.toString()})})??this.findPeer,this.getClosestPeers=e.metrics?.traceFunction("libp2p.peerRouting.getClosestPeers",this.getClosestPeers.bind(this),{optionsIndex:1,getAttributesFromArgs:([r],s)=>({...s,key:q(r,"base36")}),getAttributesFromYieldedValue:(r,s)=>({...s,peers:[...Array.isArray(s.peers)?s.peers:[],r.id.toString()]})})??this.getClosestPeers}[Symbol.toStringTag]="@libp2p/peer-routing";async findPeer(e,t){if(this.routers.length===0)throw new rl("No peer routers available");if(e.toString()===this.peerId.toString())throw new N1("Should not try to find self");const r=this,s=ms(...this.routers.filter(i=>i.findPeer instanceof Function).map(i=>async function*(){try{yield await i.findPeer(e,t)}catch(o){r.log.error(o)}}()));for await(const i of s)if(i!=null)return i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},t),i;throw new Wi}async*getClosestPeers(e,t={}){if(this.routers.length===0)throw new rl("No peer routers available");const r=this,s=pr(1024);for await(const i of Ad(async function*(){const o=ms(...r.routers.filter(a=>a.getClosestPeers instanceof Function).map(a=>a.getClosestPeers(e,t)));for await(let a of o)yield async()=>{if(a.multiaddrs.length===0)try{a=await r.findPeer(a.id,{...t,useCache:!1})}catch(c){r.log.error("could not find peer multiaddrs",c);return}return a}}()))i!=null&&(i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},t),!s.has(i.id.toMultihash().bytes)&&(s.add(i.id.toMultihash().bytes),yield i))}}class sx extends tt{peerRouting;log;walking;walkers;shutdownController;walkController;needNext;constructor(e){super(),this.log=e.logger.forComponent("libp2p:random-walk"),this.peerRouting=e.peerRouting,this.walkers=0,this.walking=!1,this.shutdownController=new AbortController,this.shutdownController.signal}[Symbol.toStringTag]="@libp2p/random-walk";start(){this.shutdownController=new AbortController,this.shutdownController.signal}stop(){this.shutdownController.abort()}async*walk(e){this.walking||this.startWalk(),this.walkers++;const t=Tt([this.shutdownController.signal,e?.signal]);try{for(;;)this.needNext?.resolve(),this.needNext=V(),yield(await ft(this,"walk:peer",t,{errorEvent:"walk:error"})).detail}finally{t.clear(),this.walkers--,this.walkers===0&&(this.walkController?.abort(),this.walkController=void 0)}}startWalk(){this.walking=!0,this.walkController=new AbortController,this.walkController.signal;const e=Tt([this.walkController.signal,this.shutdownController.signal]),t=Date.now();let r=0;Promise.resolve().then(async()=>{for(this.log("start walk");this.walkers>0;)try{const s=Vo(32);let i=Date.now();for await(const o of this.peerRouting.getClosestPeers(s,{signal:e}))e.aborted&&this.log("aborting walk"),e.throwIfAborted(),this.log("found peer %p after %dms for %d walkers",o.id,Date.now()-i,this.walkers),r++,this.safeDispatchEvent("walk:peer",{detail:o}),this.walkers===1&&this.needNext!=null&&(this.log("wait for need next"),await oe(this.needNext.promise,e)),i=Date.now();this.log("walk iteration for %b and %d walkers finished, found %d peers",s,this.walkers,r)}catch(s){this.log.error("random walk errored",s),this.safeDispatchEvent("walk:error",{detail:s})}this.log("no walkers left, ended walk")}).catch(s=>{this.log.error("random walk errored",s)}).finally(()=>{this.log("finished walk, found %d peers after %dms",r,Date.now()-t),this.walking=!1})}}const vh=32,Sh=64;class ix{log;topologies;handlers;components;constructor(e){this.components=e,this.log=e.logger.forComponent("libp2p:registrar"),this.topologies=new Map,e.metrics?.registerMetricGroup("libp2p_registrar_topologies",{calculate:()=>{const t={};for(const[r,s]of this.topologies)t[r]=s.size;return t}}),this.handlers=yt({name:"libp2p_registrar_protocol_handlers",metrics:e.metrics}),this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}[Symbol.toStringTag]="@libp2p/registrar";getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(e){const t=this.handlers.get(e);if(t==null)throw new O1(`No handler registered for protocol ${e}`);return t}getTopologies(e){const t=this.topologies.get(e);return t==null?[]:[...t.values()]}async handle(e,t,r){if(this.handlers.has(e)&&r?.force!==!0)throw new F1(`Handler already registered for protocol ${e}`);const s=Wd.bind({ignoreUndefined:!0})({maxInboundStreams:vh,maxOutboundStreams:Sh},r);this.handlers.set(e,{handler:t,options:s}),await this.components.peerStore.merge(this.components.peerId,{protocols:[e]},r)}async unhandle(e,t){(Array.isArray(e)?e:[e]).forEach(s=>{this.handlers.delete(s)}),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()},t)}async register(e,t){if(t==null)throw new z("invalid topology");const r=`${(Math.random()*1e9).toString(36)}${Date.now()}`;let s=this.topologies.get(e);return s==null&&(s=new Map,this.topologies.set(e,s)),s.set(r,t),r}unregister(e){for(const[t,r]of this.topologies.entries())r.has(e)&&(r.delete(e),r.size===0&&this.topologies.delete(t))}_onDisconnect(e){const t=e.detail,r={signal:AbortSignal.timeout(5e3)};this.components.peerStore.get(t,r).then(s=>{for(const i of s.protocols){const o=this.topologies.get(i);if(o!=null)for(const a of o.values())a.filter?.has(t)!==!1&&(a.filter?.remove(t),a.onDisconnect?.(t))}}).catch(s=>{s.name!=="NotFoundError"&&this.log.error("could not inform topologies of disconnecting peer %p",t,s)})}_onPeerUpdate(e){const{peer:t,previous:r}=e.detail,s=(r?.protocols??[]).filter(i=>!t.protocols.includes(i));for(const i of s){const o=this.topologies.get(i);if(o!=null)for(const a of o.values())a.filter?.has(t.id)!==!1&&(a.filter?.remove(t.id),a.onDisconnect?.(t.id))}}_onPeerIdentify(e){const t=e.detail.protocols,r=e.detail.connection,s=e.detail.peerId;for(const i of t){const o=this.topologies.get(i);if(o!=null)for(const a of o.values())r.limits!=null&&a.notifyOnLimitedConnection!==!0||a.filter?.has(s)!==!0&&(a.filter?.add(s),a.onConnect?.(s,r))}}}class ox{log;components;transports;listeners;faultTolerance;started;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:transports"),this.components=e,this.started=!1,this.transports=yt({name:"libp2p_transport_manager_transports",metrics:this.components.metrics}),this.listeners=yt({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=t.faultTolerance??rr.FATAL_ALL}[Symbol.toStringTag]="@libp2p/transport-manager";add(e){const t=e[Symbol.toStringTag];if(t==null)throw new z("Transport must have a valid tag");if(this.transports.has(t))throw new z(`There is already a transport with the tag ${t}`);this.log("adding transport %s",t),this.transports.set(t,e),this.listeners.has(t)||this.listeners.set(t,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const e=this.components.addressManager.getListenAddrs();await this.listen(e)}async stop(){const e=[];for(const[t,r]of this.listeners)for(this.log("closing listeners for %s",t);r.length>0;){const s=r.pop();s!=null&&e.push(s.close())}await Promise.all(e),this.log("all listeners closed");for(const t of this.listeners.keys())this.listeners.set(t,[]);this.started=!1}async dial(e,t){const r=this.dialTransportForMultiaddr(e);if(r==null)throw new K1(`No transport available for address ${String(e)}`);return t?.onProgress?.(new ee("transport-manager:selected-transport",r[Symbol.toStringTag])),r.dial(e,{...t,upgrader:this.components.upgrader})}getAddrs(){let e=[];for(const t of this.listeners.values())for(const r of t)e=[...e,...r.getAddrs()];return e}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}dialTransportForMultiaddr(e){for(const t of this.transports.values())if(t.dialFilter([e]).length>0)return t}listenTransportForMultiaddr(e){for(const t of this.transports.values())if(t.listenFilter([e]).length>0)return t}async listen(e){if(!this.isStarted())throw new ts("Not started");if(e==null||e.length===0){this.log("no addresses were provided for listening, this node is dial only");return}const t={errors:new Map,ipv4:{success:0,attempts:0},ipv6:{success:0,attempts:0}};e.forEach(i=>{t.errors.set(i.toString(),new U1)});const r=[];for(const[i,o]of this.transports.entries()){const a=o.listenFilter(e);for(const c of a){this.log("creating listener for %s on %a",i,c);const u=o.createListener({upgrader:this.components.upgrader});let l=this.listeners.get(i)??[];l==null&&(l=[],this.listeners.set(i,l)),l.push(u),u.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:u})}),u.addEventListener("close",()=>{const d=l.findIndex(h=>h===u);l.splice(d,1),this.components.events.safeDispatchEvent("transport:close",{detail:u})}),uc.matches(c)?t.ipv4.attempts++:dc.matches(c)&&t.ipv6.attempts++,r.push(u.listen(c).then(()=>{t.errors.delete(c.toString()),uc.matches(c)&&t.ipv4.success++,dc.matches(c)&&t.ipv6.success++},d=>{throw this.log.error("transport %s could not listen on address %a - %e",i,c,d),t.errors.set(c.toString(),d),d}))}}const s=await Promise.allSettled(r);if(!(s.length>0&&s.every(i=>i.status==="fulfilled"))){if(this.ipv6Unsupported(t)){this.log("all IPv4 addresses succeed but all IPv6 failed");return}if(this.faultTolerance===rr.NO_FATAL){this.log("failed to listen on any address but fault tolerance allows this");return}throw new B1(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...t.errors.entries()].map(([i,o])=>`
  ${i}: ${`${o.stack??o}`.split(`
`).join(`
  `)}
`).join("")}`)}}ipv6Unsupported(e){if(e.ipv4.attempts===0||e.ipv6.attempts===0)return!1;const t=e.ipv4.attempts===e.ipv4.success,r=e.ipv6.success===0;return t&&r}async remove(e){const t=this.listeners.get(e)??[];this.log.trace("removing transport %s",e);const r=[];for(this.log.trace("closing listeners for %s",e);t.length>0;){const s=t.pop();s!=null&&r.push(s.close())}await Promise.all(r),this.transports.delete(e),this.listeners.delete(e)}async removeAll(){const e=[];for(const t of this.transports.keys())e.push(this.remove(t));await Promise.all(e)}}const Oe="/multistream/1.0.0",da=1024,ax=$(`
`);async function Gn(n,e,t){await n.write(e,t)}async function cx(n,e,t){await n.writeV(e,t)}async function lx(n,e){const t=await n.read(e);if(t.byteLength===0||t.get(t.byteLength-1)!==ax[0])throw e.log.error("Invalid mss message - missing newline",t),new je("Missing newline");return t.sublist(0,-1)}async function hn(n,e){const t=await lx(n,e);return q(t.subarray())}async function $i(n,e,t){if(e=Array.isArray(e)?[...e]:[e],e.length===1&&t.negotiateFully===!1)return ux(n,e[0],t);const r=mn(n,{...t,maxDataLength:da}),s=e.shift();if(s==null)throw new Error("At least one protocol must be specified");t.log.trace('select: write ["%s", "%s"]',Oe,s);const i=$(`${Oe}
`),o=$(`${s}
`);await cx(r,[i,o],t),t.log.trace("select: reading multistream-select header");let a=await hn(r,t);if(t.log.trace('select: read "%s"',a),a===Oe&&(t.log.trace("select: reading protocol response"),a=await hn(r,t),t.log.trace('select: read "%s"',a)),a===s)return{stream:r.unwrap(),protocol:s};for(const c of e){t.log.trace('select: write "%s"',c),await Gn(r,$(`${c}
`),t),t.log.trace("select: reading protocol response");const u=await hn(r,t);if(t.log.trace('select: read "%s" for "%s"',u,c),u===c)return{stream:r.unwrap(),protocol:c}}throw new _o("protocol selection failed")}function ux(n,e,t){const r=n.sink.bind(n),s=n.source;let i=!1,o=!1;const a=V();let c=!1,u=!1;const l=V();let d=!1,h=!1;const p=V(),g=mn({sink:r,source:s},{...t,maxDataLength:da});n.sink=async v=>{const{sink:x}=g.unwrap();await x(async function*(){let L=!1;for await(const E of v){if(u&&await l.promise,c)yield E;else{u=!0,t.log.trace('optimistic: write ["%s", "%s", data(%d)] in sink',Oe,e,E.byteLength);const T=`${e}
`;yield new H(Uint8Array.from([19]),$(`${Oe}
`),an(T.length),$(T),E).subarray(),t.log.trace('optimistic: wrote ["%s", "%s", data(%d)] in sink',Oe,e,E.byteLength),c=!0,u=!1,l.resolve(),m().catch(k=>{t.log.error("could not finish optimistic protocol negotiation of %s",e,k)})}L=!0}L||await m()}())};async function m(){if(o){t.log.trace("optimistic: already negotiating %s stream",e),await a.promise;return}o=!0;try{c||(t.log.trace("optimistic: doing send protocol for %s stream",e),await f()),d||(t.log.trace("optimistic: doing read protocol for %s stream",e),await w())}finally{o=!1,i=!0,a.resolve()}}async function f(){if(u){await l.promise;return}u=!0;try{t.log.trace('optimistic: write ["%s", "%s", data] in source',Oe,e),await g.writeV([$(`${Oe}
`),$(`${e}
`)]),t.log.trace('optimistic: wrote ["%s", "%s", data] in source',Oe,e)}finally{c=!0,u=!1,l.resolve()}}async function w(){if(h){await p.promise;return}h=!0;try{t.log.trace("optimistic: reading multistream select header");let v=await hn(g,t);if(t.log.trace('optimistic: read multistream select header "%s"',v),v===Oe&&(v=await hn(g,t)),t.log.trace('optimistic: read protocol "%s", expecting "%s"',v,e),v!==e)throw new _o("protocol selection failed")}finally{d=!0,h=!1,p.resolve()}}if(n.source=async function*(){await m(),t.log.trace('optimistic: reading data from "%s" stream',e),yield*g.unwrap().source}(),n.closeRead!=null){const v=n.closeRead.bind(n);n.closeRead=async x=>{i||await m().catch(L=>{t.log.error("could not negotiate protocol before close read",L)}),await v(x)}}if(n.closeWrite!=null){const v=n.closeWrite.bind(n);n.closeWrite=async x=>{i||await m().catch(L=>{t.log.error("could not negotiate protocol before close write",L)}),await v(x)}}if(n.close!=null){const v=n.close.bind(n);n.close=async x=>{const L=[];u&&L.push(l.promise),h&&L.push(p.promise),L.length>0?await oe(Promise.all(L),x?.signal):(i=!0,o=!1,a.resolve()),await v(x)}}return{stream:n,protocol:e}}async function zi(n,e,t){e=Array.isArray(e)?e:[e],t.log.trace("handle: available protocols %s",e);const r=mn(n,{...t,maxDataLength:da,maxLengthLength:2});for(;;){t.log.trace("handle: reading incoming string");const s=await hn(r,t);if(t.log.trace('handle: read "%s"',s),s===Oe){t.log.trace('handle: respond with "%s" for "%s"',Oe,s),await Gn(r,$(`${Oe}
`),t),t.log.trace('handle: responded with "%s" for "%s"',Oe,s);continue}if(e.includes(s))return t.log.trace('handle: respond with "%s" for "%s"',s,s),await Gn(r,$(`${s}
`),t),t.log.trace('handle: responded with "%s" for "%s"',s,s),{stream:r.unwrap(),protocol:s};if(s==="ls"){const i=new H(...e.map(o=>ps.single($(`${o}
`))),$(`
`));t.log.trace('handle: respond with "%s" for %s',e,s),await Gn(r,i,t),t.log.trace('handle: responded with "%s" for %s',e,s);continue}t.log.trace('handle: respond with "na" for "%s"',s),await Gn(r,$(`na
`),t),t.log('handle: responded with "na" for "%s"',s)}}const dx=500;class hx{id;remoteAddr;remotePeer;direction;timeline;multiplexer;encryption;status;limits;log;tags;_newStream;_close;_abort;_getStreams;constructor(e){const{remoteAddr:t,remotePeer:r,newStream:s,close:i,abort:o,getStreams:a}=e;this.id=`${parseInt(String(Math.random()*1e9)).toString(36)}${Date.now()}`,this.remoteAddr=t,this.remotePeer=r,this.direction=e.direction,this.status="open",this.timeline=e.timeline,this.multiplexer=e.multiplexer,this.encryption=e.encryption,this.limits=e.limits,this.log=e.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`),this.remoteAddr.getPeerId()==null&&(this.remoteAddr=this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)),this._newStream=s,this._close=i,this._abort=o,this._getStreams=a,this.tags=[]}[Symbol.toStringTag]="Connection";[Ch]=!0;get streams(){return this._getStreams()}async newStream(e,t){if(this.status==="closing")throw new Ph("the connection is being closed");if(this.status==="closed")throw new yl("the connection is closed");if(Array.isArray(e)||(e=[e]),this.limits!=null&&t?.runOnLimitedConnection!==!0)throw new El("Cannot open protocol stream on limited connection");const r=await this._newStream(e,t);return r.direction="outbound",r}async close(e={}){if(!(this.status==="closed"||this.status==="closing")){if(this.log("closing connection to %a",this.remoteAddr),this.status="closing",e.signal==null){const t=AbortSignal.timeout(dx);e={...e,signal:t}}try{this.log.trace("closing underlying transport"),await this._close(e),this.log.trace("updating timeline with close time"),this.status="closed",this.timeline.close=Date.now()}catch(t){this.log.error("error encountered during graceful close of connection to %a",this.remoteAddr,t),this.abort(t)}}}abort(e){this.status!=="closed"&&(this.log.error("aborting connection to %a due to error",this.remoteAddr,e),this.status="closing",this._abort(e),this.status="closed",this.timeline.close=Date.now())}}function fx(n){return new hx(n)}function px(n,e){try{const{options:t}=e.getHandler(n);return t.maxInboundStreams}catch(t){if(t.name!=="UnhandledProtocolError")throw t}return vh}function gx(n,e,t={}){try{const{options:r}=e.getHandler(n);if(r.maxOutboundStreams!=null)return r.maxOutboundStreams}catch(r){if(r.name!=="UnhandledProtocolError")throw r}return t.maxOutboundStreams??Sh}function pl(n,e,t){let r=0;return t.streams.forEach(s=>{s.direction===e&&s.protocol===n&&r++}),r}class mx{components;connectionEncrypters;streamMuxers;inboundUpgradeTimeout;inboundStreamProtocolNegotiationTimeout;outboundStreamProtocolNegotiationTimeout;events;metrics;constructor(e,t){this.components=e,this.connectionEncrypters=yt({name:"libp2p_upgrader_connection_encrypters",metrics:this.components.metrics}),t.connectionEncrypters.forEach(r=>{this.connectionEncrypters.set(r.protocol,r)}),this.streamMuxers=yt({name:"libp2p_upgrader_stream_multiplexers",metrics:this.components.metrics}),t.streamMuxers.forEach(r=>{this.streamMuxers.set(r.protocol,r)}),this.inboundUpgradeTimeout=t.inboundUpgradeTimeout??uS,this.inboundStreamProtocolNegotiationTimeout=t.inboundStreamProtocolNegotiationTimeout??ol,this.outboundStreamProtocolNegotiationTimeout=t.outboundStreamProtocolNegotiationTimeout??ol,this.events=e.events,this.metrics={dials:e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_total"),errors:e.metrics?.registerCounterGroup("libp2p_connection_manager_dial_errors_total"),inboundErrors:e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_inbound_errors_total"),outboundErrors:e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_outbound_errors_total")}}[Symbol.toStringTag]="@libp2p/upgrader";async shouldBlockConnection(e,...t){const r=this.components.connectionGater[e];if(r==null)return;if(await r.apply(this.components.connectionGater,t)===!0)throw new z1(`The multiaddr connection is blocked by gater.${e}`)}createInboundAbortSignal(e){return Tt([AbortSignal.timeout(this.inboundUpgradeTimeout),e])}async upgradeInbound(e,t){let r=!1;const s=this.createInboundAbortSignal(t.signal);try{if(this.metrics.dials?.increment({inbound:!0}),r=await oe(this.components.connectionManager.acceptIncomingConnection(e),s),!r)throw new q1("Connection denied");await oe(this.shouldBlockConnection("denyInboundConnection",e),s),await this._performUpgrade(e,"inbound",{...t,signal:s})}catch(i){throw this.metrics.errors?.increment({inbound:!0}),this.metrics.inboundErrors?.increment({[i.name??"Error"]:!0}),i}finally{s.clear(),r&&this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(e,t){try{this.metrics.dials?.increment({outbound:!0});const r=e.remoteAddr.getPeerId();let s;r!=null&&(s=gt(r),await oe(this.shouldBlockConnection("denyOutboundConnection",s,e),t.signal));let i="outbound";return t.initiator===!1&&(i="inbound"),await this._performUpgrade(e,i,t)}catch(r){throw this.metrics.errors?.increment({outbound:!0}),this.metrics.outboundErrors?.increment({[r.name??"Error"]:!0}),r}}async _performUpgrade(e,t,r){let s,i,o,a,c;this.components.metrics?.trackMultiaddrConnection(e),e.log.trace("starting the %s connection upgrade",t);let u=e;if(r?.skipProtection!==!0){const l=this.components.connectionProtector;l!=null&&(e.log("protecting the %s connection",t),u=await l.protect(e,r))}try{if(s=u,r?.skipEncryption!==!0){r?.onProgress?.(new ee(`upgrader:encrypt-${t}-connection`)),{conn:s,remotePeer:i,protocol:c,streamMuxer:a}=await(t==="inbound"?this._encryptInbound(u,r):this._encryptOutbound(u,r));const l={...u,...s};await this.shouldBlockConnection(t==="inbound"?"denyInboundEncryptedConnection":"denyOutboundEncryptedConnection",i,l)}else{const l=e.remoteAddr.getPeerId();if(l==null)throw new Ao(`${t} connection that skipped encryption must have a peer id`);const d=gt(l);c="native",i=d}if(i.equals(this.components.peerId)){const l=new bl("Can not dial self");throw e.abort(l),l}if(o=s,r?.muxerFactory!=null)a=r.muxerFactory;else if(a==null&&this.streamMuxers.size>0){r?.onProgress?.(new ee(`upgrader:multiplex-${t}-connection`));const l=await(t==="inbound"?this._multiplexInbound({...u,...s},this.streamMuxers,r):this._multiplexOutbound({...u,...s},this.streamMuxers,r));a=l.muxerFactory,o=l.stream}}catch(l){throw e.log.error("failed to upgrade inbound connection %s %a - %e",t==="inbound"?"from":"to",e.remoteAddr,l),l}return await this.shouldBlockConnection(t==="inbound"?"denyInboundUpgradedConnection":"denyOutboundUpgradedConnection",i,e),e.log("successfully upgraded %s connection",t),this._createConnection({cryptoProtocol:c,direction:t,maConn:e,upgradedConn:o,muxerFactory:a,remotePeer:i,limits:r?.limits})}_createConnection(e){const{cryptoProtocol:t,direction:r,maConn:s,upgradedConn:i,remotePeer:o,muxerFactory:a,limits:c}=e;let u,l,d;a!=null&&(u=a.createStreamMuxer({direction:r,onIncomingStream:g=>{if(d==null)return;const m=AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout);Promise.resolve().then(async()=>{const f=this.components.registrar.getProtocols(),{stream:w,protocol:v}=await zi(g,f,{signal:m,log:g.log,yieldBytes:!1});if(d==null)return;d.log("incoming stream opened on %s",v);const x=px(v,this.components.registrar);if(pl(v,"inbound",d)===x){const E=new Mh(`Too many inbound protocol streams for protocol "${v}" - limit ${x}`);throw g.abort(E),E}g.source=w.source,g.sink=w.sink,g.protocol=v,w.closeWrite!=null&&(g.closeWrite=w.closeWrite),w.closeRead!=null&&(g.closeRead=w.closeRead),w.close!=null&&(g.close=w.close),await this.components.peerStore.merge(o,{protocols:[v]},{signal:m}),this.components.metrics?.trackProtocolStream(g,d),this._onStream({connection:d,stream:g,protocol:v})}).catch(async f=>{d.log.error("error handling incoming stream id %s - %e",g.id,f),g.timeline.close==null&&await g.close({signal:m}).catch(w=>g.abort(w))})}}),l=async(g,m={})=>{if(u==null)throw new Yr("Connection is not multiplexed");d.log.trace("starting new stream for protocols %s",g);const f=await u.newStream();d.log.trace("started new stream %s for protocols %s",f.id,g);try{if(m.signal==null){f.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout",g);const E=AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);m={...m,signal:E}}f.log.trace("selecting protocol from protocols %s",g);const{stream:w,protocol:v}=await $i(f,g,{...m,log:f.log,yieldBytes:!0});f.log.trace("selected protocol %s",v);const x=gx(v,this.components.registrar,m),L=pl(v,"outbound",d);if(L>=x){const E=new vl(`Too many outbound protocol streams for protocol "${v}" - ${L}/${x}`);throw f.abort(E),E}return await this.components.peerStore.merge(o,{protocols:[v]}),f.source=w.source,f.sink=w.sink,f.protocol=v,w.closeWrite!=null&&(f.closeWrite=w.closeWrite),w.closeRead!=null&&(f.closeRead=w.closeRead),w.close!=null&&(f.close=w.close),this.components.metrics?.trackProtocolStream(f,d),f}catch(w){throw d.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e",r==="inbound"?"from":"to",e.maConn.remoteAddr,g,w),f.timeline.close==null&&f.abort(w),w}},Promise.all([u.sink(i.source),i.sink(u.source)]).catch(g=>{d.log.error("error piping data through muxer - %e",g)}));const h=s.timeline;s.timeline=new Proxy(h,{set:(...g)=>(g[1]==="close"&&g[2]!=null&&h.close==null&&(async()=>{try{d.status==="open"&&await d.close()}catch(m){d.log.error("error closing connection after timeline close %e",m)}finally{this.events.safeDispatchEvent("connection:close",{detail:d})}})().catch(m=>{d.log.error("error thrown while dispatching connection:close event %e",m)}),Reflect.set(...g))}),s.timeline.upgraded=Date.now();const p=()=>{throw new Yr("Connection is not multiplexed")};return d=fx({remoteAddr:s.remoteAddr,remotePeer:o,status:"open",direction:r,timeline:s.timeline,multiplexer:u?.protocol,encryption:t,limits:c,logger:this.components.logger,newStream:l??p,getStreams:()=>u?.streams??[],close:async g=>{await u?.close(g),await s.close(g)},abort:g=>{s.abort(g),u?.abort(g)}}),this.events.safeDispatchEvent("connection:open",{detail:d}),d.__maConnTimeline=h,d}_onStream(e){const{connection:t,stream:r,protocol:s}=e,{handler:i,options:o}=this.components.registrar.getHandler(s);if(t.limits!=null&&o.runOnLimitedConnection!==!0)throw new El("Cannot open protocol stream on limited connection");i({connection:t,stream:r})}async _encryptInbound(e,t){const r=Array.from(this.connectionEncrypters.keys());try{const{stream:s,protocol:i}=await zi(e,r,{...t,log:e.log}),o=this.connectionEncrypters.get(i);if(o==null)throw new Xr(`no crypto module found for ${i}`);return e.log("encrypting inbound connection to %a using %s",e.remoteAddr,i),{...await o.secureInbound(s,t),protocol:i}}catch(s){throw e.log.error("encrypting inbound connection from %a failed",e.remoteAddr,s),new Xr(s.message)}}async _encryptOutbound(e,t){const r=Array.from(this.connectionEncrypters.keys());try{e.log.trace("selecting encrypter from %s",r);const{stream:s,protocol:i}=await $i(e,r,{...t,log:e.log,yieldBytes:!0}),o=this.connectionEncrypters.get(i);if(o==null)throw new Xr(`no crypto module found for ${i}`);return e.log("encrypting outbound connection to %a using %s",e.remoteAddr,i),{...await o.secureOutbound(s,t),protocol:i}}catch(s){throw e.log.error("encrypting outbound connection to %a failed",e.remoteAddr,s),new Xr(s.message)}}async _multiplexOutbound(e,t,r){const s=Array.from(t.keys());e.log("outbound selecting muxer %s",s);try{e.log.trace("selecting stream muxer from %s",s);const{stream:i,protocol:o}=await $i(e,s,{...r,log:e.log,yieldBytes:!0});e.log("selected %s as muxer protocol",o);const a=t.get(o);return{stream:i,muxerFactory:a}}catch(i){throw e.log.error("error multiplexing outbound connection",i),new Yr(String(i))}}async _multiplexInbound(e,t,r){const s=Array.from(t.keys());e.log("inbound handling muxers %s",s);try{const{stream:i,protocol:o}=await zi(e,s,{...r,log:e.log}),a=t.get(o);return{stream:i,muxerFactory:a}}catch(i){throw e.log.error("error multiplexing inbound connection",i),new Yr(String(i))}}getConnectionEncrypters(){return this.connectionEncrypters}getStreamMuxers(){return this.streamMuxers}}const xh="2.9.0",Ah="js-libp2p";function yx(n,e){return`${n??Ah}/${e??xh} browser/${globalThis.navigator.userAgent}`}class wx extends tt{peerId;peerStore;contentRouting;peerRouting;metrics;services;logger;status;components;log;constructor(e){super(),this.status="stopped";const t=new tt,r=t.dispatchEvent.bind(t);t.dispatchEvent=u=>{const l=r(u),d=this.dispatchEvent(new CustomEvent(u.type,{detail:u.detail}));return l||d},this.peerId=e.peerId,this.logger=e.logger??Yd(),this.log=this.logger.forComponent("libp2p"),this.services={};const s=e.nodeInfo?.name??Ah,i=e.nodeInfo?.version??xh,o=this.components=Q1({peerId:e.peerId,privateKey:e.privateKey,nodeInfo:{name:s,version:i,userAgent:e.nodeInfo?.userAgent??yx(s,i)},logger:this.logger,events:t,datastore:e.datastore??new g1,connectionGater:tS(e.connectionGater),dns:e.dns});e.metrics!=null&&(this.metrics=this.configureComponent("metrics",e.metrics(this.components))),this.peerStore=this.configureComponent("peerStore",u1(o,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...e.peerStore})),o.events.addEventListener("peer:update",u=>{if(u.detail.previous==null){const l={id:u.detail.peer.id,multiaddrs:u.detail.peer.addresses.map(d=>d.multiaddr)};o.events.safeDispatchEvent("peer:discovery",{detail:l})}}),e.connectionProtector!=null&&this.configureComponent("connectionProtector",e.connectionProtector(o)),this.components.upgrader=new mx(this.components,{connectionEncrypters:(e.connectionEncrypters??[]).map((u,l)=>this.configureComponent(`connection-encryption-${l}`,u(this.components))),streamMuxers:(e.streamMuxers??[]).map((u,l)=>this.configureComponent(`stream-muxers-${l}`,u(this.components))),inboundUpgradeTimeout:e.connectionManager?.inboundUpgradeTimeout,inboundStreamProtocolNegotiationTimeout:e.connectionManager?.inboundStreamProtocolNegotiationTimeout??e.connectionManager?.protocolNegotiationTimeout,outboundStreamProtocolNegotiationTimeout:e.connectionManager?.outboundStreamProtocolNegotiationTimeout??e.connectionManager?.protocolNegotiationTimeout}),this.configureComponent("transportManager",new ox(this.components,e.transportManager)),this.configureComponent("connectionManager",new BS(this.components,e.connectionManager)),e.connectionMonitor?.enabled!==!1&&this.configureComponent("connectionMonitor",new tx(this.components,e.connectionMonitor)),this.configureComponent("registrar",new ix(this.components)),this.configureComponent("addressManager",new k1(this.components,e.addresses));const a=(e.peerRouters??[]).map((u,l)=>this.configureComponent(`peer-router-${l}`,u(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new rx(this.components,{routers:a}));const c=(e.contentRouters??[]).map((u,l)=>this.configureComponent(`content-router-${l}`,u(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new nx(this.components,{routers:c})),this.configureComponent("randomWalk",new sx(this.components)),(e.peerDiscovery??[]).forEach((u,l)=>{this.configureComponent(`peer-discovery-${l}`,u(this.components)).addEventListener("peer",h=>{this.#e(h)})}),e.transports?.forEach((u,l)=>{this.components.transportManager.add(this.configureComponent(`transport-${l}`,u(this.components)))}),e.services!=null)for(const u of Object.keys(e.services)){const l=e.services[u],d=l(this.components);if(d==null){this.log.error("service factory %s returned null or undefined instance",u);continue}this.services[u]=d,this.configureComponent(u,d),d[ha]!=null&&(this.log("registering service %s for content routing",u),c.push(d[ha])),d[pa]!=null&&(this.log("registering service %s for peer routing",u),a.push(d[pa])),d[fa]!=null&&(this.log("registering service %s for peer discovery",u),d[fa].addEventListener?.("peer",h=>{this.#e(h)}))}Y1(o)}configureComponent(e,t){return t==null&&this.log.error("component %s was null or undefined",e),this.components[e]=t,t}async start(){if(this.status==="stopped"){this.status="starting",this.log("libp2p is starting");try{await this.components.beforeStart?.(),await this.components.start(),await this.components.afterStart?.(),this.status="started",this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started")}catch(e){throw this.log.error("An error occurred starting libp2p",e),this.status="started",await this.stop(),e}}}async stop(){this.status==="started"&&(this.log("libp2p is stopping"),this.status="stopping",await this.components.beforeStop?.(),await this.components.stop(),await this.components.afterStop?.(),this.status="stopped",this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}getConnections(e){return this.components.connectionManager.getConnections(e)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const e=new dn;for(const t of this.components.connectionManager.getConnections())e.add(t.remotePeer);return Array.from(e)}async dial(e,t={}){return this.components.connectionManager.openConnection(e,{priority:75,...t})}async dialProtocol(e,t,r={}){if(t==null)throw new z("no protocols were provided to open a stream");if(t=Array.isArray(t)?t:[t],t.length===0)throw new z("no protocols were provided to open a stream");return(await this.dial(e,r)).newStream(t,r)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(e,t={}){Gs(e)&&(e=gt(e.getPeerId()??"")),await this.components.connectionManager.closeConnections(e,t)}async getPublicKey(e,t={}){if(this.log("getPublicKey %p",e),e.publicKey!=null)return e.publicKey;try{const o=await this.peerStore.get(e,t);if(o.id.publicKey!=null)return o.id.publicKey}catch(o){if(o.name!=="NotFoundError")throw o}const r=Ut([$("/pk/"),e.toMultihash().bytes]),s=await this.contentRouting.get(r,t),i=It(s);return await this.peerStore.patch(e,{publicKey:i},t),i}async handle(e,t,r){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async s=>{await this.components.registrar.handle(s,t,r)}))}async unhandle(e,t){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async r=>{await this.components.registrar.unhandle(r,t)}))}async register(e,t,r){return this.components.registrar.register(e,t,r)}unregister(e){this.components.registrar.unregister(e)}async isDialable(e,t={}){return this.components.connectionManager.isDialable(e,t)}#e(e){const{detail:t}=e;if(t.id.toString()===this.peerId.toString()){this.log.error("peer discovery mechanism discovered self");return}this.components.peerStore.merge(t.id,{multiaddrs:t.multiaddrs}).catch(r=>{this.log.error(r)})}}async function bx(n={}){n.privateKey??=await Cm();const e=new wx({...await yv(n),peerId:Lm(n.privateKey)});return n.start!==!1&&await e.start(),e}document.title="v10";const Eo=n=>n.includes("/webrtc/")&&n.includes("/ws/")&&n.includes("/dns"),Ex=document.getElementById("output"),Fs=n=>{const e=document.createElement("div");e.appendChild(document.createTextNode(n)),Ex.append(e)},Ge=await bx({addresses:{listen:["/p2p-circuit","/webrtc"]},transports:[GE({filter:zd}),PE(),u0()],connectionEncrypters:[Wy()],streamMuxers:[hw()],connectionGater:{denyDialMultiaddr:()=>!1},services:{identify:M0(),identifyPush:N0(),ping:H0()}});await Ge.start();function _h(){const n=Ge.getConnections().map(e=>{const t=document.createElement("li");return t.textContent=e.remoteAddr.toString(),t});document.getElementById("connections").replaceChildren(...n)}Ge.addEventListener("connection:open",n=>{_h()});Ge.addEventListener("connection:close",n=>{_h()});Ge.addEventListener("self:peer:update",n=>{console.log(Ge.getMultiaddrs().map(t=>t.toString()));const e=Ge.getMultiaddrs().map(t=>t.toString()).filter(Eo).map(t=>{const r=document.createElement("li");return r.textContent=t,r});document.getElementById("multiaddrs").replaceChildren(...e),vx()});const gl="/dns4/194-11-226-35.k51qzi5uqu5dhlxz4gos5ph4wivip9rgsg6tywpypccb403b0st1nvzhw8as9q.libp2p.direct/tcp/4001/tls/ws/p2p/12D3KooWDfnXqdZfsoqKbcYEDKRttt3adumB5m6tw8YghPwMAz8V";try{await Ge.dial(K(gl)),Fs(`Connected to relay '${gl}'`)}catch(n){console.log(n),Fs(`Error connecting to relay: ${n.message}`)}let qi=[];const vx=async()=>{const n="bafybeigmddlmc235fgegsdagzfbutnqjo2kxamyfrpfziaxrsc6ptb5fnm";try{const{Providers:e}=await fetch(`https://peers.pleb.bot/routing/v1/providers/${n}`).then(r=>r.json()),t=[];for(const r of e)if(r.ID)for(const s of r.Addrs)Eo(s)&&t.push(`${s}/p2p/${r.ID}`);qi=t,console.log({peersDiscovered:qi})}catch(e){console.log(e),Fs(`Error discovering peers: ${e.message}`)}try{const e=Ge.getMultiaddrs().map(s=>s.toString()).filter(Eo);if(!e.length)throw Error("don't have any addresses");const t=JSON.stringify({Providers:[{Schema:"bitswap",Protocol:"transport-bitswap",Signature:"mx5kamm5kzxuCnVJtX3K9DEj8gKlFqXil2x/M8zDTozvzowTY6W+HOALQ2LCkTZCEz4H5qizpnHxPM/rVQ7MNBg",Payload:{Keys:[n],Timestamp:Date.now(),AdvisoryTTL:864e11,ID:Ge.peerId.toString(),Addrs:e}}]}),r=await fetch("https://peers.pleb.bot/routing/v1/providers/",{method:"PUT",body:t});console.log("announced",r)}catch(e){console.log(e),Fs(`Error announcing: ${e.message}`)}qi.forEach(e=>{console.log("dialing",e),Ge.dial(K(e)).catch(console.log)})};
